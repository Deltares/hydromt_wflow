
<!DOCTYPE html>


<html lang="en" data-content_root="../../" data-theme="light">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hydromt_wflow.wflow &#8212; HydroMT Wflow  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "light";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/theme-deltares.css?v=5ca2d357" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/hydromt_wflow/wflow';</script>
    <link rel="icon" href="../../_static/hydromt-icon.svg"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="1.0.0.dev" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="light">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
    
    <img src="../../_static/hydromt-icon.svg" class="logo__image only-light" alt=""/>
    <img src="../../_static/hydromt-icon.svg" class="logo__image only-dark pst-js-only" alt=""/>
  
  
    <p class="title logo__title">HydroMT Wflow</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../getting_started/intro.html">
    Getting started
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../user_guide/intro.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../dev_guide/intro.html">
    Developments
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://deltares.github.io/hydromt/latest/index.html">
    HydroMT core
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/Deltares/hydromt_wflow" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fab fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://deltares.github.io/Wflow.jl/dev/" title="Wflow" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../_static/wflow_logo.png" class="icon-link-image" alt="Wflow"/></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.deltares.nl/en/" title="Deltares" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../_static/deltares-blue.svg" class="icon-link-image" alt="Deltares"/></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../getting_started/intro.html">
    Getting started
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../user_guide/intro.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../dev_guide/intro.html">
    Developments
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://deltares.github.io/hydromt/latest/index.html">
    HydroMT core
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/Deltares/hydromt_wflow" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fab fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://deltares.github.io/Wflow.jl/dev/" title="Wflow" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../_static/wflow_logo.png" class="icon-link-image" alt="Wflow"/></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.deltares.nl/en/" title="Deltares" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../_static/deltares-blue.svg" class="icon-link-image" alt="Deltares"/></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">hydromt_wflow.wflow</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for hydromt_wflow.wflow</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Implement Wflow model class.&quot;&quot;&quot;</span>

<span class="c1"># Implement model class following model API</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">glob</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">os.path</span><span class="w"> </span><span class="kn">import</span> <span class="n">basename</span><span class="p">,</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">isdir</span><span class="p">,</span> <span class="n">isfile</span><span class="p">,</span> <span class="n">join</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">hydromt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pyflwdir</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pyproj</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tomllib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dask.diagnostics</span><span class="w"> </span><span class="kn">import</span> <span class="n">ProgressBar</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydromt</span><span class="w"> </span><span class="kn">import</span> <span class="n">hydromt_step</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydromt._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NoDataStrategy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydromt.gis</span><span class="w"> </span><span class="kn">import</span> <span class="n">flw</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydromt.model</span><span class="w"> </span><span class="kn">import</span> <span class="n">Model</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydromt.model.processes.basin_mask</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_basin_geometry</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydromt.model.processes.region</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">_parse_region_value</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">hydromt_wflow.utils</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">utils</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydromt_wflow</span><span class="w"> </span><span class="kn">import</span> <span class="n">workflows</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydromt_wflow.components</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">WflowConfigComponent</span><span class="p">,</span>
    <span class="n">WflowGeomsComponent</span><span class="p">,</span>
    <span class="n">WflowStatesComponent</span><span class="p">,</span>
    <span class="n">WflowStaticmapsComponent</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydromt_wflow.naming</span><span class="w"> </span><span class="kn">import</span> <span class="n">_create_hydromt_wflow_mapping_sbm</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;WflowModel&quot;</span><span class="p">]</span>
<span class="n">__hydromt_eps__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;WflowModel&quot;</span><span class="p">]</span>  <span class="c1"># core entrypoints</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;hydromt.</span><span class="si">{</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="WflowModel">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.html#hydromt_wflow.WflowModel">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WflowModel</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read or Write a wflow model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    root : str, optional</span>
<span class="sd">        Model root, by default None (current working directory)</span>
<span class="sd">    config_filename : str, optional</span>
<span class="sd">        A path relative to the root where the configuration file will</span>
<span class="sd">        be read and written if user does not provide a path themselves.</span>
<span class="sd">        By default &quot;wflow_sbm.toml&quot;</span>
<span class="sd">    mode : {&#39;r&#39;,&#39;r+&#39;,&#39;w&#39;}, optional</span>
<span class="sd">        read/append/write mode, by default &quot;w&quot;</span>
<span class="sd">    data_libs : list[str] | str, optional</span>
<span class="sd">        List of data catalog configuration files, by default None</span>
<span class="sd">    **catalog_keys:</span>
<span class="sd">        Additional keyword arguments to be passed down to the DataCatalog.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;wflow&quot;</span>

    <span class="n">_MODEL_VERSION</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># TODO supported model version should be filled by the plugins</span>
    <span class="c1"># e.g. _MODEL_VERSION = &quot;&gt;=1.0, &lt;1.1</span>

    <span class="n">_DATADIR</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">DATADIR</span>
    <span class="n">_CATALOGS</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">_DATADIR</span><span class="p">,</span> <span class="s2">&quot;parameters_data.yml&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="WflowModel.__init__">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.html#hydromt_wflow.WflowModel.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">root</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">config_filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;wflow_sbm.toml&quot;</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="n">data_libs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">catalog_keys</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Define components when they are implemented</span>
        <span class="c1"># This is when config_fn should be able to be passed to ConfigComponent later</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;config&quot;</span><span class="p">:</span> <span class="n">WflowConfigComponent</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">filename</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">config_filename</span><span class="p">),</span>
                <span class="n">default_template_filename</span><span class="o">=</span><span class="n">join</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_DATADIR</span><span class="p">,</span> <span class="s2">&quot;wflow&quot;</span><span class="p">,</span> <span class="s2">&quot;wflow_sbm.toml&quot;</span>
                <span class="p">),</span>
            <span class="p">),</span>
            <span class="s2">&quot;geoms&quot;</span><span class="p">:</span> <span class="n">WflowGeomsComponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region_component</span><span class="o">=</span><span class="s2">&quot;staticmaps&quot;</span><span class="p">),</span>
            <span class="s2">&quot;states&quot;</span><span class="p">:</span> <span class="n">WflowStatesComponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">region_component</span><span class="o">=</span><span class="s2">&quot;staticmaps&quot;</span><span class="p">),</span>
            <span class="s2">&quot;staticmaps&quot;</span><span class="p">:</span> <span class="n">WflowStaticmapsComponent</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">root</span><span class="p">,</span>
            <span class="n">components</span><span class="o">=</span><span class="n">components</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">region_component</span><span class="o">=</span><span class="s2">&quot;staticmaps&quot;</span><span class="p">,</span>
            <span class="n">data_libs</span><span class="o">=</span><span class="n">data_libs</span><span class="p">,</span>
            <span class="o">**</span><span class="n">catalog_keys</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># wflow specific</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flwdir</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">from_yml</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_CATALOGS</span><span class="p">)</span>

        <span class="c1"># Supported Wflow.jl version</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Supported Wflow.jl version v1+&quot;</span><span class="p">)</span>
        <span class="c1"># hydromt mapping and wflow variable names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span> <span class="o">=</span> <span class="n">_create_hydromt_wflow_mapping_sbm</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">data</span>
        <span class="p">)</span>
        <span class="c1"># Read model from disk when in read mode</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;r&quot;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;r+&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">config_filename</span><span class="o">=</span><span class="n">config_filename</span><span class="p">)</span></div>


    <span class="c1">## Properties</span>
    <span class="c1"># Components</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">config</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">WflowConfigComponent</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the config component.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;config&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">geoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">WflowGeomsComponent</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the WflowGeomsComponent instance.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;geoms&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">states</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">WflowStatesComponent</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the states component.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;states&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">staticmaps</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">WflowStaticmapsComponent</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the staticmaps component.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;staticmaps&quot;</span><span class="p">]</span>

    <span class="c1"># Non model component properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">basins</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a basin(s) geometry as a geopandas.GeoDataFrame.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;basins&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;basins&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span>
                <span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">vectorize</span><span class="p">()</span>
                <span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;basins&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Basin map </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s1">&#39;basins&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> not found in grid.&quot;</span><span class="p">)</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">gdf</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">basins_highres</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a high resolution basin(s) geometry.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;basins_highres&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;basins_highres&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basins</span>
        <span class="k">return</span> <span class="n">gdf</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rivers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a river geometry as a geopandas.GeoDataFrame.</span>

<span class="sd">        If available, the stream order and upstream area values are added to</span>
<span class="sd">        the geometry properties.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;rivers&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rivers&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">rivmsk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="c1"># Check if there are river cells in the model before continuing</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rivmsk</span><span class="p">):</span>
                <span class="c1"># add stream order &#39;strord&#39; column</span>
                <span class="n">strord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="o">.</span><span class="n">stream_order</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">rivmsk</span><span class="p">)</span>
                <span class="n">feats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="o">.</span><span class="n">streams</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">rivmsk</span><span class="p">,</span> <span class="n">strord</span><span class="o">=</span><span class="n">strord</span><span class="p">)</span>
                <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="o">.</span><span class="n">from_features</span><span class="p">(</span><span class="n">feats</span><span class="p">)</span>
                <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">CRS</span><span class="o">.</span><span class="n">from_user_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;rivers&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No river cells detected in the selected basin.&quot;</span><span class="p">)</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">gdf</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_grid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the grid data with a DataArray or Dataset.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="c1">## SETUP METHODS</span>
<div class="viewcode-block" id="WflowModel.setup_config">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_config.html#hydromt_wflow.WflowModel.setup_config">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the config dictionary at key(s) with values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : Dict[str, Any]</span>
<span class="sd">            A dictionary with the values to be set. keys can be dotted like in</span>
<span class="sd">            :py:meth:`~hydromt_wflow.components.config.WflowConfigComponent.set`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Setting data as a nested dictionary::</span>


<span class="sd">            &gt;&gt; self.setup_config({&#39;a&#39;: 1, &#39;b&#39;: {&#39;c&#39;: {&#39;d&#39;: 2}}})</span>
<span class="sd">            &gt;&gt; self.config.data</span>
<span class="sd">            {&#39;a&#39;: 1, &#39;b&#39;: {&#39;c&#39;: {&#39;d&#39;: 2}}}</span>

<span class="sd">        Setting data using dotted notation::</span>

<span class="sd">            &gt;&gt; self.setup_config({&#39;a.d.f.g&#39;: 1, &#39;b&#39;: {&#39;c&#39;: {&#39;d&#39;: 2}}})</span>
<span class="sd">            &gt;&gt; self.config.data</span>
<span class="sd">            {&#39;a&#39;: {&#39;d&#39;:{&#39;f&#39;:{&#39;g&#39;: 1}}}, &#39;b&#39;: {&#39;c&#39;: {&#39;d&#39;: 2}}}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_basemaps">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_basemaps.html#hydromt_wflow.WflowModel.setup_basemaps">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_basemaps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">region</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">hydrography_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">basin_index_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">res</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">120.0</span><span class="p">,</span>
        <span class="n">upscale_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ihu&quot;</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;basin__local_drain_direction&quot;</span><span class="p">:</span> <span class="s2">&quot;local_drain_direction&quot;</span><span class="p">,</span>
            <span class="s2">&quot;subbasin_location__count&quot;</span><span class="p">:</span> <span class="s2">&quot;subcatchment&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land_surface__slope&quot;</span><span class="p">:</span> <span class="s2">&quot;land_slope&quot;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the DEM and flow direction for a Wflow model.</span>

<span class="sd">        Setup basemaps sets the `region` of interest and `res`</span>
<span class="sd">        (resolution in degrees) of the model.</span>
<span class="sd">        All DEM and flow direction related maps are then build.</span>

<span class="sd">        We strongly recommend using the region types ``basin`` or ``subbasin`` to build</span>
<span class="sd">        a wflow model. If you know what you are doing, you can also use the ``bbox``</span>
<span class="sd">        region type (e.g for an island) with the bbox coordinates in EPSG 4326 or the</span>
<span class="sd">        ``geom`` region type (e.g. basin polygons have been pre-processed and match</span>
<span class="sd">        EXACTLY with ``hydrography_fn``).</span>

<span class="sd">        E.g. of `region` argument for a subbasin based on a point and snapped using</span>
<span class="sd">        upstream area threshold in `hydrography_fn`, where the maximum boundary box of</span>
<span class="sd">        the output subbasin is known:</span>
<span class="sd">        region = {&#39;subbasin&#39;: [x,y], &#39;uparea&#39;: 10, &#39;bounds&#39;: [xmin, ymin, xmax, ymax]}</span>

<span class="sd">        (Sub)Basin delineation is done using hydromt.workflows.get_basin_geometry</span>
<span class="sd">        method. Because the delineation is computed from the flow direction data in</span>
<span class="sd">        memory, to avoid memory error when using large datasets in `hydrography_fn`, the</span>
<span class="sd">        user can either supply &#39;bounds&#39; in `region` or a basin index dataset in</span>
<span class="sd">        `basin_index_fn` to limit the flow direction data to the region of interest.</span>
<span class="sd">        The basin index dataset is a GeoDataframe containing either basins polygons or</span>
<span class="sd">        bounding boxes of basin boundaries. To select the correct basins, basin ID</span>
<span class="sd">        &#39;basins&#39; in `hydrography_fn` and `basin_index_fn` should match.</span>

<span class="sd">        If the model resolution is larger than the source data resolution,</span>
<span class="sd">        the flow direction is upscaled using the `upscale_method`, by default the</span>
<span class="sd">        Iterative Hydrography Upscaling (IHU).</span>

<span class="sd">        The default `hydrography_fn` is &quot;merit_hydro&quot;</span>
<span class="sd">        (`MERIT hydro &lt;http://hydro.iis.u-tokyo.ac.jp/~yamadai/MERIT_Hydro/index.html&gt;`_</span>
<span class="sd">        at 3 arcsec resolution).</span>
<span class="sd">        Alternative sources include &quot;merit_hydro_1k&quot; at 30 arcsec resolution.</span>
<span class="sd">        Users can also supply their own elevation and flow direction data</span>
<span class="sd">        in any CRS and not only EPSG:4326. The ArcGIS D8 convention is supported</span>
<span class="sd">        (see also `PyFlwDir documentation</span>
<span class="sd">        &lt;https://deltares.github.io/pyflwdir/latest/_examples/flwdir.html&gt;`).</span>

<span class="sd">        Note that in order to define the region, using points or bounding box,</span>
<span class="sd">        the coordinates of the points / bounding box</span>
<span class="sd">        should be in the same CRS than the hydrography data.</span>
<span class="sd">        The wflow model will then also be in the same CRS than the</span>
<span class="sd">        hydrography data in order to avoid assumptions and reprojection errors.</span>
<span class="sd">        If the user wishes to use a different CRS,</span>
<span class="sd">        we recommend first to reproject the hydrography data separately,</span>
<span class="sd">        before calling hydromt build.</span>
<span class="sd">        You can find examples on how to reproject or prepare hydrography data in the</span>
<span class="sd">        `prepare flow directions example notebook</span>
<span class="sd">        &lt;https://deltares.github.io/hydromt_wflow/latest/_examples/prepare_ldd.html&gt;`_.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **local_drain_direction** map: flow direction in LDD format [-]</span>
<span class="sd">        * **subcatchment** map: basin ID map [-]</span>
<span class="sd">        * **meta_upstream_area** map: upstream area [km2]</span>
<span class="sd">        * **meta_streamorder** map: Strahler stream order [-]</span>
<span class="sd">        * **land_elevation** map: average elevation [m+REF]</span>
<span class="sd">        * **meta_subgrid_elevation** map: subgrid outlet elevation [m+REF]</span>
<span class="sd">        * **land_slope** map: average land surface slope [m/m]</span>
<span class="sd">        * **basins** geom: basins boundary vector</span>
<span class="sd">        * **region** geom: region boundary vector</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        region : dict</span>
<span class="sd">            Dictionary describing region of interest.</span>
<span class="sd">            See :py:meth:`hydromt.workflows.basin_mask.parse_region()` for all options</span>
<span class="sd">        hydrography_fn : str, xarray.Dataset</span>
<span class="sd">            Name of RasterDataset source for basemap parameters.</span>

<span class="sd">            * Required variables: &#39;flwdir&#39; [LLD or D8 or NEXTXY], &#39;elevtn&#39; [m+REF]</span>

<span class="sd">            * Required variables if used with `basin_index_fn`: &#39;basins&#39; [-]</span>

<span class="sd">            * Required variables if used for snapping in `region`: &#39;uparea&#39; [km2],</span>
<span class="sd">                &#39;strord&#39; [-]</span>

<span class="sd">            * Optional variables: &#39;lndslp&#39; [m/m], &#39;mask&#39; [bool]</span>
<span class="sd">        basin_index_fn : str, geopandas.GeoDataFrame, optional</span>
<span class="sd">            Name of GeoDataFrame source for basin_index data linked to hydrography_fn.</span>

<span class="sd">            * Required variables: &#39;basid&#39; [-]</span>
<span class="sd">        res : float, optional</span>
<span class="sd">            Output model resolution</span>
<span class="sd">        upscale_method : {&#39;ihu&#39;, &#39;eam&#39;, &#39;dmm&#39;}, optional</span>
<span class="sd">            Upscaling method for flow direction data, by default &#39;ihu&#39;.</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hydromt.workflows.parse_region</span>
<span class="sd">        hydromt.workflows.get_basin_geometry</span>
<span class="sd">        workflows.hydrography</span>
<span class="sd">        workflows.topography</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing base hydrography basemaps.&quot;</span><span class="p">)</span>
        <span class="c1"># update self._MAPS and self._WFLOW_NAMES with user defined output names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>

        <span class="n">geometries</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">ds_org</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">parse_region</span><span class="p">(</span>
            <span class="n">data_catalog</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="p">,</span>
            <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span>
            <span class="n">hydrography_fn</span><span class="o">=</span><span class="n">hydrography_fn</span><span class="p">,</span>
            <span class="n">resolution</span><span class="o">=</span><span class="n">res</span><span class="p">,</span>
            <span class="n">basin_index_fn</span><span class="o">=</span><span class="n">basin_index_fn</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">_geom</span> <span class="ow">in</span> <span class="n">geometries</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">_geom</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># setup hydrography maps and set staticmap attribute with renamed maps</span>
        <span class="n">ds_base</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">hydrography</span><span class="p">(</span>
            <span class="n">ds</span><span class="o">=</span><span class="n">ds_org</span><span class="p">,</span>
            <span class="n">res</span><span class="o">=</span><span class="n">res</span><span class="p">,</span>
            <span class="n">xy</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span>
            <span class="n">upscale_method</span><span class="o">=</span><span class="n">upscale_method</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Rename and add to grid</span>
        <span class="c1"># rename idx_out coords</span>
        <span class="k">if</span> <span class="s2">&quot;idx_out&quot;</span> <span class="ow">in</span> <span class="n">ds_base</span><span class="p">:</span>
            <span class="n">ds_base</span> <span class="o">=</span> <span class="n">ds_base</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;idx_out&quot;</span><span class="p">:</span> <span class="s2">&quot;meta_subgrid_outlet_idx&quot;</span><span class="p">})</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_base</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_base</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>

        <span class="c1"># update config</span>
        <span class="c1"># skip adding elevtn to config as it will only be used if floodplain 2d are on</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">rmdict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;elevtn&quot;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">ds_base</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Call basins once to set it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basins</span>

        <span class="c1"># setup topography maps</span>
        <span class="n">ds_topo</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">topography</span><span class="p">(</span>
            <span class="n">ds</span><span class="o">=</span><span class="n">ds_org</span><span class="p">,</span> <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
        <span class="p">)</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_topo</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_topo</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>

        <span class="c1"># update config</span>
        <span class="c1"># skip adding elevtn to config as it will only be used if floodplain 2d are on</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">rmdict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;elevtn&quot;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">ds_topo</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>

        <span class="c1"># update toml for degree/meters if needed</span>
        <span class="k">if</span> <span class="n">ds_base</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">is_projected</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.cell_length_in_meter__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_rivers">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_rivers.html#hydromt_wflow.WflowModel.setup_rivers">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_rivers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hydrography_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">river_geom_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">river_upa</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">rivdph_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;powlaw&quot;</span><span class="p">,</span>
        <span class="n">slope_len</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2e3</span><span class="p">,</span>
        <span class="n">min_rivlen_ratio</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">min_rivdph</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">min_rivwth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">smooth_len</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5e3</span><span class="p">,</span>
        <span class="n">rivman_mapping_fn</span><span class="p">:</span> <span class="nb">str</span>
        <span class="o">|</span> <span class="n">Path</span>
        <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="s2">&quot;roughness_river_mapping_default&quot;</span><span class="p">,</span>
        <span class="n">elevtn_map</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;land_elevation&quot;</span><span class="p">,</span>
        <span class="n">river_routing</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;kinematic-wave&quot;</span><span class="p">,</span>
        <span class="n">connectivity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
        <span class="n">strord_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;meta_streamorder&quot;</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;river_location__mask&quot;</span><span class="p">:</span> <span class="s2">&quot;river_mask&quot;</span><span class="p">,</span>
            <span class="s2">&quot;river__length&quot;</span><span class="p">:</span> <span class="s2">&quot;river_length&quot;</span><span class="p">,</span>
            <span class="s2">&quot;river__width&quot;</span><span class="p">:</span> <span class="s2">&quot;river_width&quot;</span><span class="p">,</span>
            <span class="s2">&quot;river_bank_water__depth&quot;</span><span class="p">:</span> <span class="s2">&quot;river_depth&quot;</span><span class="p">,</span>
            <span class="s2">&quot;river__slope&quot;</span><span class="p">:</span> <span class="s2">&quot;river_slope&quot;</span><span class="p">,</span>
            <span class="s2">&quot;river_water_flow__manning_n_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;river_manning_n&quot;</span><span class="p">,</span>
            <span class="s2">&quot;river_bank_water__elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;river_bank_elevation&quot;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set all river parameter maps.</span>

<span class="sd">        The river mask is defined by all cells with a minimum upstream area threshold</span>
<span class="sd">        ``river_upa`` [km2].</span>

<span class="sd">        The river length is defined as the distance from the subgrid outlet pixel to</span>
<span class="sd">        the next upstream subgrid outlet pixel. The ``min_rivlen_ratio`` is the minimum</span>
<span class="sd">        global river length to avg. cell resolution ratio and is used as a threshold in</span>
<span class="sd">        window based smoothing of river length.</span>

<span class="sd">        The river slope is derived from the subgrid elevation difference between pixels</span>
<span class="sd">        at a half distance ``slope_len`` [m] up-</span>
<span class="sd">        and downstream from the subgrid outlet pixel.</span>

<span class="sd">        The river manning roughness coefficient is derived based on reclassification</span>
<span class="sd">        of the streamorder map using a lookup table ``rivman_mapping_fn``.</span>

<span class="sd">        The river width is derived from the nearest river segment in ``river_geom_fn``.</span>
<span class="sd">        Data gaps are filled by the nearest valid upstream value and averaged along</span>
<span class="sd">        the flow directions over a length ``smooth_len`` [m]</span>

<span class="sd">        The river depth can be directly derived from ``river_geom_fn`` property or</span>
<span class="sd">        calculated using the ``rivdph_method``, by default powlaw:</span>
<span class="sd">        h = hc*Qbf**hp, which is based on qbankfull discharge from the nearest river</span>
<span class="sd">        segment in ``river_geom_fn`` and takes optional arguments for the hc</span>
<span class="sd">        (default = 0.27) and hp (default = 0.30) parameters. For other methods see</span>
<span class="sd">        :py:meth:`hydromt.workflows.river_depth`.</span>

<span class="sd">        If ``river_routing`` is set to &quot;local-inertial&quot;, the bankfull elevation map</span>
<span class="sd">        can be conditioned based on the average cell elevation (&quot;land_elevation&quot;)</span>
<span class="sd">        or subgrid outlet pixel elevation (&quot;meta_subgrid_elevation&quot;).</span>
<span class="sd">        The subgrid elevation might provide a better representation</span>
<span class="sd">        of the river elevation profile, however in combination with</span>
<span class="sd">        local-inertial land routing (see :py:meth:`setup_floodplains`)</span>
<span class="sd">        the subgrid elevation will likely overestimate the floodplain storage capacity.</span>
<span class="sd">        Note that the same input elevation map should be used for river bankfull</span>
<span class="sd">        elevation and land elevation when using local-inertial land routing.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **wflow_river** map: river mask [-]</span>
<span class="sd">        * **river_length** map: river length [m]</span>
<span class="sd">        * **river_width** map: river width [m]</span>
<span class="sd">        * **river_depth** map: bankfull river depth [m]</span>
<span class="sd">        * **river_slope** map: river slope [m/m]</span>
<span class="sd">        * **river_manning_n** map: Manning coefficient for river cells [s.m^1/3]</span>
<span class="sd">        * **rivers** geom: river vector based on wflow_river mask</span>
<span class="sd">        * **river_bank_elevation** map: hydrologically conditioned elevation [m+REF]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hydrography_fn : str, Path, xarray.Dataset</span>
<span class="sd">            Name of RasterDataset source for hydrography data.</span>
<span class="sd">            Must be same as setup_basemaps for consistent results.</span>

<span class="sd">            * Required variables: &#39;flwdir&#39; [LLD or D8 or NEXTXY], &#39;uparea&#39; [km2],</span>
<span class="sd">              &#39;elevtn&#39;[m+REF]</span>
<span class="sd">            * Optional variables: &#39;rivwth&#39; [m], &#39;qbankfull&#39; [m3/s]</span>
<span class="sd">        river_geom_fn : str, Path, geopandas.GeoDataFrame, optional</span>
<span class="sd">            Name of GeoDataFrame source for river data.</span>

<span class="sd">            * Required variables: &#39;rivwth&#39; [m], &#39;rivdph&#39; [m] or &#39;qbankfull&#39; [m3/s]</span>
<span class="sd">        river_upa : float, optional</span>
<span class="sd">            Minimum upstream area threshold for the river map [km2]. By default 30.0</span>
<span class="sd">        slope_len : float, optional</span>
<span class="sd">            Length over which the river slope is calculated [km]. By default 2.0</span>
<span class="sd">        min_rivlen_ratio: float, optional</span>
<span class="sd">            Ratio of cell resolution used minimum length threshold in a moving</span>
<span class="sd">            window based smoothing of river length, by default 0.0</span>
<span class="sd">            The river length smoothing is skipped if `min_riverlen_ratio` = 0.</span>
<span class="sd">            For details about the river length smoothing,</span>
<span class="sd">            see :py:meth:`pyflwdir.FlwdirRaster.smooth_rivlen`</span>
<span class="sd">        rivdph_method : {&#39;gvf&#39;, &#39;manning&#39;, &#39;powlaw&#39;}</span>
<span class="sd">            see :py:meth:`hydromt.workflows.river_depth` for details, by default \</span>
<span class="sd">                &quot;powlaw&quot;</span>
<span class="sd">        river_routing : {&#39;kinematic-wave&#39;, &#39;local-inertial&#39;}</span>
<span class="sd">            Routing methodology to be used, by default &quot;kinematic-wave&quot;.</span>
<span class="sd">        smooth_len : float, optional</span>
<span class="sd">            Length [m] over which to smooth the output river width and depth,</span>
<span class="sd">            by default 5e3</span>
<span class="sd">        min_rivdph : float, optional</span>
<span class="sd">            Minimum river depth [m], by default 1.0</span>
<span class="sd">        min_rivwth : float, optional</span>
<span class="sd">            Minimum river width [m], by default 30.0</span>
<span class="sd">        elevtn_map : str, optional</span>
<span class="sd">            Name of the elevation map in the current WflowModel.grid.</span>
<span class="sd">            By default &quot;land_elevation&quot;</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        workflows.river_bathymetry</span>
<span class="sd">        hydromt.workflows.river_depth</span>
<span class="sd">        pyflwdir.FlwdirRaster.river_depth</span>
<span class="sd">        setup_floodplains</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing river maps.&quot;</span><span class="p">)</span>
        <span class="c1"># update self._MAPS and self._WFLOW_NAMES with user defined output names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>
        <span class="c1"># check for streamorder</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;strord&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">strord_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Streamorder map </span><span class="si">{</span><span class="n">strord_name</span><span class="si">}</span><span class="s2"> not found in grid. &quot;</span>
                    <span class="s2">&quot;Please run setup_basemaps or update the strord_name argument.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;strord&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">strord_name</span>

        <span class="c1"># Check that river_upa threshold is bigger than the maximum uparea in the grid</span>
        <span class="k">if</span> <span class="n">river_upa</span> <span class="o">&gt;</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;uparea&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">max</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;river_upa threshold </span><span class="si">{</span><span class="n">river_upa</span><span class="si">}</span><span class="s2"> should be larger than the maximum </span><span class="se">\</span>
<span class="s2">uparea in the grid </span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s1">&#39;uparea&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span><span class="si">}</span><span class="s2"> in order </span><span class="se">\</span>
<span class="s2">to create river cells.&quot;</span>
            <span class="p">)</span>

        <span class="n">rivdph_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gvf&quot;</span><span class="p">,</span> <span class="s2">&quot;manning&quot;</span><span class="p">,</span> <span class="s2">&quot;powlaw&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rivdph_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rivdph_methods</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">rivdph_method</span><span class="si">}</span><span class="s1">&quot; unknown. Select from </span><span class="si">{</span><span class="n">rivdph_methods</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">routing_options</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;kinematic-wave&quot;</span><span class="p">,</span> <span class="s2">&quot;local-inertial&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">river_routing</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">routing_options</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;river_routing=&quot;</span><span class="si">{</span><span class="n">river_routing</span><span class="si">}</span><span class="s1">&quot; unknown. </span><span class="se">\</span>
<span class="s1">Select from </span><span class="si">{</span><span class="n">routing_options</span><span class="si">}</span><span class="s1">.&#39;</span>
            <span class="p">)</span>

        <span class="c1"># read data</span>
        <span class="n">ds_hydro</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">hydrography_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">10</span>
        <span class="p">)</span>
        <span class="n">ds_hydro</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_hydro</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">geometry_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>

        <span class="c1"># get rivmsk, rivlen, rivslp</span>
        <span class="c1"># read model maps and revert wflow to hydromt map names</span>
        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">}</span>
        <span class="n">ds_riv</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">river</span><span class="p">(</span>
            <span class="n">ds</span><span class="o">=</span><span class="n">ds_hydro</span><span class="p">,</span>
            <span class="n">ds_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">river_upa</span><span class="o">=</span><span class="n">river_upa</span><span class="p">,</span>
            <span class="n">slope_len</span><span class="o">=</span><span class="n">slope_len</span><span class="p">,</span>
            <span class="n">channel_dir</span><span class="o">=</span><span class="s2">&quot;up&quot;</span><span class="p">,</span>
            <span class="n">min_rivlen_ratio</span><span class="o">=</span><span class="n">min_rivlen_ratio</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ds_riv</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_riv</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">assign_attrs</span><span class="p">(</span>
            <span class="n">river_upa</span><span class="o">=</span><span class="n">river_upa</span><span class="p">,</span> <span class="n">slope_len</span><span class="o">=</span><span class="n">slope_len</span><span class="p">,</span> <span class="n">min_rivlen_ratio</span><span class="o">=</span><span class="n">min_rivlen_ratio</span>
        <span class="p">)</span>
        <span class="n">dvars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">,</span> <span class="s2">&quot;rivlen&quot;</span><span class="p">,</span> <span class="s2">&quot;rivslp&quot;</span><span class="p">]</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dvars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_riv</span><span class="p">[</span><span class="n">dvars</span><span class="p">]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
        <span class="c1"># update config</span>
        <span class="k">for</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="n">dvars</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dvar</span> <span class="o">==</span> <span class="s2">&quot;rivmsk&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="n">dvar</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="n">dvar</span><span class="p">])</span>

        <span class="c1"># TODO make separate workflows.river_manning  method</span>
        <span class="c1"># Make river_manning_n map from csv file with mapping</span>
        <span class="c1"># between streamorder and river_manning_n value</span>
        <span class="n">strord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;strord&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span><span class="n">rivman_mapping_fn</span><span class="p">)</span>
        <span class="c1"># max streamorder value above which values get the same river_manning_n value</span>
        <span class="n">max_str</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">nodata</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># if streamorder value larger than max_str, assign last value</span>
        <span class="n">strord</span> <span class="o">=</span> <span class="n">strord</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">strord</span> <span class="o">&lt;=</span> <span class="n">max_str</span><span class="p">,</span> <span class="n">max_str</span><span class="p">)</span>
        <span class="c1"># handle missing value (last row of csv is mapping of missing values)</span>
        <span class="n">strord</span> <span class="o">=</span> <span class="n">strord</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">strord</span> <span class="o">!=</span> <span class="n">strord</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span> <span class="n">nodata</span><span class="p">)</span>
        <span class="n">strord</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">set_nodata</span><span class="p">(</span><span class="n">nodata</span><span class="p">)</span>
        <span class="n">ds_nriver</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">landuse</span><span class="p">(</span>
            <span class="n">da</span><span class="o">=</span><span class="n">strord</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_nriver</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_nriver</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
        <span class="c1"># update config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">ds_nriver</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>

        <span class="c1"># get rivdph, rivwth</span>
        <span class="c1"># while we still have setup_riverwidth one can skip river_bathymetry here</span>
        <span class="c1"># TODO make river_geom_fn required after removing setup_riverwidth</span>
        <span class="k">if</span> <span class="n">river_geom_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gdf_riv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
                <span class="n">river_geom_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span>
            <span class="p">)</span>
            <span class="c1"># reread model data to get river maps</span>
            <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span>
            <span class="p">}</span>
            <span class="n">ds_riv1</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">river_bathymetry</span><span class="p">(</span>
                <span class="n">ds_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
                <span class="n">gdf_riv</span><span class="o">=</span><span class="n">gdf_riv</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">rivdph_method</span><span class="p">,</span>
                <span class="n">smooth_len</span><span class="o">=</span><span class="n">smooth_len</span><span class="p">,</span>
                <span class="n">min_rivdph</span><span class="o">=</span><span class="n">min_rivdph</span><span class="p">,</span>
                <span class="n">min_rivwth</span><span class="o">=</span><span class="n">min_rivwth</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_riv1</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_riv1</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
            <span class="c1"># update config</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">ds_riv1</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adding rivers vector to geoms.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;rivers&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;rivers&quot;</span><span class="p">)</span>  <span class="c1"># remove old rivers if in geoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rivers</span>  <span class="c1"># add new rivers to geoms</span>

        <span class="c1"># Add hydrologically conditioned elevation map for the river, if required</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Update wflow config model.river_routing=&quot;</span><span class="si">{</span><span class="n">river_routing</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.river_routing&quot;</span><span class="p">,</span> <span class="n">river_routing</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">river_routing</span> <span class="o">==</span> <span class="s2">&quot;local-inertial&quot;</span><span class="p">:</span>
            <span class="n">postfix</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;land_elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;_avg&quot;</span><span class="p">,</span>
                <span class="s2">&quot;meta_subgrid_elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;_subgrid&quot;</span><span class="p">,</span>
            <span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">elevtn_map</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;river_bank_elevation</span><span class="si">{</span><span class="n">postfix</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="c1"># Check if users wanted a specific name for the hydrodem</span>
            <span class="n">hydrodem_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;hydrodem&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">hydrodem_var</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">output_names</span><span class="p">[</span><span class="n">hydrodem_var</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="n">hydrodem_var</span><span class="p">:</span> <span class="n">name</span><span class="p">})</span>

            <span class="n">ds_out</span> <span class="o">=</span> <span class="n">flw</span><span class="o">.</span><span class="n">dem_adjust</span><span class="p">(</span>
                <span class="n">da_flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;flwdir&quot;</span><span class="p">]],</span>
                <span class="n">da_elevtn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">elevtn_map</span><span class="p">],</span>
                <span class="n">da_rivmsk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]],</span>
                <span class="n">flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span>
                <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
                <span class="n">river_d8</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_out</span><span class="p">)</span>

            <span class="c1"># update toml model.river_routing</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_floodplains">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_floodplains.html#hydromt_wflow.WflowModel.setup_floodplains">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_floodplains</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hydrography_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">floodplain_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="c1">### Options for 1D floodplains</span>
        <span class="n">river_upa</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">flood_depths</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">],</span>
        <span class="c1">### Options for 2D floodplains</span>
        <span class="n">elevtn_map</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;land_elevation&quot;</span><span class="p">,</span>
        <span class="n">connectivity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;floodplain_water__sum_of_volume-per-depth&quot;</span><span class="p">:</span> <span class="s2">&quot;floodplain_volume&quot;</span><span class="p">,</span>
            <span class="s2">&quot;river_bank_elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;river_bank_elevation_avg_D4&quot;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add floodplain information to the model schematisation.</span>

<span class="sd">        The user can define what type of floodplains are required (1D or 2D),</span>
<span class="sd">        through the ``floodplain_type`` argument.</span>

<span class="sd">        If ``floodplain_type`` is set to &quot;1d&quot;, a floodplain profile is derived for every</span>
<span class="sd">        river cell. It adds a map with floodplain volume per flood depth,</span>
<span class="sd">        which is used in the wflow 1D floodplain schematisation.</span>

<span class="sd">        Note, it is important to use the same river uparea value as used in the</span>
<span class="sd">        :py:meth:`setup_rivers` method.</span>

<span class="sd">        If ``floodplain_type`` is set to &quot;2d&quot;, this component adds</span>
<span class="sd">        a hydrologically conditioned elevation (river_bank_elevation) map for</span>
<span class="sd">        land routing (local-inertial). For this options, landcells need to be</span>
<span class="sd">        conditioned to D4 flow directions otherwise pits may remain in the land cells.</span>

<span class="sd">        The conditioned elevation can be based on the average cell elevation</span>
<span class="sd">        (&quot;land_elevation&quot;) or subgrid outlet pixel elevation (&quot;meta_subgrid_elevation&quot;).</span>
<span class="sd">        Note that the subgrid elevation will likely overestimate</span>
<span class="sd">        the floodplain storage capacity.</span>

<span class="sd">        Additionally, note that the same input elevation map should be used for river</span>
<span class="sd">        bankfull elevation and land elevation when using local-inertial land routing.</span>

<span class="sd">        Requires :py:meth:`setup_rivers` to be executed beforehand</span>
<span class="sd">        (with ``river_routing`` set to &quot;local-inertial&quot;).</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **floodplain_volume** map: map with floodplain volumes, has flood depth as \</span>
<span class="sd">            third dimension [m3] (for 1D floodplains)</span>
<span class="sd">        * **river_bank_elevation** map: hydrologically conditioned elevation [m+REF]</span>
<span class="sd">          (for 2D floodplains)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        floodplain_type: {&quot;1d&quot;, &quot;2d&quot;}</span>
<span class="sd">            Option defining the type of floodplains, see below what arguments</span>
<span class="sd">            are related to the different floodplain types</span>
<span class="sd">        hydrography_fn : str, Path, xarray.Dataset</span>
<span class="sd">            Name of RasterDataset source for hydrography data. Must be same as</span>
<span class="sd">            setup_basemaps for consistent results.</span>

<span class="sd">            * Required variables: [&#39;flwdir&#39;, &#39;uparea&#39;, &#39;elevtn&#39;]</span>
<span class="sd">        river_upa : float, optional</span>
<span class="sd">            (1D floodplains) minimum upstream area threshold for drain in the HAND.</span>
<span class="sd">            Optional value, as it is inferred from the grid metadata,</span>
<span class="sd">            to be consistent with setup_rivers.</span>
<span class="sd">        flood_depths : tuple of float, optional</span>
<span class="sd">            (1D floodplains) flood depths at which a volume is derived.</span>
<span class="sd">            By default [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0]</span>

<span class="sd">        elevtn_map: {&quot;land_elevation&quot;, &quot;meta_subgrid_elevation&quot;}</span>
<span class="sd">            (2D floodplains) Name of staticmap to hydrologically condition.</span>
<span class="sd">            By default &quot;land_elevation&quot;</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        workflows.river_floodplain_volume</span>
<span class="sd">        hydromt.flw.dem_adjust</span>
<span class="sd">        pyflwdir.FlwdirRaster.dem_adjust</span>
<span class="sd">        setup_rivers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;model.river_routing&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;local-inertial&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Floodplains (1d or 2d) are currently only supported with </span><span class="se">\</span>
<span class="s2">local inertial river routing&quot;</span>
            <span class="p">)</span>
        <span class="c1"># update self._MAPS and self._WFLOW_NAMES with user defined output names</span>
        <span class="n">var</span> <span class="o">=</span> <span class="s2">&quot;floodplain_water__sum_of_volume-per-depth&quot;</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="n">var</span><span class="p">:</span> <span class="n">output_names</span><span class="p">[</span><span class="n">var</span><span class="p">]})</span>

        <span class="n">r_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;1d&quot;</span><span class="p">,</span> <span class="s2">&quot;2d&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">floodplain_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r_list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;river_routing=&quot;</span><span class="si">{</span><span class="n">floodplain_type</span><span class="si">}</span><span class="s1">&quot; unknown. Select from </span><span class="si">{</span><span class="n">r_list</span><span class="si">}</span><span class="s1">.&#39;</span>
            <span class="p">)</span>

        <span class="c1"># Adjust settings based on floodplain_type selection</span>
        <span class="k">if</span> <span class="n">floodplain_type</span> <span class="o">==</span> <span class="s2">&quot;1d&quot;</span><span class="p">:</span>
            <span class="n">floodplain_1d</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">land_routing</span> <span class="o">=</span> <span class="s2">&quot;kinematic-wave&quot;</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pyflwdir</span><span class="o">.</span><span class="n">FlwdirRaster</span><span class="p">,</span> <span class="s2">&quot;ucat_volume&quot;</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;This method requires pyflwdir &gt;= 0.5.6&quot;</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing 1D river floodplain_volume map.&quot;</span><span class="p">)</span>

            <span class="c1"># read data</span>
            <span class="n">ds_hydro</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">hydrography_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">10</span>
            <span class="p">)</span>
            <span class="n">ds_hydro</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_hydro</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">geometry_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>

            <span class="c1"># try to get river uparea from grid, throw error if not specified</span>
            <span class="c1"># or when found but different from specified value</span>
            <span class="n">new_river_upa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;river_upa&quot;</span><span class="p">,</span> <span class="n">river_upa</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">new_river_upa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;No value for `river_upa` specified, and the value cannot </span><span class="se">\</span>
<span class="s2">be inferred from the grid attributes&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">new_river_upa</span> <span class="o">!=</span> <span class="n">river_upa</span> <span class="ow">and</span> <span class="n">river_upa</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Value specified for river_upa (</span><span class="si">{</span><span class="n">river_upa</span><span class="si">}</span><span class="s2">) is different from </span><span class="se">\</span>
<span class="s2">the value found in the grid (</span><span class="si">{</span><span class="n">new_river_upa</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using river_upa value value of: </span><span class="si">{</span><span class="n">new_river_upa</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># get river floodplain volume</span>
            <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span>
            <span class="p">}</span>
            <span class="n">da_fldpln</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">river_floodplain_volume</span><span class="p">(</span>
                <span class="n">ds</span><span class="o">=</span><span class="n">ds_hydro</span><span class="p">,</span>
                <span class="n">ds_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
                <span class="n">river_upa</span><span class="o">=</span><span class="n">new_river_upa</span><span class="p">,</span>
                <span class="n">flood_depths</span><span class="o">=</span><span class="n">flood_depths</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># check if the layer already exists, since overwriting with different</span>
            <span class="c1"># flood_depth values is not working properly if this is the case</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;floodplain_volume&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Layer `floodplain_volume` already in grid, removing layer </span><span class="se">\</span>
<span class="s2">and `flood_depth` dimension to ensure correctly </span><span class="se">\</span>
<span class="s2">setting new flood_depth dimensions&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">drop_dims</span><span class="p">(</span><span class="s2">&quot;flood_depth&quot;</span><span class="p">)</span>

            <span class="n">da_fldpln</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;floodplain_volume&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_fldpln</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">da_fldpln</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">floodplain_type</span> <span class="o">==</span> <span class="s2">&quot;2d&quot;</span><span class="p">:</span>
            <span class="n">floodplain_1d</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">land_routing</span> <span class="o">=</span> <span class="s2">&quot;local-inertial&quot;</span>

            <span class="k">if</span> <span class="n">elevtn_map</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">elevtn_map</span><span class="si">}</span><span class="s1">&quot; not found in grid&#39;</span><span class="p">)</span>

            <span class="n">postfix</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;land_elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;_avg&quot;</span><span class="p">,</span>
                <span class="s2">&quot;meta_subgrid_elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;_subgrid&quot;</span><span class="p">,</span>
            <span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">elevtn_map</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;river_bank_elevation</span><span class="si">{</span><span class="n">postfix</span><span class="si">}</span><span class="s2">_D</span><span class="si">{</span><span class="n">connectivity</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="c1"># Check if users wanted a specific name for the river_bank_elevation</span>
            <span class="n">hydrodem_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;hydrodem&quot;</span><span class="p">])</span>
            <span class="n">lndelv_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">])</span>
            <span class="c1"># river_bank_elevation is used for two wflow variables</span>
            <span class="k">if</span> <span class="n">hydrodem_var</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">output_names</span><span class="p">[</span><span class="n">hydrodem_var</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="n">hydrodem_var</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
                    <span class="n">lndelv_var</span><span class="p">:</span> <span class="n">elevtn_map</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparing </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> map for land routing.&quot;</span><span class="p">)</span>
            <span class="n">ds_out</span> <span class="o">=</span> <span class="n">flw</span><span class="o">.</span><span class="n">dem_adjust</span><span class="p">(</span>
                <span class="n">da_flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;flwdir&quot;</span><span class="p">]],</span>
                <span class="n">da_elevtn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">elevtn_map</span><span class="p">],</span>
                <span class="n">da_rivmsk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]],</span>
                <span class="n">flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span>
                <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
                <span class="n">river_d8</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_out</span><span class="p">)</span>
            <span class="c1"># Update the bankfull elevation map</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.static.river_bank_water__elevation&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="c1"># In this case river_bank_elevation is also used for the ground elevation?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span>
                <span class="s2">&quot;input.static.land_surface_water_flow__ground_elevation&quot;</span><span class="p">,</span> <span class="n">elevtn_map</span>
            <span class="p">)</span>

        <span class="c1"># Update config</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;Update wflow config model.floodplain_1d__flag=&quot;</span><span class="si">{</span><span class="n">floodplain_1d</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.floodplain_1d__flag&quot;</span><span class="p">,</span> <span class="n">floodplain_1d</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Update wflow config model.land_routing=&quot;</span><span class="si">{</span><span class="n">land_routing</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.land_routing&quot;</span><span class="p">,</span> <span class="n">land_routing</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">floodplain_type</span> <span class="o">==</span> <span class="s2">&quot;1d&quot;</span><span class="p">:</span>
            <span class="c1"># Add states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span>
                <span class="s2">&quot;state.floodplain_water__instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                <span class="s2">&quot;floodplain_instantaneous_q&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span>
                <span class="s2">&quot;state.floodplain_water__instantaneous_depth&quot;</span><span class="p">,</span>
                <span class="s2">&quot;floodplain_instantaneous_h&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span>
                <span class="s2">&quot;state.land_surface_water__instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                <span class="s2">&quot;land_instantaneous_q&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Remove local-inertial land states</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
                    <span class="s2">&quot;state.land_surface_water__x_component_of_instantaneous_volume_flow_rate&quot;</span>
                <span class="p">)</span>
                <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
                    <span class="s2">&quot;land_surface_water__x_component_of_instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                    <span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
                    <span class="s2">&quot;state.land_surface_water__y_component_of_instantaneous_volume_flow_rate&quot;</span>
                <span class="p">)</span>
                <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
                    <span class="s2">&quot;land_surface_water__y_component_of_instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                    <span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># Remove from output.netcdf_grid section</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
                    <span class="s2">&quot;output.netcdf_grid.variables.land_surface_water__x_component_of_instantaneous_volume_flow_rate&quot;</span>
                <span class="p">)</span>
                <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">][</span><span class="s2">&quot;netcdf_grid&quot;</span><span class="p">][</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
                    <span class="s2">&quot;land_surface_water__x_component_of_instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                    <span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
                    <span class="s2">&quot;output.netcdf_grid.variables.land_surface_water__y_component_of_instantaneous_volume_flow_rate&quot;</span>
                <span class="p">)</span>
                <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">][</span><span class="s2">&quot;netcdf_grid&quot;</span><span class="p">][</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
                    <span class="s2">&quot;land_surface_water__y_component_of_instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                    <span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Add local-inertial land routing states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span>
                <span class="s2">&quot;state.land_surface_water__x_component_of_instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                <span class="s2">&quot;land_instantaneous_qx&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span>
                <span class="s2">&quot;state.land_surface_water__y_component_of_instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                <span class="s2">&quot;land_instantaneous_qy&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Remove kinematic-wave and 1d floodplain states</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
                    <span class="s2">&quot;state.land_surface_water__instantaneous_volume_flow_rate&quot;</span>
                <span class="p">)</span>
                <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
                    <span class="s2">&quot;land_surface_water__instantaneous_volume_flow_rate&quot;</span><span class="p">,</span> <span class="kc">None</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
                    <span class="s2">&quot;state.floodplain_water__instantaneous_volume_flow_rate&quot;</span>
                <span class="p">)</span>
                <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
                    <span class="s2">&quot;floodplain_water__instantaneous_volume_flow_rate&quot;</span><span class="p">,</span> <span class="kc">None</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;state.floodplain_water__instantaneous_depth&quot;</span><span class="p">)</span>
                <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;floodplain_water__instantaneous_depth&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="c1"># Remove from output.netcdf_grid section</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
                    <span class="s2">&quot;output.netcdf_grid.variables.land_surface_water__instantaneous_volume_flow_rate&quot;</span>
                <span class="p">)</span>
                <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">][</span><span class="s2">&quot;netcdf_grid&quot;</span><span class="p">][</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
                    <span class="s2">&quot;land_surface_water__instantaneous_volume_flow_rate&quot;</span><span class="p">,</span> <span class="kc">None</span>
                <span class="p">)</span></div>


    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_riverwidth</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">predictor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;discharge&quot;</span><span class="p">,</span>
        <span class="n">fill</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">fit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">min_wth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">precip_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="s2">&quot;chelsa&quot;</span><span class="p">,</span>
        <span class="n">climate_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="s2">&quot;koppen_geiger&quot;</span><span class="p">,</span>
        <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;river_width&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the river width parameter based on power-law relationship with a predictor.</span>

<span class="sd">        By default the riverwidth is estimated based on discharge as ``predictor``</span>
<span class="sd">        and used to set the riverwidth globally based on pre-defined power-law</span>
<span class="sd">        parameters per climate class. With ``fit`` set to True,</span>
<span class="sd">        the power-law relationships parameters are set on-the-fly.</span>
<span class="sd">        With ``fill`` set to True, the estimated river widths are only used</span>
<span class="sd">        to fill gaps in the observed data. Alternative ``predictor`` values</span>
<span class="sd">        are precip (accumulated precipitation) and uparea (upstream area).</span>
<span class="sd">        For these predictors values ``fit`` default to True.</span>
<span class="sd">        By default the predictor is based on discharge which is estimated through</span>
<span class="sd">        multiple linear regression with precipitation and upstream area</span>
<span class="sd">        per climate zone.</span>

<span class="sd">        * **river_width** map: river width [m]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        predictor : {&quot;discharge&quot;, &quot;precip&quot;, &quot;uparea&quot;}</span>
<span class="sd">            Predictor used in the power-law equation: width = a * predictor ^ b.</span>
<span class="sd">            Discharge is based on multiple linear regression per climate zone.</span>
<span class="sd">            Precip is based on the 10x the daily average</span>
<span class="sd">            accumulated precipitation [m3/s].</span>
<span class="sd">            Uparea is based on the upstream area grid [km2].</span>
<span class="sd">            Other variables, e.g. bankfull discharge, can also be provided if present</span>
<span class="sd">            in the grid</span>
<span class="sd">        fill : bool, optional</span>
<span class="sd">            If True (default), use estimate to fill gaps, outliers and lake/res areas</span>
<span class="sd">            in observed width data (if present);</span>
<span class="sd">            if False, set all riverwidths based on predictor</span>
<span class="sd">            (automatic choice if no observations found)</span>
<span class="sd">        fit : bool, optional</span>
<span class="sd">            If True, the power-law parameters are fitted on the fly</span>
<span class="sd">            By default True for all but &quot;discharge&quot; predictor.</span>
<span class="sd">            A-priori derived parameters will be overwritten if True.</span>
<span class="sd">        a, b : float, optional kwarg</span>
<span class="sd">            Manual power-law parameters</span>
<span class="sd">        min_wth : float, optional</span>
<span class="sd">            Minimum river width, by default 1.0</span>
<span class="sd">        precip_fn : str, xarray.DataArray</span>
<span class="sd">            Source of long term precipitation grid if the predictor</span>
<span class="sd">            is set to &#39;discharge&#39; or &#39;precip&#39;. By default &quot;chelsa&quot;.</span>
<span class="sd">        climate_fn: str, xarray.DataArray</span>
<span class="sd">            Source of long-term climate grid if the predictor is set to &#39;discharge&#39;.</span>
<span class="sd">            By default &quot;koppen_geiger&quot;.</span>
<span class="sd">        output_name : str</span>
<span class="sd">            The name of the output river__width map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s1">&#39;The &quot;setup_riverwidth&quot; method has been deprecated </span><span class="se">\</span>
<span class="s1">and will soon be removed. &#39;</span>
            <span class="s1">&#39;You can now use the &quot;setup_river&quot; method for all river parameters.&#39;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The setup_riverwidth method requires to run setup_river method first.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># update self._MAPS and self._WFLOW_NAMES with user defined output names</span>
        <span class="n">wflow_var</span> <span class="o">=</span> <span class="s2">&quot;river__width&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="n">wflow_var</span><span class="p">:</span> <span class="n">output_name</span><span class="p">})</span>

        <span class="c1"># derive river width</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">predictor</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;discharge&quot;</span><span class="p">,</span> <span class="s2">&quot;precip&quot;</span><span class="p">]:</span>
            <span class="n">da_precip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">precip_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
            <span class="n">da_precip</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">precip_fn</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;da_precip&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">da_precip</span>
        <span class="k">if</span> <span class="n">predictor</span> <span class="o">==</span> <span class="s2">&quot;discharge&quot;</span><span class="p">:</span>
            <span class="n">da_climate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">climate_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
            <span class="n">da_climate</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">climate_fn</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;da_climate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">da_climate</span>

        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">}</span>
        <span class="n">da_rivwth</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">river_width</span><span class="p">(</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">fill</span><span class="o">=</span><span class="n">fill</span><span class="p">,</span>
            <span class="n">fill_outliers</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;fill_outliers&quot;</span><span class="p">,</span> <span class="n">fill</span><span class="p">),</span>
            <span class="n">min_wth</span><span class="o">=</span><span class="n">min_wth</span><span class="p">,</span>
            <span class="n">mask_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lake_area_id&quot;</span><span class="p">,</span> <span class="s2">&quot;reservoir_area_id&quot;</span><span class="p">],</span>
            <span class="n">predictor</span><span class="o">=</span><span class="n">predictor</span><span class="p">,</span>
            <span class="n">a</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">b</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="n">fit</span><span class="o">=</span><span class="n">fit</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_rivwth</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">output_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">output_name</span><span class="p">)</span>

<div class="viewcode-block" id="WflowModel.setup_lulcmaps">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_lulcmaps.html#hydromt_wflow.WflowModel.setup_lulcmaps">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_lulcmaps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lulc_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">lulc_mapping_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lulc_vars</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;landuse&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_kext&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_canopy__light-extinction_coefficient&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land_manning_n&quot;</span><span class="p">:</span> <span class="s2">&quot;land_surface_water_flow__manning_n_parameter&quot;</span><span class="p">,</span>
            <span class="s2">&quot;soil_compacted_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;soil~compacted__area_fraction&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_root_depth&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__depth&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_leaf_storage&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation__specific-leaf_storage&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_wood_storage&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_wood_water__storage_capacity&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land_water_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;land~water-covered__area_fraction&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_crop_factor&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation__crop_factor&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_feddes_alpha_h1&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~1_reduction_coefficient&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;vegetation_feddes_h1&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_feddes_h2&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~2&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_feddes_h3_high&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~3~high&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;vegetation_feddes_h3_low&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~3~low&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;vegetation_feddes_h4&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~4&quot;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">output_names_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derive several wflow maps based on landuse-landcover (LULC) data.</span>

<span class="sd">        Lookup table `lulc_mapping_fn` columns are converted to lulc classes model</span>
<span class="sd">        parameters based on literature. The data is remapped at its original resolution</span>
<span class="sd">        and then resampled to the model resolution using the average value, unless noted</span>
<span class="sd">        differently.</span>

<span class="sd">        Currently, if `lulc_fn` is set to the &quot;vito&quot;, &quot;globcover&quot;, &quot;esa_worldcover&quot;</span>
<span class="sd">        &quot;corine&quot; or &quot;glmnco&quot;, default lookup tables are available and will be used if</span>
<span class="sd">        `lulc_mapping_fn` is not provided.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **landuse** map:</span>
<span class="sd">            Landuse class [-]</span>
<span class="sd">        * **vegetation_kext** map:</span>
<span class="sd">            Extinction coefficient in the canopy gap fraction equation [-]</span>
<span class="sd">        * **vegetation_leaf_storage** map:</span>
<span class="sd">            Specific leaf storage [mm]</span>
<span class="sd">        * **vegetation_wood_storage** map:</span>
<span class="sd">            Fraction of wood in the vegetation/plant [-]</span>
<span class="sd">        * **vegetation_root_depth** map:</span>
<span class="sd">            Length of vegetation roots [mm]</span>
<span class="sd">        * **soil_compacted_fraction** map:</span>
<span class="sd">            The fraction of compacted or urban area per grid cell [-]</span>
<span class="sd">        * **land_water_fraction** map:</span>
<span class="sd">            The fraction of open water per grid cell [-]</span>
<span class="sd">        * **land_manning_n** map:</span>
<span class="sd">            Manning Roughness [-]</span>
<span class="sd">        * **vegetation_crop_factor** map:</span>
<span class="sd">            Crop coefficient [-]</span>
<span class="sd">        * **vegetation_feddes_alpha_h1** map:</span>
<span class="sd">            Root water uptake reduction at soil water pressure head</span>
<span class="sd">            h1 (0 or 1) [-]</span>
<span class="sd">        * **vegetation_feddes_h1** map:</span>
<span class="sd">            Soil water pressure head h1 at which root water</span>
<span class="sd">            uptake is reduced (Feddes) [cm]</span>
<span class="sd">        * **vegetation_feddes_h2** map:</span>
<span class="sd">            Soil water pressure head h2 at which root water</span>
<span class="sd">            uptake is reduced (Feddes) [cm]</span>
<span class="sd">        * **vegetation_feddes_h3_high** map:</span>
<span class="sd">            Soil water pressure head h3 (high) at which root water uptake is</span>
<span class="sd">            reduced (Feddes) [cm]</span>
<span class="sd">        * **vegetation_feddes_h3_low** map:</span>
<span class="sd">            Soil water pressure head h3 (low) at which root water uptake is</span>
<span class="sd">            reduced (Feddes) [cm]</span>
<span class="sd">        * **vegetation_feddes_h4** map:</span>
<span class="sd">            Soil water pressure head h4 at which root water</span>
<span class="sd">            uptake is reduced (Feddes) [cm]</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lulc_fn : str, xarray.DataArray</span>
<span class="sd">            Name of RasterDataset source in data_sources.yml file.</span>
<span class="sd">        lulc_mapping_fn : str, Path, pd.DataFrame</span>
<span class="sd">            Path to a mapping csv file from landuse in source name to parameter values</span>
<span class="sd">            in lulc_vars. If lulc_fn is one of {&quot;globcover&quot;, &quot;vito&quot;, &quot;corine&quot;,</span>
<span class="sd">            &quot;esa_worldcover&quot;, &quot;glmnco&quot;}, a default mapping is used and this argument</span>
<span class="sd">            becomes optional.</span>
<span class="sd">        lulc_vars : Dict</span>
<span class="sd">            Dictionnary of landuse parameters to prepare. The names are the</span>
<span class="sd">            the columns of the mapping file and the values are the corresponding</span>
<span class="sd">            Wflow.jl variables if any.</span>
<span class="sd">        output_names_suffix : str, optional</span>
<span class="sd">            Suffix to be added to the output names to avoid having to rename all the</span>
<span class="sd">            columns of the mapping tables. For example if the suffix is &quot;vito&quot;, all</span>
<span class="sd">            variables in lulc_vars will be renamed to &quot;landuse_vito&quot;, &quot;Kext_vito&quot;, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">output_names_suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># rename lulc_vars with the suffix</span>
            <span class="n">output_names</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">v</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">output_names_suffix</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">lulc_vars</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">lulc_vars</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>
        <span class="c1"># As landuse is not a wflow variable, we update the name manually in self._MAPS</span>
        <span class="k">if</span> <span class="n">output_names_suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;landuse&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;meta_landuse_</span><span class="si">{</span><span class="n">output_names_suffix</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing LULC parameter maps.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lulc_mapping_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lulc_mapping_fn</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lulc_fn</span><span class="si">}</span><span class="s2">_mapping_default&quot;</span>

        <span class="c1"># read landuse map to DataArray</span>
        <span class="n">da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">lulc_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;landuse&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">df_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span>
            <span class="n">lulc_mapping_fn</span><span class="p">,</span>
            <span class="n">driver_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;index_col&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>  <span class="c1"># only used if fn_map is a file path</span>
        <span class="p">)</span>
        <span class="c1"># process landuse</span>
        <span class="n">ds_lulc_maps</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">landuse</span><span class="p">(</span>
            <span class="n">da</span><span class="o">=</span><span class="n">da</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df_map</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">lulc_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_lulc_maps</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_lulc_maps</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>

        <span class="c1"># Add entries to the config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">ds_lulc_maps</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_lulcmaps_from_vector">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_lulcmaps_from_vector.html#hydromt_wflow.WflowModel.setup_lulcmaps_from_vector">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_lulcmaps_from_vector</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lulc_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">lulc_mapping_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lulc_vars</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;landuse&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_kext&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_canopy__light-extinction_coefficient&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land_manning_n&quot;</span><span class="p">:</span> <span class="s2">&quot;land_surface_water_flow__manning_n_parameter&quot;</span><span class="p">,</span>
            <span class="s2">&quot;soil_compacted_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;soil~compacted__area_fraction&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_root_depth&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__depth&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_leaf_storage&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation__specific-leaf_storage&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_wood_storage&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_wood_water__storage_capacity&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land_water_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;land~water-covered__area_fraction&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_crop_factor&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation__crop_factor&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_feddes_alpha_h1&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~1_reduction_coefficient&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;vegetation_feddes_h1&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_feddes_h2&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~2&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_feddes_h3_high&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~3~high&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;vegetation_feddes_h3_low&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~3~low&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;vegetation_feddes_h4&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~4&quot;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">lulc_res</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">all_touched</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">buffer</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">save_raster_lulc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">output_names_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derive several wflow maps based on vector landuse-landcover (LULC) data.</span>

<span class="sd">        The vector lulc data is first rasterized to a raster map at the model resolution</span>
<span class="sd">        or at a higher resolution specified in ``lulc_res`` (recommended).</span>

<span class="sd">        Lookup table `lulc_mapping_fn` columns are converted to lulc classes model</span>
<span class="sd">        parameters based on literature. The data is remapped at its original resolution</span>
<span class="sd">        and then resampled to the model resolution using the average value, unless noted</span>
<span class="sd">        differently.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **landuse** map:</span>
<span class="sd">            Landuse class [-]</span>
<span class="sd">        * **vegetation_kext** map:</span>
<span class="sd">            Extinction coefficient in the canopy gap fraction equation [-]</span>
<span class="sd">        * **vegetation_leaf_storage** map:</span>
<span class="sd">            Specific leaf storage [mm]</span>
<span class="sd">        * **vegetation_wood_storage** map:</span>
<span class="sd">            Fraction of wood in the vegetation/plant [-]</span>
<span class="sd">        * **vegetation_root_depth** map:</span>
<span class="sd">            Length of vegetation roots [mm]</span>
<span class="sd">        * **soil_compacted_fraction** map:</span>
<span class="sd">            The fraction of compacted or urban area per grid cell [-]</span>
<span class="sd">        * **land_water_fraction** map:</span>
<span class="sd">            The fraction of open water per grid cell [-]</span>
<span class="sd">        * **land_manning_n** map: Manning Roughness [-]</span>
<span class="sd">        * **vegetation_crop_factor** map:</span>
<span class="sd">            Crop coefficient [-]</span>
<span class="sd">        * **vegetation_feddes_alpha_h1** map:</span>
<span class="sd">            Root water uptake reduction at soil water pressure head</span>
<span class="sd">            h1 (0 or 1) [-]</span>
<span class="sd">        * **vegetation_feddes_h1** map:</span>
<span class="sd">            Soil water pressure head h1 at which root water</span>
<span class="sd">            uptake is reduced (Feddes) [cm]</span>
<span class="sd">        * **vegetation_feddes_h2** map:</span>
<span class="sd">            Soil water pressure head h2 at which root water</span>
<span class="sd">            uptake is reduced (Feddes) [cm]</span>
<span class="sd">        * **vegetation_feddes_h3_high** map:</span>
<span class="sd">            Soil water pressure head h3 (high) at which root water uptake is</span>
<span class="sd">            reduced (Feddes) [cm]</span>
<span class="sd">        * **vegetation_feddes_h3_low** map:</span>
<span class="sd">            Soil water pressure head h3 (low) at which root water uptake is</span>
<span class="sd">            reduced (Feddes) [cm]</span>
<span class="sd">        * **vegetation_feddes_h4** map:</span>
<span class="sd">            Soil water pressure head h4 at which root water</span>
<span class="sd">            uptake is reduced (Feddes) [cm]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lulc_fn : str, gpd.GeoDataFrame</span>
<span class="sd">            GeoDataFrame or name in data catalog / path to (vector) landuse map.</span>

<span class="sd">            * Required columns: &#39;landuse&#39; [-]</span>
<span class="sd">        lulc_mapping_fn : str, Path, pd.DataFrame</span>
<span class="sd">            Path to a mapping csv file from landuse in source name to parameter values</span>
<span class="sd">            in lulc_vars. If lulc_fn is one of {&quot;globcover&quot;, &quot;vito&quot;, &quot;corine&quot;,</span>
<span class="sd">            &quot;esa_worldcover&quot;, &quot;glmnco&quot;}, a default mapping is used and this argument</span>
<span class="sd">            becomes optional.</span>
<span class="sd">        lulc_vars : Dict</span>
<span class="sd">            Dictionnary of landuse parameters to prepare. The names are the</span>
<span class="sd">            the columns of the mapping file and the values are the corresponding</span>
<span class="sd">            Wflow.jl variables.</span>
<span class="sd">        lulc_res : float, int, optional</span>
<span class="sd">            Resolution of the intermediate rasterized landuse map. The unit (meter or</span>
<span class="sd">            degree) depends on the CRS of lulc_fn (projected or not). By default None,</span>
<span class="sd">            which uses the model resolution.</span>
<span class="sd">        all_touched : bool, optional</span>
<span class="sd">            If True, all pixels touched by the vector will be burned in the raster,</span>
<span class="sd">            by default False.</span>
<span class="sd">        buffer : int, optional</span>
<span class="sd">            Buffer around the bounding box of the vector data to ensure that all</span>
<span class="sd">            landuse classes are included in the rasterized map, by default 1000.</span>
<span class="sd">        save_raster_lulc : bool, optional</span>
<span class="sd">            If True, the (high) resolution rasterized landuse map will be saved to</span>
<span class="sd">            maps/landuse_raster.tif, by default False.</span>
<span class="sd">        output_names_suffix : str, optional</span>
<span class="sd">            Suffix to be added to the output names to avoid having to rename all the</span>
<span class="sd">            columns of the mapping tables. For example if the suffix is &quot;vito&quot;, all</span>
<span class="sd">            variables in lulc_vars will be renamed to &quot;landuse_vito&quot;, &quot;Kext_vito&quot;, etc.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        workflows.landuse_from_vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">output_names_suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># rename lulc_vars with the suffix</span>
            <span class="n">output_names</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">v</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">output_names_suffix</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">lulc_vars</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">lulc_vars</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>
        <span class="c1"># As landuse is not a wflow variable, we update the name manually in self._MAPS</span>
        <span class="k">if</span> <span class="n">output_names_suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;landuse&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;meta_landuse_</span><span class="si">{</span><span class="n">output_names_suffix</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing LULC parameter maps.&quot;</span><span class="p">)</span>
        <span class="c1"># Read mapping table</span>
        <span class="k">if</span> <span class="n">lulc_mapping_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lulc_mapping_fn</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lulc_fn</span><span class="si">}</span><span class="s2">_mapping_default&quot;</span>
        <span class="n">df_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span>
            <span class="n">lulc_mapping_fn</span><span class="p">,</span>
            <span class="n">driver_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;index_col&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>  <span class="c1"># only used if fn_map is a file path</span>
        <span class="p">)</span>
        <span class="c1"># read landuse map</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">lulc_fn</span><span class="p">,</span>
            <span class="n">bbox</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;landuse&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">save_raster_lulc</span><span class="p">:</span>
            <span class="n">lulc_out</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;maps&quot;</span><span class="p">,</span> <span class="s2">&quot;landuse_raster.tif&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lulc_out</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># process landuse</span>
        <span class="n">ds_lulc_maps</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">landuse_from_vector</span><span class="p">(</span>
            <span class="n">gdf</span><span class="o">=</span><span class="n">gdf</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df_map</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">lulc_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="n">lulc_res</span><span class="o">=</span><span class="n">lulc_res</span><span class="p">,</span>
            <span class="n">all_touched</span><span class="o">=</span><span class="n">all_touched</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
            <span class="n">lulc_out</span><span class="o">=</span><span class="n">lulc_out</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_lulc_maps</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_lulc_maps</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
        <span class="c1"># update config variable names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">ds_lulc_maps</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_laimaps">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_laimaps.html#hydromt_wflow.WflowModel.setup_laimaps">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_laimaps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lai_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">lulc_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lulc_sampling_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;any&quot;</span><span class="p">,</span>
        <span class="n">lulc_zero_classes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">buffer</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;vegetation_leaf_area_index&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set leaf area index (LAI) climatology maps per month [1,2,3,...,12].</span>

<span class="sd">        The values are resampled to the model resolution using the average value.</span>
<span class="sd">        Currently only directly cyclic LAI data is supported.</span>

<span class="sd">        If `lulc_fn` is provided, mapping tables from landuse classes to LAI values</span>
<span class="sd">        will be derived from the LULC data. These tables can then be re-used later if</span>
<span class="sd">        you would like to add new LAI maps derived from this mapping table and new</span>
<span class="sd">        landuse scenarios. We advise to use a larger `buffer` to ensure that LAI values</span>
<span class="sd">        can be assigned for all landuse classes and based on a large enough sample of</span>
<span class="sd">        the LULC data.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **vegetation_leaf_area_index** map: Leaf Area Index climatology [-]</span>
<span class="sd">            Resampled from source data using average. Assuming that missing values</span>
<span class="sd">            correspond to bare soil, these are set to zero before resampling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lai_fn : str, xarray.DataArray</span>
<span class="sd">            Name of RasterDataset source for LAI parameters, see data/data_sources.yml.</span>

<span class="sd">            * Required variables: &#39;LAI&#39; [-]</span>

<span class="sd">            * Required dimensions: &#39;time&#39; = [1,2,3,...,12] (months)</span>
<span class="sd">        lulc_fn : str, xarray.DataArray, optional</span>
<span class="sd">            Name of RasterDataset source for landuse-landcover data.</span>
<span class="sd">            If provided, the LAI values are mapped to landuse classes and will be saved</span>
<span class="sd">            to a csv file.</span>
<span class="sd">        lulc_sampling_method : str, optional</span>
<span class="sd">            Resampling method for the LULC data to the LAI resolution. Two methods are</span>
<span class="sd">            supported:</span>

<span class="sd">            * &#39;any&#39; (default): if any cell of the desired landuse class is present in</span>
<span class="sd">              the resampling window (even just one), it will be used to derive LAI</span>
<span class="sd">              values. This method is less exact but will provide LAI values for all</span>
<span class="sd">              landuse classes for the high resolution landuse map.</span>
<span class="sd">            * &#39;mode&#39;: the most frequent value in the resampling window is</span>
<span class="sd">              used. This method is less precise as for cells with a lot of different</span>
<span class="sd">              landuse classes, the most frequent value might still be only a small</span>
<span class="sd">              fraction of the cell. More landuse classes should however be covered and</span>
<span class="sd">              it can always be used with the landuse map of the wflow model instead of</span>
<span class="sd">              the original high resolution one.</span>
<span class="sd">            * &#39;q3&#39;: only cells with the most frequent value (mode) and that cover 75%</span>
<span class="sd">              (q3) of the resampling window will be used. This method is more exact but</span>
<span class="sd">              for small basins, you may have less or no samples to derive LAI values</span>
<span class="sd">              for some classes.</span>
<span class="sd">        lulc_zero_classes : list, optional</span>
<span class="sd">            List of landuse classes that should have zero for leaf area index values</span>
<span class="sd">            for example waterbodies, open ocean etc. For very high resolution landuse</span>
<span class="sd">            maps, urban surfaces and bare areas can be included here as well.</span>
<span class="sd">            By default empty.</span>
<span class="sd">        buffer : int, optional</span>
<span class="sd">            Buffer around the region to read the data, by default 2.</span>
<span class="sd">        output_name : str</span>
<span class="sd">            Name of the output vegetation__leaf-area_index map.</span>
<span class="sd">            By default &quot;vegetation_leaf_area_index&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># retrieve data for region</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing LAI maps.&quot;</span><span class="p">)</span>
        <span class="n">wflow_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="n">wflow_var</span><span class="p">:</span> <span class="n">output_name</span><span class="p">})</span>
        <span class="n">da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">lai_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">lulc_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing LULC-LAI mapping table.&quot;</span><span class="p">)</span>
            <span class="n">da_lulc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">lulc_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span>
            <span class="p">)</span>
            <span class="c1"># derive mapping</span>
            <span class="n">df_lai_mapping</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">create_lulc_lai_mapping_table</span><span class="p">(</span>
                <span class="n">da_lulc</span><span class="o">=</span><span class="n">da_lulc</span><span class="p">,</span>
                <span class="n">da_lai</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">sampling_method</span><span class="o">=</span><span class="n">lulc_sampling_method</span><span class="p">,</span>
                <span class="n">lulc_zero_classes</span><span class="o">=</span><span class="n">lulc_zero_classes</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Save to csv</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lulc_fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isfile</span><span class="p">(</span><span class="n">lulc_fn</span><span class="p">):</span>
                <span class="n">df_fn</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;lai_per_lulc_</span><span class="si">{</span><span class="n">lulc_fn</span><span class="si">}</span><span class="s2">.csv&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">df_fn</span> <span class="o">=</span> <span class="s2">&quot;lai_per_lulc.csv&quot;</span>
            <span class="n">df_lai_mapping</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">df_fn</span><span class="p">))</span>

        <span class="c1"># Resample LAI data to wflow model resolution</span>
        <span class="n">da_lai</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">lai</span><span class="p">(</span>
            <span class="n">da</span><span class="o">=</span><span class="n">da</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Rename the first dimension to time</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">da_lai</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="s2">&quot;time&quot;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_lai</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;cyclic&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_laimaps_from_lulc_mapping">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_laimaps_from_lulc_mapping.html#hydromt_wflow.WflowModel.setup_laimaps_from_lulc_mapping">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_laimaps_from_lulc_mapping</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lulc_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">lai_mapping_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;vegetation_leaf_area_index&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derive cyclic LAI maps from a LULC data source and a LULC-LAI mapping table.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **vegetation_leaf_area_index** map: Leaf Area Index climatology [-]</span>
<span class="sd">            Resampled from source data using average. Assuming that missing values</span>
<span class="sd">            correspond to bare soil, these are set to zero before resampling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lulc_fn : str, xarray.DataArray</span>
<span class="sd">            Name of RasterDataset source for landuse-landcover data.</span>
<span class="sd">        lai_mapping_fn : str, pd.DataFrame</span>
<span class="sd">            Path to a mapping csv file from landuse in source name to</span>
<span class="sd">            LAI values. The csv file should contain rows with landuse classes</span>
<span class="sd">            and LAI values for each month. The columns should be named as the</span>
<span class="sd">            months (1,2,3,...,12).</span>
<span class="sd">            This table can be created using the :py:meth:`setup_laimaps` method.</span>
<span class="sd">        output_name : str</span>
<span class="sd">            Name of the output vegetation__leaf-area_index map.</span>
<span class="sd">            By default &quot;vegetation_leaf_area_index&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing LAI maps from LULC data using LULC-LAI mapping table.&quot;</span><span class="p">)</span>
        <span class="c1"># update self._MAPS and self._WFLOW_NAMES with user defined output names</span>
        <span class="n">wflow_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="n">wflow_var</span><span class="p">:</span> <span class="n">output_name</span><span class="p">})</span>

        <span class="c1"># read landuse map to DataArray</span>
        <span class="n">da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">lulc_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;landuse&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">df_lai_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span>
            <span class="n">lai_mapping_fn</span><span class="p">,</span>
            <span class="n">driver_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;index_col&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>  <span class="c1"># only used if fn_map is a file path</span>
        <span class="p">)</span>
        <span class="c1"># process landuse with LULC-LAI mapping table</span>
        <span class="n">da_lai</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">lai_from_lulc_mapping</span><span class="p">(</span>
            <span class="n">da</span><span class="o">=</span><span class="n">da</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df_lai_mapping</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Add to grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_lai</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">])</span>
        <span class="c1"># Add to config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;cyclic&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_config_output_timeseries">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_config_output_timeseries.html#hydromt_wflow.WflowModel.setup_config_output_timeseries">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_config_output_timeseries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">toml_output</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="s2">&quot;csv&quot;</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;river_q&quot;</span><span class="p">],</span>
        <span class="n">param</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;river_water__volume_flow_rate&quot;</span><span class="p">],</span>
        <span class="n">reducer</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the default gauge map based on basin outlets.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **csv.column** config: csv timeseries to save based on mapname locations</span>
<span class="sd">        * **netcdf.variable** config: netcdf timeseries to save based on mapname \</span>
<span class="sd">            locations</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapname : str</span>
<span class="sd">            Name of the gauge map (in staticmaps.nc) to use for scalar output.</span>
<span class="sd">        toml_output : str, optional</span>
<span class="sd">            One of [&#39;csv&#39;, &#39;netcdf_scalar&#39;, None] to update [output.csv] or</span>
<span class="sd">            [output.netcdf_scalar] section of wflow toml file or do nothing. By</span>
<span class="sd">            default, &#39;csv&#39;.</span>
<span class="sd">        header : list, optional</span>
<span class="sd">            Save specific model parameters in csv section. This option defines</span>
<span class="sd">            the header of the csv file.</span>
<span class="sd">            By default saves river_q (for river_water__volume_flow_rate).</span>
<span class="sd">        param: list, optional</span>
<span class="sd">            Save specific model parameters in csv section. This option defines</span>
<span class="sd">            the wflow variable corresponding to the</span>
<span class="sd">            names in gauge_toml_header. By default saves river_water__volume_flow_rate</span>
<span class="sd">            (for river_q).</span>
<span class="sd">        reducer: list, optional</span>
<span class="sd">            If map is an area rather than a point location, provides the reducer</span>
<span class="sd">            for the parameters to save. By default None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># # Add new outputcsv section in the config</span>
        <span class="k">if</span> <span class="n">toml_output</span> <span class="o">==</span> <span class="s2">&quot;csv&quot;</span> <span class="ow">or</span> <span class="n">toml_output</span> <span class="o">==</span> <span class="s2">&quot;netcdf_scalar&quot;</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding </span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">toml_output</span><span class="si">}</span><span class="s2"> section of toml.&quot;</span><span class="p">)</span>
            <span class="c1"># Add map to the input section of config</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;input.</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">mapname</span><span class="p">)</span>
            <span class="c1"># Settings and add csv or netcdf sections if not already in config</span>
            <span class="c1"># csv</span>
            <span class="k">if</span> <span class="n">toml_output</span> <span class="o">==</span> <span class="s2">&quot;csv&quot;</span><span class="p">:</span>
                <span class="n">header_name</span> <span class="o">=</span> <span class="s2">&quot;header&quot;</span>
                <span class="n">var_name</span> <span class="o">=</span> <span class="s2">&quot;column&quot;</span>
                <span class="n">current_config</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;output.csv&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">current_config</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_config</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;output.csv.path&quot;</span><span class="p">,</span> <span class="s2">&quot;output.csv&quot;</span><span class="p">)</span>
            <span class="c1"># netcdf</span>
            <span class="k">if</span> <span class="n">toml_output</span> <span class="o">==</span> <span class="s2">&quot;netcdf_scalar&quot;</span><span class="p">:</span>
                <span class="n">header_name</span> <span class="o">=</span> <span class="s2">&quot;name&quot;</span>
                <span class="n">var_name</span> <span class="o">=</span> <span class="s2">&quot;variable&quot;</span>
                <span class="n">current_config</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;output.netcdf_scalar&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">current_config</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_config</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;output.netcdf_scalar.path&quot;</span><span class="p">,</span> <span class="s2">&quot;output_scalar.nc&quot;</span><span class="p">)</span>
            <span class="c1"># initialise column / variable section</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;output.</span><span class="si">{</span><span class="n">toml_output</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;output.</span><span class="si">{</span><span class="n">toml_output</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">[])</span>

            <span class="c1"># Add new output column/variable to config</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">)):</span>
                <span class="n">gauge_toml_dict</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">header_name</span><span class="p">:</span> <span class="n">header</span><span class="p">[</span><span class="n">o</span><span class="p">],</span>
                    <span class="s2">&quot;map&quot;</span><span class="p">:</span> <span class="n">mapname</span><span class="p">,</span>
                    <span class="s2">&quot;parameter&quot;</span><span class="p">:</span> <span class="n">param</span><span class="p">[</span><span class="n">o</span><span class="p">],</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="n">reducer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">gauge_toml_dict</span><span class="p">[</span><span class="s2">&quot;reducer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reducer</span><span class="p">[</span><span class="n">o</span><span class="p">]</span>
                <span class="c1"># If the gauge column/variable already exists skip writing twice</span>
                <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;output.</span><span class="si">{</span><span class="n">toml_output</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">gauge_toml_dict</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                    <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gauge_toml_dict</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;output.</span><span class="si">{</span><span class="n">toml_output</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">variables</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;toml_output set to </span><span class="si">{</span><span class="n">toml_output</span><span class="si">}</span><span class="s2">, </span><span class="se">\</span>
<span class="s2">skipping adding gauge specific outputs to the toml.&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_outlets">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_outlets.html#hydromt_wflow.WflowModel.setup_outlets">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_outlets</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">river_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">toml_output</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;csv&quot;</span><span class="p">,</span>
        <span class="n">gauge_toml_header</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;river_q&quot;</span><span class="p">],</span>
        <span class="n">gauge_toml_param</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;river_water__volume_flow_rate&quot;</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the default gauge map based on basin outlets.</span>

<span class="sd">        If the subcatchment map is available, the catchment outlets IDs will be matching</span>
<span class="sd">        the subcatchment IDs. If not, then IDs from 1 to number of outlets are used.</span>

<span class="sd">        Can also add csv/netcdf_scalar output settings in the TOML.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **outlets** map: IDs map from catchment outlets [-]</span>
<span class="sd">        * **outlets** geom: polygon of catchment outlets</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        river_only : bool, optional</span>
<span class="sd">            Only derive outlet locations if they are located on a river instead of</span>
<span class="sd">            locations for all catchments, by default True.</span>
<span class="sd">        toml_output : str, optional</span>
<span class="sd">            One of [&#39;csv&#39;, &#39;netcdf_scalar&#39;, None] to update [output.csv] or</span>
<span class="sd">            [output.netcdf_scalar] section of wflow toml file or do nothing. By</span>
<span class="sd">            default, &#39;csv&#39;.</span>
<span class="sd">        gauge_toml_header : list, optional</span>
<span class="sd">            Save specific model parameters in csv section. This option defines</span>
<span class="sd">            the header of the csv file.</span>
<span class="sd">            By default saves river_q (for river_water__volume_flow_rate).</span>
<span class="sd">        gauge_toml_param: list, optional</span>
<span class="sd">            Save specific model parameters in csv section. This option defines</span>
<span class="sd">            the wflow variable corresponding to the names in gauge_toml_header.</span>
<span class="sd">            By default saves river_water__volume_flow_rate (for river_q).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># read existing geoms; important to get the right basin when updating</span>
        <span class="c1"># fix in set_geoms / set_geoms method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Gauges locations set based on river outlets.&quot;</span><span class="p">)</span>
        <span class="n">idxs_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="o">.</span><span class="n">idxs_pit</span>
        <span class="c1"># Only keep river outlets for gauges</span>
        <span class="k">if</span> <span class="n">river_only</span><span class="p">:</span>
            <span class="n">idxs_out</span> <span class="o">=</span> <span class="n">idxs_out</span><span class="p">[</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">idxs_out</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="c1"># Use the subcatchment ids</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">idxs_out</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">da_out</span><span class="p">,</span> <span class="n">idxs_out</span><span class="p">,</span> <span class="n">ids_out</span> <span class="o">=</span> <span class="n">flw</span><span class="o">.</span><span class="n">gauge_map</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">idxs</span><span class="o">=</span><span class="n">idxs_out</span><span class="p">,</span>
            <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
            <span class="n">flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_out</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;outlets&quot;</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">idx_to_xy</span><span class="p">(</span><span class="n">idxs_out</span><span class="p">))</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">ids_out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">geometry</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span>
        <span class="p">)</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;fid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ids_out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;outlets&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Gauges map based on catchment river outlets added.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setup_config_output_timeseries</span><span class="p">(</span>
            <span class="n">mapname</span><span class="o">=</span><span class="s2">&quot;outlets&quot;</span><span class="p">,</span>
            <span class="n">toml_output</span><span class="o">=</span><span class="n">toml_output</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="n">gauge_toml_header</span><span class="p">,</span>
            <span class="n">param</span><span class="o">=</span><span class="n">gauge_toml_param</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_gauges">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_gauges.html#hydromt_wflow.WflowModel.setup_gauges">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_gauges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">gauges_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">index_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">snap_to_river</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">snap_uparea</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_dist</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10e3</span><span class="p">,</span>
        <span class="n">wdw</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">rel_error</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
        <span class="n">abs_error</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">50.0</span><span class="p">,</span>
        <span class="n">fillna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">derive_subcatch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">basename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">toml_output</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;csv&quot;</span><span class="p">,</span>
        <span class="n">gauge_toml_header</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;river_q&quot;</span><span class="p">,</span> <span class="s2">&quot;precip&quot;</span><span class="p">],</span>
        <span class="n">gauge_toml_param</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;river_water__volume_flow_rate&quot;</span><span class="p">,</span>
            <span class="s2">&quot;atmosphere_water__precipitation_volume_flux&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a gauge map based on ``gauges_fn`` data.</span>

<span class="sd">        Supported gauge datasets include data catlog entries, direct GeoDataFrame</span>
<span class="sd">        or &quot;&lt;path_to_source&gt;&quot; for user supplied csv or geometry files</span>
<span class="sd">        with gauge locations. If a csv file is provided, a &quot;x&quot; or &quot;lon&quot; and</span>
<span class="sd">        &quot;y&quot; or &quot;lat&quot; column is required and the first column will be used as</span>
<span class="sd">        IDs in the map.</span>

<span class="sd">        There are four available methods to prepare the gauge map:</span>

<span class="sd">        * no snapping: ``mask=None``, ``snap_to_river=False``, ``snap_uparea=False``.</span>
<span class="sd">          The gauge locations are used as is.</span>
<span class="sd">        * snapping to mask: the gauge locations are snapped to a boolean mask map based</span>
<span class="sd">          on the closest dowsntream cell within the mask:</span>
<span class="sd">          either provide ``mask`` or set ``snap_to_river=True``</span>
<span class="sd">          to snap to the river cells (default).</span>
<span class="sd">          ``max_dist`` can be used to set the maximum distance to snap to the mask.</span>
<span class="sd">        * snapping based on upstream area matching: : ``snap_uparea=True``.</span>
<span class="sd">          The gauge locations are snapped to the closest matching upstream area value.</span>
<span class="sd">          Requires gauges_fn to have an ``uparea`` [km2] column. The closest value will</span>
<span class="sd">          be looked for in a cell window of size ``wdw`` and the absolute and relative</span>
<span class="sd">          differences between the gauge and the closest value should be smaller than</span>
<span class="sd">          ``abs_error`` and ``rel_error``.</span>
<span class="sd">        * snapping based on upstream area matching and mask: ``snap_uparea=True``,</span>
<span class="sd">          ``mask`` or ``snap_to_river=True``. The gauge locations are snapped to the</span>
<span class="sd">          closest matching upstream area value within the mask.</span>

<span class="sd">        If ``derive_subcatch`` is set to True, an additional subcatch map is derived</span>
<span class="sd">        from the gauge locations.</span>

<span class="sd">        Finally the output locations can be added to wflow TOML file sections</span>
<span class="sd">        [output.csv] or [output.netcdf_scalar] using the ``toml_output`` option. The</span>
<span class="sd">        ``gauge_toml_header`` and ``gauge_toml_param`` options can be used to define</span>
<span class="sd">        the header and corresponding wflow variable names in the TOML file.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **gauges_source** map: gauge IDs map from source [-] (if gauges_fn)</span>
<span class="sd">        * **subcatchment_source** map: subcatchment based on gauge locations [-] \</span>
<span class="sd">(if derive_subcatch)</span>
<span class="sd">        * **gauges_source** geom: polygon of gauges from source</span>
<span class="sd">        * **subcatchment_source** geom: polygon of subcatchment based on \</span>
<span class="sd">gauge locations [-] (if derive_subcatch)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gauges_fn : str, Path, geopandas.GeoDataFrame</span>
<span class="sd">            Catalog source name, path to gauges file geometry file or</span>
<span class="sd">            geopandas.GeoDataFrame.</span>

<span class="sd">            * Required variables if snap_uparea is True: &#39;uparea&#39; [km2]</span>
<span class="sd">        index_col : str, optional</span>
<span class="sd">            Column in gauges_fn to use for ID values, by default None</span>
<span class="sd">            (use the default index column)</span>
<span class="sd">        mask : np.boolean, optional</span>
<span class="sd">            If provided snaps to the mask, else snaps to the river (default).</span>
<span class="sd">        snap_to_river : bool, optional</span>
<span class="sd">            Snap point locations to the closest downstream river cell, by default True</span>
<span class="sd">        snap_uparea: bool, optional</span>
<span class="sd">            Snap gauges based on upstream area. Gauges_fn should have &quot;uparea&quot;</span>
<span class="sd">            in its attributes.</span>
<span class="sd">        max_dist : float, optional</span>
<span class="sd">            Maximum distance [m] between original and snapped point location.</span>
<span class="sd">            A warning is logged if exceeded. By default 10 000m.</span>
<span class="sd">        wdw: int, optional</span>
<span class="sd">            Window size in number of cells around the gauge locations</span>
<span class="sd">            to snap uparea to, only used if ``snap_uparea`` is True. By default 3.</span>
<span class="sd">        rel_error: float, optional</span>
<span class="sd">            Maximum relative error (default 0.05)</span>
<span class="sd">            between the gauge location upstream area and the upstream area of</span>
<span class="sd">            the best fit grid cell, only used if snap_uparea is True.</span>
<span class="sd">        abs_error: float, optional</span>
<span class="sd">            Maximum absolute error (default 50.0)</span>
<span class="sd">            between the gauge location upstream area and the upstream area of</span>
<span class="sd">            the best fit grid cell, only used if snap_uparea is True.</span>
<span class="sd">        fillna: bool, optional</span>
<span class="sd">            Fill missing values in the gauges uparea column with the values from wflow</span>
<span class="sd">            upstream area (ie no snapping). By default False and the gauges with NaN</span>
<span class="sd">            values are skipped.</span>
<span class="sd">        derive_subcatch : bool, optional</span>
<span class="sd">            Derive subcatch map for gauges, by default False</span>
<span class="sd">        basename : str, optional</span>
<span class="sd">            Map name in grid (gauges_basename)</span>
<span class="sd">            if None use the gauges_fn basename.</span>
<span class="sd">        toml_output : str, optional</span>
<span class="sd">            One of [&#39;csv&#39;, &#39;netcdf_scalar&#39;, None] to update [output.csv] or</span>
<span class="sd">            [output.netcdf_scalar] section of wflow toml file or do nothing. By</span>
<span class="sd">            default, &#39;csv&#39;.</span>
<span class="sd">        gauge_toml_header : list, optional</span>
<span class="sd">            Save specific model parameters in csv section.</span>
<span class="sd">            This option defines the header of the csv file.</span>
<span class="sd">            By default saves river_q (for river_water__volume_flow_rate) and</span>
<span class="sd">            precip (for &quot;atmosphere_water__precipitation_volume_flux&quot;).</span>
<span class="sd">        gauge_toml_param: list, optional</span>
<span class="sd">            Save specific model parameters in csv section. This option defines</span>
<span class="sd">            the wflow variable corresponding to the names in gauge_toml_header.</span>
<span class="sd">            By default saves river_water__volume_flow_rate (for river_q) and</span>
<span class="sd">            &quot;atmosphere_water__precipitation_volume_flux&quot; (for precip).</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments to pass to the get_data method ie</span>
<span class="sd">            get_geodataframe or get_geodataset depending  on the data_type of gauges_fn.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Read data</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gauges_fn</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">):</span>
            <span class="n">gdf_gauges</span> <span class="o">=</span> <span class="n">gauges_fn</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">gdf_gauges</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="s2">&quot;Point&quot;</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gauges_fn</span><span class="si">}</span><span class="s2"> contains other geometries than Point&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">isfile</span><span class="p">(</span><span class="n">gauges_fn</span><span class="p">):</span>
            <span class="c1"># try to get epsg number directly, important when writing back data_catalog</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="s2">&quot;to_epsg&quot;</span><span class="p">):</span>
                <span class="n">code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_epsg</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">crs</span><span class="o">=</span><span class="n">code</span><span class="p">)</span>
            <span class="n">gdf_gauges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
                <span class="n">gauges_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins</span><span class="p">,</span>
                <span class="n">assert_gtype</span><span class="o">=</span><span class="s2">&quot;Point&quot;</span><span class="p">,</span>
                <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">gauges_fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">sources</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_source</span><span class="p">(</span><span class="n">gauges_fn</span><span class="p">)</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;GeoDataFrame&quot;</span><span class="p">:</span>
                <span class="n">gdf_gauges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
                    <span class="n">gauges_fn</span><span class="p">,</span>
                    <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins</span><span class="p">,</span>
                    <span class="n">assert_gtype</span><span class="o">=</span><span class="s2">&quot;Point&quot;</span><span class="p">,</span>
                    <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_source</span><span class="p">(</span><span class="n">gauges_fn</span><span class="p">)</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;GeoDataset&quot;</span><span class="p">:</span>
                <span class="n">da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataset</span><span class="p">(</span>
                    <span class="n">gauges_fn</span><span class="p">,</span>
                    <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins</span><span class="p">,</span>
                    <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">gdf_gauges</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">to_gdf</span><span class="p">()</span>
                <span class="c1"># Check for point geometry</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">gdf_gauges</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="s2">&quot;Point&quot;</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gauges_fn</span><span class="si">}</span><span class="s2"> contains other geometries than Point&quot;</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gauges_fn</span><span class="si">}</span><span class="s2"> data source not found or incorrect data_type &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_source</span><span class="p">(</span><span class="n">gauges_fn</span><span class="p">)</span><span class="o">.</span><span class="n">data_type</span><span class="si">}</span><span class="s2"> instead of &quot;</span>
                <span class="s2">&quot;GeoDataFrame or GeoDataset).&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Create basename</span>
        <span class="k">if</span> <span class="n">basename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">gauges_fn</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">)</span>

        <span class="c1"># Check if there is data found</span>
        <span class="k">if</span> <span class="n">gdf_gauges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skipping method, as no data has been found&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Create the gauges map</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">basename</span><span class="si">}</span><span class="s2"> gauge locations found within domain&quot;</span>
        <span class="p">)</span>

        <span class="c1"># read existing geoms; important to get the right basin when updating</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span>
        <span class="c1"># Reproject to model crs</span>
        <span class="n">gdf_gauges</span> <span class="o">=</span> <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Get coords, index and ID</span>
        <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))(</span>
            <span class="n">gdf_gauges</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">xy_to_idx</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index_col</span> <span class="ow">in</span> <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">gdf_gauges</span> <span class="o">=</span> <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">index_col</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Gauge ID 0 is not allowed, setting to 1&quot;</span><span class="p">)</span>
            <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># if snap_to_river use river map as the mask</span>
        <span class="k">if</span> <span class="n">snap_to_river</span> <span class="ow">and</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="n">snap_uparea</span> <span class="ow">and</span> <span class="s2">&quot;uparea&quot;</span> <span class="ow">in</span> <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># Derive gauge map based on upstream area snapping</span>
            <span class="n">da</span><span class="p">,</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">ids</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">gauge_map_uparea</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="n">gdf_gauges</span><span class="p">,</span>
                <span class="n">uparea_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;uparea&quot;</span><span class="p">],</span>
                <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                <span class="n">wdw</span><span class="o">=</span><span class="n">wdw</span><span class="p">,</span>
                <span class="n">rel_error</span><span class="o">=</span><span class="n">rel_error</span><span class="p">,</span>
                <span class="n">abs_error</span><span class="o">=</span><span class="n">abs_error</span><span class="p">,</span>
                <span class="n">fillna</span><span class="o">=</span><span class="n">fillna</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Derive gauge map</span>
            <span class="n">da</span><span class="p">,</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">ids</span> <span class="o">=</span> <span class="n">flw</span><span class="o">.</span><span class="n">gauge_map</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="n">idxs</span><span class="o">=</span><span class="n">idxs</span><span class="p">,</span>
                <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
                <span class="n">stream</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                <span class="n">flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span>
                <span class="n">max_dist</span><span class="o">=</span><span class="n">max_dist</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Filter gauges that could not be snapped to rivers</span>
            <span class="k">if</span> <span class="n">snap_to_river</span><span class="p">:</span>
                <span class="n">ids_old</span> <span class="o">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">da</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">nodata</span>
                <span class="p">)</span>
                <span class="n">ids_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">da</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">idxs</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">ids_old</span><span class="p">,</span> <span class="n">ids_new</span><span class="p">)]</span>
                <span class="n">ids</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>

        <span class="c1"># Check if there are gauges left</span>
        <span class="k">if</span> <span class="n">ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;No gauges found within domain after snapping, skipping method.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Add to grid</span>
        <span class="n">mapname</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;gauges_</span><span class="si">{</span><span class="n">basename</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">mapname</span><span class="p">)</span>

        <span class="c1"># geoms</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">idx_to_xy</span><span class="p">(</span><span class="n">idxs</span><span class="p">))</span>
        <span class="c1"># if csv contains additional columns, these are also written in the geoms</span>
        <span class="n">gdf_snapped</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">ids</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">geometry</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span>
        <span class="p">)</span>
        <span class="c1"># Set the index name of gdf snapped based on original gdf</span>
        <span class="k">if</span> <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gdf_snapped</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gdf_snapped</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;fid&quot;</span>
            <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;fid&quot;</span>
        <span class="c1"># Add gdf attributes to gdf_snapped (filter on snapped index before merging)</span>
        <span class="n">df_attrs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">gdf_gauges</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">))</span>
        <span class="n">df_attrs</span> <span class="o">=</span> <span class="n">df_attrs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">df_attrs</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">gdf_snapped</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span>
        <span class="n">gdf_snapped</span> <span class="o">=</span> <span class="n">gdf_snapped</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_attrs</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># Add gdf_snapped to geoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_snapped</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">mapname</span><span class="p">)</span>

        <span class="c1"># Add output timeseries for gauges in the toml</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup_config_output_timeseries</span><span class="p">(</span>
            <span class="n">mapname</span><span class="o">=</span><span class="n">mapname</span><span class="p">,</span>
            <span class="n">toml_output</span><span class="o">=</span><span class="n">toml_output</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="n">gauge_toml_header</span><span class="p">,</span>
            <span class="n">param</span><span class="o">=</span><span class="n">gauge_toml_param</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># add subcatch</span>
        <span class="k">if</span> <span class="n">derive_subcatch</span><span class="p">:</span>
            <span class="n">da_basins</span> <span class="o">=</span> <span class="n">flw</span><span class="o">.</span><span class="n">basin_map</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span> <span class="n">idxs</span><span class="o">=</span><span class="n">idxs</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mapname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">basename</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_basins</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">mapname</span><span class="p">)</span>
            <span class="n">gdf_basins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">mapname</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">vectorize</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_basins</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">mapname</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_areamap">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_areamap.html#hydromt_wflow.WflowModel.setup_areamap">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_areamap</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">area_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">col2raster</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">nodata</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set area map from vector data to save wflow outputs for specific area.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **col2raster** map:  output area data map</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        area_fn : str, geopandas.GeoDataFrame</span>
<span class="sd">            Name of GeoDataFrame data corresponding to wflow output area.</span>
<span class="sd">        col2raster : str</span>
<span class="sd">            Name of the column from `area_fn` to rasterize.</span>
<span class="sd">        nodata : int/float, optional</span>
<span class="sd">            Nodata value to use when rasterizing. Should match the dtype of `col2raster`</span>
<span class="sd">            . By default -1.</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file. If another name is provided than col2raster, this name</span>
<span class="sd">            will be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparing &#39;</span><span class="si">{</span><span class="n">col2raster</span><span class="si">}</span><span class="s2">&#39; map from &#39;</span><span class="si">{</span><span class="n">area_fn</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>
        <span class="n">gdf_org</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">area_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins</span><span class="p">,</span> <span class="n">dst_crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No shapes of </span><span class="si">{</span><span class="n">area_fn</span><span class="si">}</span><span class="s2"> found within region, skipping areamap.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span>
                <span class="n">gdf</span><span class="o">=</span><span class="n">gdf_org</span><span class="p">,</span>
                <span class="n">col_name</span><span class="o">=</span><span class="n">col2raster</span><span class="p">,</span>
                <span class="n">nodata</span><span class="o">=</span><span class="n">nodata</span><span class="p">,</span>
                <span class="n">all_touched</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">output_names</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Only one output name is allowed for areamap, </span><span class="se">\</span>
<span class="s2">                    please provide a dictionary with one key.&quot;</span>
                <span class="p">)</span>
            <span class="n">col2raster_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">output_names</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">col2raster_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col2raster_name</span> <span class="o">=</span> <span class="n">col2raster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_area</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">col2raster_name</span><span class="p">))</span></div>


<div class="viewcode-block" id="WflowModel.setup_lakes">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_lakes.html#hydromt_wflow.WflowModel.setup_lakes">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_lakes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lakes_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">rating_curve_fns</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_area</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
        <span class="n">add_maxstorage</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;lake_area__count&quot;</span><span class="p">:</span> <span class="s2">&quot;lake_area_id&quot;</span><span class="p">,</span>
            <span class="s2">&quot;lake_location__count&quot;</span><span class="p">:</span> <span class="s2">&quot;lake_outlet_id&quot;</span><span class="p">,</span>
            <span class="s2">&quot;lake_surface__area&quot;</span><span class="p">:</span> <span class="s2">&quot;lake_area&quot;</span><span class="p">,</span>
            <span class="s2">&quot;lake_water_surface__initial_elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;lake_initial_depth&quot;</span><span class="p">,</span>
            <span class="s2">&quot;lake_water_flow_threshold-level__elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;lake_outflow_threshold&quot;</span><span class="p">,</span>
            <span class="s2">&quot;lake_water__rating_curve_coefficient&quot;</span><span class="p">:</span> <span class="s2">&quot;lake_b&quot;</span><span class="p">,</span>
            <span class="s2">&quot;lake_water__rating_curve_exponent&quot;</span><span class="p">:</span> <span class="s2">&quot;lake_e&quot;</span><span class="p">,</span>
            <span class="s2">&quot;lake_water__rating_curve_type_count&quot;</span><span class="p">:</span> <span class="s2">&quot;lake_rating_curve&quot;</span><span class="p">,</span>
            <span class="s2">&quot;lake_water__storage_curve_type_count&quot;</span><span class="p">:</span> <span class="s2">&quot;lake_storage_curve&quot;</span><span class="p">,</span>
            <span class="s2">&quot;lake~lower_location__count&quot;</span><span class="p">:</span> <span class="s2">&quot;lake_lower_id&quot;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">geom_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;lakes&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate maps of lake areas and outlets.</span>

<span class="sd">        Also meant to generate parameters with average lake area,</span>
<span class="sd">        depth and discharge values. The data is generated from features with</span>
<span class="sd">        ``min_area`` [km2] (default 1 km2) from a database with lake geometry, IDs and</span>
<span class="sd">        metadata. Data required are lake ID &#39;waterbody_id&#39;,</span>
<span class="sd">        average area &#39;Area_avg&#39; [m2], average volume &#39;Vol_avg&#39; [m3],</span>
<span class="sd">        average depth &#39;Depth_avg&#39; [m] and average discharge &#39;Dis_avg&#39; [m3/s].</span>

<span class="sd">        If rating curve data is available for storage and discharge they can be prepared</span>
<span class="sd">        via ``rating_curve_fns`` (see below for syntax and requirements).</span>
<span class="sd">        Else the parameters &#39;lake_b&#39; and &#39;lake_e&#39; will be used for discharge and</span>
<span class="sd">        for storage a rectangular profile lake is assumed.</span>
<span class="sd">        See Wflow documentation for more information.</span>

<span class="sd">        If ``add_maxstorage`` is True, the maximum storage of the lake is added to the</span>
<span class="sd">        output (controlled lake) based on &#39;Vol_max&#39; [m3] column of lakes_fn.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **lake_area_id** map: lake IDs [-]</span>
<span class="sd">        * **lake_outlet_id** map: lake IDs at outlet locations [-]</span>
<span class="sd">        * **lake_area** map: lake area [m2]</span>
<span class="sd">        * **lake_initial_depth** map: lake average water level [m]</span>
<span class="sd">        * **lake_outflow_threshold** map: lake outflow threshold water level [m]</span>
<span class="sd">        * **meta_lake_mean_outflow** map: lake average discharge [m3/s]</span>
<span class="sd">        * **lake_b** map: lake rating curve coefficient [-]</span>
<span class="sd">        * **lake_e** map: lake rating curve exponent [-]</span>
<span class="sd">        * **lake_rating_curve** map: option to compute rating curve [-]</span>
<span class="sd">        * **lake_storage_curve** map: option to compute storage curve [-]</span>
<span class="sd">        * **lake_lower_id** map: optional, lower linked lake locations [-]</span>
<span class="sd">        * **LakeMaxStorage** map: optional, maximum storage of lake [m3]</span>
<span class="sd">        * **lakes** geom: polygon with lakes and wflow lake parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lakes_fn :</span>
<span class="sd">            Name of GeoDataFrame source for lake parameters.</span>

<span class="sd">            * Required variables for direct use: \</span>
<span class="sd">&#39;waterbody_id&#39; [-], &#39;Area_avg&#39; [m2], &#39;Depth_avg&#39; [m], &#39;Dis_avg&#39; [m3/s], &#39;lake_b&#39; [-], \</span>
<span class="sd">&#39;lake_e&#39; [-], &#39;lake_rating_curve&#39; [-], &#39;lake_storage_curve&#39; [-], \</span>
<span class="sd">&#39;lake_outflow_threshold&#39; [m], &#39;lake_lower_id&#39; [-]</span>

<span class="sd">            * Required variables for parameter estimation: \</span>
<span class="sd">&#39;waterbody_id&#39; [-], &#39;Area_avg&#39; [m2], &#39;Vol_avg&#39; [m3], &#39;Depth_avg&#39; [m], &#39;Dis_avg&#39;[m3/s]</span>
<span class="sd">        rating_curve_fns: str, Path, pandas.DataFrame, List, optional</span>
<span class="sd">            Data catalog entry/entries, path(s) or pandas.DataFrame containing rating</span>
<span class="sd">            curve values for lakes. If None then will be derived from properties of</span>
<span class="sd">            `lakes_fn`.</span>
<span class="sd">            Assumes one file per lake (with all variables) and that the lake ID is</span>
<span class="sd">            either in the filename or data catalog entry name (eg using placeholder).</span>
<span class="sd">            The ID should be placed at the end separated by an underscore (eg</span>
<span class="sd">            &#39;rating_curve_12.csv&#39; or &#39;rating_curve_12&#39;)</span>

<span class="sd">            * Required variables for storage curve: &#39;elevtn&#39; [m+REF], &#39;volume&#39; [m3]</span>

<span class="sd">            * Required variables for rating curve: &#39;elevtn&#39; [m+REF], &#39;discharge&#39; [m3/s]</span>
<span class="sd">        min_area : float, optional</span>
<span class="sd">            Minimum lake area threshold [km2], by default 10.0 km2.</span>
<span class="sd">        add_maxstorage : bool, optional</span>
<span class="sd">            If True, maximum storage of the lake is added to the output</span>
<span class="sd">            (controlled lake) based on &#39;Vol_max&#39; [m3] column of lakes_fn.</span>
<span class="sd">            By default False (natural lake).</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>
<span class="sd">        geom_name : str, optional</span>
<span class="sd">            Name of the lakes geometry in the staticgeoms folder, by default &#39;lakes&#39;</span>
<span class="sd">            for lakes.geojson.</span>
<span class="sd">        kwargs: optional</span>
<span class="sd">            Keyword arguments passed to the method</span>
<span class="sd">            hydromt.DataCatalog.get_rasterdataset()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Derive lake are and outlet maps</span>
        <span class="n">gdf_org</span><span class="p">,</span> <span class="n">ds_lakes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_waterbodies</span><span class="p">(</span>
            <span class="n">lakes_fn</span><span class="p">,</span> <span class="s2">&quot;lake&quot;</span><span class="p">,</span> <span class="n">min_area</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ds_lakes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skipping method, as no data has been found&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>

        <span class="c1"># If rating_curve_fn prepare rating curve dict</span>
        <span class="n">rating_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">rating_curve_fns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rating_curve_fns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">rating_curve_fns</span><span class="p">)</span>
            <span class="c1"># Find ids in rating_curve_fns</span>
            <span class="n">fns_ids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">rating_curve_fns</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fns_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Could not parse integer lake index from </span><span class="se">\</span>
<span class="s2">rating curve fn </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s2">. Skipping.&quot;</span>
                    <span class="p">)</span>
            <span class="c1"># assume lake index will be in the path</span>
            <span class="c1"># Assume one rating curve per lake index</span>
            <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">gdf_org</span><span class="p">[</span><span class="s2">&quot;waterbody_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="nb">id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
                <span class="c1"># Find if id is is one of the paths in rating_curve_fns</span>
                <span class="k">if</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">fns_ids</span><span class="p">:</span>
                    <span class="c1"># Update path based on current waterbody_id</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">fns_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
                    <span class="n">rating_fn</span> <span class="o">=</span> <span class="n">rating_curve_fns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="c1"># Read data</span>
                    <span class="k">if</span> <span class="n">isfile</span><span class="p">(</span><span class="n">rating_fn</span><span class="p">)</span> <span class="ow">or</span> <span class="n">rating_fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Preparing lake rating curve data from </span><span class="si">{</span><span class="n">rating_fn</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="n">df_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span><span class="n">rating_fn</span><span class="p">)</span>
                        <span class="c1"># Add to dict</span>
                        <span class="n">rating_dict</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_rate</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Rating curve file not found for lake with id </span><span class="si">{</span><span class="nb">id</span><span class="si">}</span><span class="s2">. </span><span class="se">\</span>
<span class="s2">Using default storage/outflow function parameters.&quot;</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;No rating curve data provided. </span><span class="se">\</span>
<span class="s2">Using default storage/outflow function parameters.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># add waterbody parameters</span>
        <span class="n">ds_lakes</span><span class="p">,</span> <span class="n">gdf_lakes</span><span class="p">,</span> <span class="n">rating_curves</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">waterbodies</span><span class="o">.</span><span class="n">lakeattrs</span><span class="p">(</span>
            <span class="n">ds_lakes</span><span class="p">,</span> <span class="n">gdf_org</span><span class="p">,</span> <span class="n">rating_dict</span><span class="p">,</span> <span class="n">add_maxstorage</span><span class="o">=</span><span class="n">add_maxstorage</span>
        <span class="p">)</span>

        <span class="c1"># add to grid</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_lakes</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_lakes</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
        <span class="c1"># write lakes with attr tables to static geoms.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_lakes</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">geom_name</span><span class="p">)</span>
        <span class="c1"># add the tables</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">rating_curves</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_tables</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

        <span class="c1"># Lake settings in the toml to update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.lake__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span>
            <span class="s2">&quot;state.variables.lake_water_surface__instantaneous_elevation&quot;</span><span class="p">,</span>
            <span class="s2">&quot;lake_instantaneous_water_level&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="n">ds_lakes</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;lake_area_id&quot;</span><span class="p">,</span> <span class="s2">&quot;lake_outlet_id&quot;</span><span class="p">,</span> <span class="s2">&quot;lake_lower_id&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="n">dvar</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="n">dvar</span><span class="p">])</span></div>


<div class="viewcode-block" id="WflowModel.setup_reservoirs">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_reservoirs.html#hydromt_wflow.WflowModel.setup_reservoirs">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_reservoirs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reservoirs_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">timeseries_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_area</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;reservoir_area__count&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_area_id&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_location__count&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_outlet_id&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_surface__area&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_area&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_water__max_volume&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_max_volume&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_water~min-target__volume_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_target_min_fraction&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;reservoir_water~full-target__volume_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_target_full_fraction&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;reservoir_water_demand~required~downstream__volume_flow_rate&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_demand&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;reservoir_water_release-below-spillway__max_volume_flow_rate&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_max_release&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
        <span class="p">},</span>
        <span class="n">geom_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;reservoirs&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate maps of reservoir areas and outlets.</span>

<span class="sd">        Also meant to generate parameters with average reservoir area, demand,</span>
<span class="sd">        min and max target storage capacities and discharge capacity values.</span>

<span class="sd">        The data is generated from features with ``min_area`` [km2] (default is 1 km2)</span>
<span class="sd">        from a database with reservoir geometry, IDs and metadata.</span>

<span class="sd">        Data requirements for direct use (i.e. wflow parameters are data already present</span>
<span class="sd">        in reservoirs_fn) are reservoir ID &#39;waterbody_id&#39;, area &#39;reservoir_area&#39; [m2],</span>
<span class="sd">        maximum volume &#39;reservoir_max_volume&#39; [m3], the targeted minimum and maximum</span>
<span class="sd">        fraction of water volume in the reservoir &#39;reservoir_target_min_fraction&#39; and</span>
<span class="sd">        &#39;reservoir_target_full_fraction&#39; [-], the average water demand</span>
<span class="sd">        &#39;reservoir_demand&#39; [m3/s] and the maximum release of the reservoir before</span>
<span class="sd">        spilling &#39;reservoir_max_release&#39; [m3/s].</span>

<span class="sd">        In case the wflow parameters are not directly available they can be computed by</span>
<span class="sd">        HydroMT based on time series of reservoir surface water area.</span>
<span class="sd">        These time series can be retrieved from either the hydroengine or the gwwapi,</span>
<span class="sd">        based on the Hylak_id the reservoir, found in the GrandD database.</span>

<span class="sd">        The required variables for computation of the parameters with time series data</span>
<span class="sd">        are reservoir ID &#39;waterbody_id&#39;, reservoir ID in the HydroLAKES database</span>
<span class="sd">        &#39;Hylak_id&#39;, average volume &#39;Vol_avg&#39; [m3], average depth &#39;Depth_avg&#39; [m],</span>
<span class="sd">        average discharge &#39;Dis_avg&#39; [m3/s] and dam height &#39;Dam_height&#39; [m].</span>
<span class="sd">        To compute parameters without using time series data, the required variables in</span>
<span class="sd">        reservoirs_fn are reservoir ID &#39;waterbody_id&#39;, average area &#39;Area_avg&#39; [m2],</span>
<span class="sd">        average volume &#39;Vol_avg&#39; [m3], average depth &#39;Depth_avg&#39; [m], average discharge</span>
<span class="sd">        &#39;Dis_avg&#39; [m3/s] and dam height &#39;Dam_height&#39; [m]</span>
<span class="sd">        and minimum / normal / maximum storage capacity of the dam &#39;Capacity_min&#39;,</span>
<span class="sd">        &#39;Capacity_norm&#39;, &#39;Capacity_max&#39; [m3].</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **reservoir_area_id** map: reservoir IDs [-]</span>
<span class="sd">        * **reservoir_outlet_id** map: reservoir IDs at outlet locations [-]</span>
<span class="sd">        * **reservoir_area** map: reservoir area [m2]</span>
<span class="sd">        * **reservoir_max_volume** map: reservoir max volume [m3]</span>
<span class="sd">        * **reservoir_target_min_fraction** map: reservoir target min frac [m3/m3]</span>
<span class="sd">        * **reservoir_target_full_fraction** map: reservoir target full frac [m3/m3]</span>
<span class="sd">        * **reservoir_demand** map: reservoir demand flow [m3/s]</span>
<span class="sd">        * **reservoir_max_release** map: reservoir max release flow [m3/s]</span>
<span class="sd">        * **reservoirs** geom: polygon with reservoirs and wflow reservoir parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reservoirs_fn : str</span>
<span class="sd">            Name of data source for reservoir parameters, see data/data_sources.yml.</span>

<span class="sd">            * Required variables for direct use: \</span>
<span class="sd">&#39;waterbody_id&#39; [-], &#39;reservoir_area&#39; [m2], &#39;reservoir_max_volume&#39; [m3], \</span>
<span class="sd">&#39;reservoir_target_min_fraction&#39; [m3/m3], &#39;reservoir_target_full_fraction&#39; [m3/m3], \</span>
<span class="sd">&#39;reservoir_demand&#39; [m3/s], &#39;reservoir_max_release&#39; [m3/s]</span>

<span class="sd">            * Required variables for computation with timeseries_fn: \</span>
<span class="sd">&#39;waterbody_id&#39; [-], &#39;Hylak_id&#39; [-], &#39;Vol_avg&#39; [m3], &#39;Depth_avg&#39; [m], &#39;Dis_avg&#39; [m3/s], \</span>
<span class="sd">&#39;Dam_height&#39; [m]</span>

<span class="sd">            * Required variables for computation without timeseries_fn: \</span>
<span class="sd">&#39;waterbody_id&#39; [-], &#39;Area_avg&#39; [m2], &#39;Vol_avg&#39; [m3], &#39;Depth_avg&#39; [m], &#39;Dis_avg&#39; \</span>
<span class="sd">[m3/s], &#39;Capacity_max&#39; [m3], &#39;Capacity_norm&#39; [m3], &#39;Capacity_min&#39; [m3], &#39;Dam_height&#39; [m]</span>
<span class="sd">        timeseries_fn : {&#39;gww&#39;, &#39;hydroengine&#39;, None}, optional</span>
<span class="sd">            Download and use time series of reservoir surface water area to calculate</span>
<span class="sd">            and overwrite the reservoir volume/areas of the data source. Timeseries are</span>
<span class="sd">            either downloaded from Global Water Watch &#39;gww&#39; (using gwwapi package) or</span>
<span class="sd">            JRC &#39;jrc&#39; (using hydroengine package). By default None.</span>
<span class="sd">        min_area : float, optional</span>
<span class="sd">            Minimum reservoir area threshold [km2], by default 1.0 km2.</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>
<span class="sd">        geom_name : str, optional</span>
<span class="sd">            Name of the reservoirs geometry in the staticgeoms folder, by default</span>
<span class="sd">            &quot;reservoirs&quot; for reservoirs.geojson.</span>
<span class="sd">        kwargs: optional</span>
<span class="sd">            Keyword arguments passed to the method</span>
<span class="sd">            hydromt.DataCatalog.get_rasterdataset()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Derive reservoir area and outlet maps</span>
        <span class="n">gdf_org</span><span class="p">,</span> <span class="n">ds_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_waterbodies</span><span class="p">(</span>
            <span class="n">reservoirs_fn</span><span class="p">,</span> <span class="s2">&quot;reservoir&quot;</span><span class="p">,</span> <span class="n">min_area</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="c1"># Skip method if no data is returned</span>
        <span class="k">if</span> <span class="n">ds_res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skipping method, as no data has been found&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>
        <span class="c1"># Continue method if data has been found</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_res</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_res</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
            <span class="n">ds_res</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span>

        <span class="c1"># add attributes</span>
        <span class="c1"># if present use directly</span>
        <span class="n">resattributes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;waterbody_id&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_area&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_max_volume&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_target_min_fraction&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_target_full_fraction&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_demand&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_max_release&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">resattributes</span><span class="p">,</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
            <span class="n">intbl_reservoirs</span> <span class="o">=</span> <span class="n">gdf_org</span><span class="p">[</span><span class="n">resattributes</span><span class="p">]</span>
            <span class="n">reservoir_accuracy</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">reservoir_timeseries</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># else compute</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span>
                <span class="n">intbl_reservoirs</span><span class="p">,</span>
                <span class="n">reservoir_accuracy</span><span class="p">,</span>
                <span class="n">reservoir_timeseries</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">reservoirattrs</span><span class="p">(</span>
                <span class="n">gdf</span><span class="o">=</span><span class="n">gdf_org</span><span class="p">,</span> <span class="n">timeseries_fn</span><span class="o">=</span><span class="n">timeseries_fn</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span>
            <span class="p">)</span>

        <span class="c1"># create a geodf with id of reservoir and geometry at outflow location</span>
        <span class="n">gdf_org_points</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="n">gdf_org</span><span class="p">[</span><span class="s2">&quot;waterbody_id&quot;</span><span class="p">],</span>
            <span class="n">geometry</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">gdf_org</span><span class="o">.</span><span class="n">xout</span><span class="p">,</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">yout</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">intbl_reservoirs</span> <span class="o">=</span> <span class="n">intbl_reservoirs</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;expr1&quot;</span><span class="p">:</span> <span class="s2">&quot;waterbody_id&quot;</span><span class="p">})</span>
        <span class="n">gdf_org_points</span> <span class="o">=</span> <span class="n">gdf_org_points</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">intbl_reservoirs</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;waterbody_id&quot;</span>
        <span class="p">)</span>  <span class="c1"># merge</span>
        <span class="c1"># add parameter attributes to polygon gdf:</span>
        <span class="n">gdf_org</span> <span class="o">=</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">intbl_reservoirs</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;waterbody_id&quot;</span><span class="p">)</span>

        <span class="c1"># write reservoirs with param values to geoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_org</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">geom_name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">gdf_org_points</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
            <span class="n">gdf_org_points</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_org_points</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
            <span class="n">da_res</span> <span class="o">=</span> <span class="n">ds_res</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span>
                <span class="n">gdf_org_points</span><span class="p">,</span> <span class="n">col_name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="n">nodata</span><span class="o">=-</span><span class="mi">999</span>
            <span class="p">)</span>
            <span class="n">output_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_res</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">output_name</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;static&quot;</span><span class="p">)</span>

        <span class="c1"># Save accuracy information on reservoir parameters</span>
        <span class="k">if</span> <span class="n">reservoir_accuracy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reservoir_accuracy</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;reservoir_accuracy.csv&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">reservoir_timeseries</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reservoir_timeseries</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
                <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;reservoir_timeseries_</span><span class="si">{</span><span class="n">timeseries_fn</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># update toml</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.reservoir__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span>
            <span class="s2">&quot;state.variables.reservoir_water__instantaneous_volume&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_instantaneous_volume&quot;</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_setup_waterbodies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waterbodies_fn</span><span class="p">,</span> <span class="n">wb_type</span><span class="p">,</span> <span class="n">min_area</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Help with common workflow of setup_lakes and setup_reservoir.</span>

<span class="sd">        See specific methods for more info about the arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># retrieve data for basin</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparing </span><span class="si">{</span><span class="n">wb_type</span><span class="si">}</span><span class="s2"> maps.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;predicate&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;contains&quot;</span><span class="p">)</span>
        <span class="n">gdf_org</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">waterbodies_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins_highres</span><span class="p">,</span>
            <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">gdf_org</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Return two times None (similar to main function output), if there is no</span>
            <span class="c1"># data found</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># skip small size waterbodies</span>
        <span class="k">if</span> <span class="s2">&quot;Area_avg&quot;</span> <span class="ow">in</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">min_area_m2</span> <span class="o">=</span> <span class="n">min_area</span> <span class="o">*</span> <span class="mf">1e6</span>
            <span class="n">gdf_org</span> <span class="o">=</span> <span class="n">gdf_org</span><span class="p">[</span><span class="n">gdf_org</span><span class="o">.</span><span class="n">Area_avg</span> <span class="o">&gt;=</span> <span class="n">min_area_m2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">wb_type</span><span class="si">}</span><span class="s2">&#39;s database has no area attribute. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;All </span><span class="si">{</span><span class="n">wb_type</span><span class="si">}</span><span class="s2">s will be considered.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># get waterbodies maps and parameters</span>
        <span class="n">nb_wb</span> <span class="o">=</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">size</span>
        <span class="n">ds_waterbody</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">nb_wb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nb_wb</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">wb_type</span><span class="si">}</span><span class="s2">(s) of sufficient size found within region.&quot;</span><span class="p">)</span>
            <span class="c1"># add waterbody maps</span>
            <span class="n">uparea_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;uparea&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">uparea_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Upstream area map for </span><span class="si">{</span><span class="n">wb_type</span><span class="si">}</span><span class="s2"> outlet setup not found. &quot;</span>
                    <span class="s2">&quot;Database coordinates used instead&quot;</span>
                <span class="p">)</span>
                <span class="n">uparea_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ds_waterbody</span><span class="p">,</span> <span class="n">gdf_wateroutlet</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">waterbodymaps</span><span class="p">(</span>
                <span class="n">gdf</span><span class="o">=</span><span class="n">gdf_org</span><span class="p">,</span>
                <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="n">wb_type</span><span class="o">=</span><span class="n">wb_type</span><span class="p">,</span>
                <span class="n">uparea_name</span><span class="o">=</span><span class="n">uparea_name</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># update/replace xout and yout in gdf_org from gdf_wateroutlet:</span>
            <span class="n">gdf_org</span><span class="p">[</span><span class="s2">&quot;xout&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_wateroutlet</span><span class="p">[</span><span class="s2">&quot;xout&quot;</span><span class="p">]</span>
            <span class="n">gdf_org</span><span class="p">[</span><span class="s2">&quot;yout&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_wateroutlet</span><span class="p">[</span><span class="s2">&quot;yout&quot;</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No </span><span class="si">{</span><span class="n">wb_type</span><span class="si">}</span><span class="s2">s of sufficient size found within region! &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Skipping </span><span class="si">{</span><span class="n">wb_type</span><span class="si">}</span><span class="s2"> procedures!&quot;</span>
            <span class="p">)</span>

        <span class="c1"># rasterize points polygons in raster.rasterize --</span>
        <span class="c1"># you need grid to know the grid</span>
        <span class="k">return</span> <span class="n">gdf_org</span><span class="p">,</span> <span class="n">ds_waterbody</span>

<div class="viewcode-block" id="WflowModel.setup_soilmaps">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_soilmaps.html#hydromt_wflow.WflowModel.setup_soilmaps">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_soilmaps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">soil_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;soilgrids&quot;</span><span class="p">,</span>
        <span class="n">ptf_ksatver</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;brakensiek&quot;</span><span class="p">,</span>
        <span class="n">wflow_thicknesslayers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">800</span><span class="p">],</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;soil_water__saturated_volume_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;soil_theta_s&quot;</span><span class="p">,</span>
            <span class="s2">&quot;soil_water__residual_volume_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;soil_theta_r&quot;</span><span class="p">,</span>
            <span class="s2">&quot;soil_surface_water__vertical_saturated_hydraulic_conductivity&quot;</span><span class="p">:</span> <span class="s2">&quot;soil_ksat_vertical&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;soil__thickness&quot;</span><span class="p">:</span> <span class="s2">&quot;soil_thickness&quot;</span><span class="p">,</span>
            <span class="s2">&quot;soil_water__vertical_saturated_hydraulic_conductivity_scale_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;soil_f&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;soil_layer_water__brooks-corey_exponent&quot;</span><span class="p">:</span> <span class="s2">&quot;soil_brooks_corey_c&quot;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derive several (layered) soil parameters.</span>

<span class="sd">        Based on a database with physical soil properties using available point-scale</span>
<span class="sd">        (pedo)transfer functions (PTFs) from literature with upscaling rules to</span>
<span class="sd">        ensure flux matching across scales.</span>

<span class="sd">        Currently, supported ``soil_fn`` is &quot;soilgrids&quot; and &quot;soilgrids_2020&quot;.</span>
<span class="sd">        ``ptf_ksatver`` (PTF for the vertical hydraulic conductivity) options are</span>
<span class="sd">        &quot;brakensiek&quot; and &quot;cosby&quot;. &quot;soilgrids&quot; provides data at 7 specific depths,</span>
<span class="sd">        while &quot;soilgrids_2020&quot; provides data averaged over 6 depth intervals.</span>
<span class="sd">        This leads to small changes in the workflow:</span>
<span class="sd">        (1) M parameter uses midpoint depths in soilgrids_2020 versus \</span>
<span class="sd">specific depths in soilgrids,</span>
<span class="sd">        (2) weighted average of soil properties over soil thickness is done with \</span>
<span class="sd">the trapezoidal rule in soilgrids versus simple block weighted average in \</span>
<span class="sd">soilgrids_2020,</span>
<span class="sd">        (3) the soil_brooks_corey_c parameter is computed as weighted average over \</span>
<span class="sd">wflow_sbm soil layers defined in ``wflow_thicknesslayers``.</span>

<span class="sd">        The required data from soilgrids are soil bulk density &#39;bd_sl*&#39; [g/cm3], \</span>
<span class="sd">clay content &#39;clyppt_sl*&#39; [%], silt content &#39;sltppt_sl*&#39; [%], organic carbon content \</span>
<span class="sd">&#39;oc_sl*&#39; [%], pH &#39;ph_sl*&#39; [-], sand content &#39;sndppt_sl*&#39; [%] and soil thickness \</span>
<span class="sd">&#39;soilthickness&#39; [cm].</span>

<span class="sd">        A ``soil_mapping_fn`` can optionnally be provided to derive parameters based</span>
<span class="sd">        on soil texture classes. A default table *soil_mapping_default* is available</span>
<span class="sd">        to derive the infiltration capacity of the soil.</span>

<span class="sd">        The following maps are added to grid:</span>

<span class="sd">        * **soil_theta_s** map:</span>
<span class="sd">            average saturated soil water content [m3/m3]</span>
<span class="sd">        * **soil_theta_r** map:</span>
<span class="sd">            average residual water content [m3/m3]</span>
<span class="sd">        * **soil_ksat_vertical** map:</span>
<span class="sd">            vertical saturated hydraulic conductivity at soil surface [mm/day]</span>
<span class="sd">        * **soil_thickness** map:</span>
<span class="sd">            soil thickness [mm]</span>
<span class="sd">        * **soil_f** map: scaling parameter controlling the decline of ksat_vertical \</span>
<span class="sd">[mm-1] (fitted with curve_fit (scipy.optimize)), bounds are checked</span>
<span class="sd">        * **soil_f_** map:</span>
<span class="sd">            scaling parameter controlling the decline of soil_ksat_vertical \</span>
<span class="sd">[mm-1] (fitted with numpy linalg regression), bounds are checked</span>
<span class="sd">        * **soil_brooks_corey_c_n** map:</span>
<span class="sd">            Brooks Corey coefficients [-] based on pore size distribution, \</span>
<span class="sd">a map for each of the wflow_sbm soil layers (n in total)</span>
<span class="sd">        * **meta_{soil_fn}_ksat_vertical_[z]cm** map: vertical hydraulic conductivity</span>
<span class="sd">            [mm/day] at soil depths [z] of ``soil_fn`` data</span>
<span class="sd">            [0.0, 5.0, 15.0, 30.0, 60.0, 100.0, 200.0]</span>
<span class="sd">        * **meta_soil_texture** map: soil texture based on USDA soil texture triangle \</span>
<span class="sd">(mapping: [1:Clay, 2:Silty Clay, 3:Silty Clay-Loam, 4:Sandy Clay, 5:Sandy Clay-Loam, \</span>
<span class="sd">6:Clay-Loam, 7:Silt, 8:Silt-Loam, 9:Loam, 10:Sand, 11: Loamy Sand, 12:Sandy Loam])</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        soil_fn : {&#39;soilgrids&#39;, &#39;soilgrids_2020&#39;}</span>
<span class="sd">            Name of RasterDataset source for soil parameter maps, see</span>
<span class="sd">            data/data_sources.yml.</span>
<span class="sd">            Should contain info for the 7 soil depths of soilgrids</span>
<span class="sd">            (or 6 depths intervals for soilgrids_2020).</span>
<span class="sd">            * Required variables: \</span>
<span class="sd">&#39;bd_sl*&#39; [g/cm3], &#39;clyppt_sl*&#39; [%], &#39;sltppt_sl*&#39; [%], &#39;oc_sl*&#39; [%], &#39;ph_sl*&#39; [-], \</span>
<span class="sd">&#39;sndppt_sl*&#39; [%], &#39;soilthickness&#39; [cm]</span>
<span class="sd">        ptf_ksatver : {&#39;brakensiek&#39;, &#39;cosby&#39;}</span>
<span class="sd">            Pedotransfer function (PTF) to use for calculation of ksat vertical</span>
<span class="sd">            (vertical saturated hydraulic conductivity [mm/day]).</span>
<span class="sd">            By default &#39;brakensiek&#39;.</span>
<span class="sd">        wflow_thicknesslayers : list of int, optional</span>
<span class="sd">            Thickness of soil layers [mm] for wflow_sbm soil model.</span>
<span class="sd">            By default [100, 300, 800] for layers at depths 100, 400, 1200 and &gt;1200 mm.</span>
<span class="sd">            Used only for Brooks Corey coefficients.</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing soil parameter maps.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>
        <span class="c1"># TODO add variables list with required variable names</span>
        <span class="n">dsin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span><span class="n">soil_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">dsout</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">soilgrids</span><span class="p">(</span>
            <span class="n">ds</span><span class="o">=</span><span class="n">dsin</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">ptfKsatVer</span><span class="o">=</span><span class="n">ptf_ksatver</span><span class="p">,</span>
            <span class="n">soil_fn</span><span class="o">=</span><span class="n">soil_fn</span><span class="p">,</span>
            <span class="n">wflow_layers</span><span class="o">=</span><span class="n">wflow_thicknesslayers</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reset_coords</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dsout</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">dsout</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>

        <span class="c1"># Update the toml file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.soil_layer__thickness&quot;</span><span class="p">,</span> <span class="n">wflow_thicknesslayers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">dsout</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_ksathorfrac">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_ksathorfrac.html#hydromt_wflow.WflowModel.setup_ksathorfrac">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_ksathorfrac</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ksat_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">variable</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">resampling_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;average&quot;</span><span class="p">,</span>
        <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set KsatHorFrac parameter values from a predetermined map.</span>

<span class="sd">        This predetermined map contains (preferably) &#39;calibrated&#39; values of \</span>
<span class="sd">the KsatHorFrac parameter. This map is either selected from the wflow Deltares data \</span>
<span class="sd">or created by a third party/ individual.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ksat_fn : str, xr.DataArray</span>
<span class="sd">            The identifier of the KsatHorFrac dataset in the data catalog.</span>
<span class="sd">        variable : str, optional</span>
<span class="sd">            The variable name for the subsurface_ksat_horizontal_ratio map to</span>
<span class="sd">            use in ``ksat_fn`` in case ``ksat_fn`` contains several variables.</span>
<span class="sd">            By default None.</span>
<span class="sd">        resampling_method : str, optional</span>
<span class="sd">            The resampling method when up- or downscaled, by default &quot;average&quot;</span>
<span class="sd">        output_name : str, optional</span>
<span class="sd">            The name of the output map. If None (default), the name will be set</span>
<span class="sd">            to the name of the ksat_fn DataArray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing KsatHorFrac parameter map.&quot;</span><span class="p">)</span>
        <span class="n">wflow_var</span> <span class="o">=</span> <span class="s2">&quot;subsurface_water__horizontal-to-vertical_saturated_hydraulic_conductivity_ratio&quot;</span>  <span class="c1"># noqa: E501</span>
        <span class="n">dain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">ksat_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">variable</span><span class="p">,</span>
            <span class="n">single_var_as_array</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Ensure its a DataArray</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dain</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The ksat_fn data contains several variables. </span><span class="se">\</span>
<span class="s2">Select the variable to use for subsurface_ksat_horizontal_ratio </span><span class="se">\</span>
<span class="s2">using &#39;variable&#39; argument.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Create scaled subsurface_ksat_horizontal_ratio map</span>
        <span class="n">daout</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">ksat_horizontal_ratio</span><span class="p">(</span>
            <span class="n">dain</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">resampling_method</span><span class="o">=</span><span class="n">resampling_method</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">output_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">daout</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">output_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="n">wflow_var</span><span class="p">:</span> <span class="n">daout</span><span class="o">.</span><span class="n">name</span><span class="p">})</span>
        <span class="c1"># Set the grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">daout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">daout</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_ksatver_vegetation">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_ksatver_vegetation.html#hydromt_wflow.WflowModel.setup_ksatver_vegetation">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_ksatver_vegetation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">soil_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;soilgrids&quot;</span><span class="p">,</span>
        <span class="n">alfa</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">4.5</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;soil_ksat_vertical_vegetation&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correct vertical saturated hydraulic conductivity with vegetation properties.</span>

<span class="sd">        This allows to account for biologically-promoted soil structure and \</span>
<span class="sd">        heterogeneities in natural landscapes based on the work of \</span>
<span class="sd">        Bonetti et al. (2021) https://www.nature.com/articles/s43247-021-00180-0.</span>

<span class="sd">        This method requires to have run setup_soilgrids and setup_lai first.</span>

<span class="sd">        The following map is added to grid:</span>

<span class="sd">        * **KsatVer_vegetation** map: saturated hydraulic conductivity considering \</span>
<span class="sd">        vegetation characteristics [mm/d]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        soil_fn : {&#39;soilgrids&#39;, &#39;soilgrids_2020&#39;}</span>
<span class="sd">            Name of RasterDataset source for soil parameter maps, see</span>
<span class="sd">            data/data_sources.yml.</span>
<span class="sd">            Should contain info for the sand percentage of the upper layer</span>
<span class="sd">            * Required variable: &#39;sndppt_sl1&#39; [%]</span>
<span class="sd">        alfa : float, optional</span>
<span class="sd">            Shape parameter. The default is 4.5 when using LAI.</span>
<span class="sd">        beta : float, optional</span>
<span class="sd">            Shape parameter. The default is 5 when using LAI.</span>
<span class="sd">        output_name : dict, optional</span>
<span class="sd">            Name of the output map. By default &#39;KsatVer_vegetation&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Modifying ksat_vertical based on vegetation characteristics&quot;</span><span class="p">)</span>
        <span class="n">wflow_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;ksat_vertical&quot;</span><span class="p">]]</span>

        <span class="c1"># open soil dataset to get sand percentage</span>
        <span class="n">sndppt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">soil_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sndppt_sl1&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># in ksatver_vegetation, ksat_vertical should be provided in mm/d</span>
        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data_vars</span>
        <span class="p">}</span>
        <span class="n">KSatVer_vegetation</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">ksatver_vegetation</span><span class="p">(</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">sndppt</span><span class="o">=</span><span class="n">sndppt</span><span class="p">,</span>
            <span class="n">alfa</span><span class="o">=</span><span class="n">alfa</span><span class="p">,</span>
            <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="n">wflow_var</span><span class="p">:</span> <span class="n">output_name</span><span class="p">})</span>
        <span class="c1"># add to grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">KSatVer_vegetation</span><span class="p">,</span> <span class="n">output_name</span><span class="p">)</span>
        <span class="c1"># update config file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">output_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_lulcmaps_with_paddy">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_lulcmaps_with_paddy.html#hydromt_wflow.WflowModel.setup_lulcmaps_with_paddy">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_lulcmaps_with_paddy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lulc_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">paddy_class</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">output_paddy_class</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lulc_mapping_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">paddy_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">paddy_mapping_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">soil_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="s2">&quot;soilgrids&quot;</span><span class="p">,</span>
        <span class="n">wflow_thicknesslayers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">800</span><span class="p">],</span>
        <span class="n">target_conductivity</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="mi">5</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">lulc_vars</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;landuse&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_kext&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_canopy__light-extinction_coefficient&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land_manning_n&quot;</span><span class="p">:</span> <span class="s2">&quot;land_surface_water_flow__manning_n_parameter&quot;</span><span class="p">,</span>
            <span class="s2">&quot;soil_compacted_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;soil~compacted__area_fraction&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_root_depth&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__depth&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_leaf_storage&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation__specific-leaf_storage&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_wood_storage&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_wood_water__storage_capacity&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land_water_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;land~water-covered__area_fraction&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_crop_factor&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation__crop_factor&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_feddes_alpha_h1&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~1_reduction_coefficient&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;vegetation_feddes_h1&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_feddes_h2&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~2&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_feddes_h3_high&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~3~high&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;vegetation_feddes_h3_low&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~3~low&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;vegetation_feddes_h4&quot;</span><span class="p">:</span> <span class="s2">&quot;vegetation_root__feddes_critial_pressure_head_h~4&quot;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">paddy_waterlevels</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;demand_paddy_h_min&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
            <span class="s2">&quot;demand_paddy_h_opt&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
            <span class="s2">&quot;demand_paddy_h_max&quot;</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">save_high_resolution_lulc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">output_names_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up landuse maps and parameters including for paddy fields.</span>

<span class="sd">        THIS FUNCTION SHOULD BE RUN AFTER setup_soilmaps.</span>

<span class="sd">        Lookup table `lulc_mapping_fn` columns are converted to lulc classes model</span>
<span class="sd">        parameters based on literature. The data is remapped at its original resolution</span>
<span class="sd">        and then resampled to the model resolution using the average value, unless noted</span>
<span class="sd">        differently.</span>

<span class="sd">        If paddies are present either directly as a class in the landuse_fn or in a</span>
<span class="sd">        separate paddy_fn, the paddy class is used to derive the paddy parameters.</span>

<span class="sd">        To allow for water to pool on the surface (for paddy/rice fields), the layers in</span>
<span class="sd">        the model can be updated to new depths, such that we can allow a thin layer with</span>
<span class="sd">        limited vertical conductivity. These updated layers means that the</span>
<span class="sd">        ``soil_brooks_corey_c`` parameter needs to be calculated again. Next, the</span>
<span class="sd">        soil_ksat_vertical_factor layer corrects the vertical conductivity</span>
<span class="sd">        (by multiplying) such that the bottom of the layer corresponds to the</span>
<span class="sd">        ``target_conductivity`` for that layer. This currently assumes the wflow models</span>
<span class="sd">        to have an exponential declining vertical conductivity (using the ``f``</span>
<span class="sd">        parameter). If no target_conductivity is specified for a layer (``None``),</span>
<span class="sd">        the soil_ksat_vertical_factor value is set to 1.</span>

<span class="sd">        The different values for the minimum/optimal/maximum water levels for paddy</span>
<span class="sd">        fields will be added as constant values in the toml file, through the</span>
<span class="sd">        ``land~irrigated-paddy__min_depth.value = 20`` interface.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **landuse** map:</span>
<span class="sd">            Landuse class [-]</span>
<span class="sd">        * **vegetation_kext** map:</span>
<span class="sd">            Extinction coefficient in the canopy gap fraction equation [-]</span>
<span class="sd">        * **vegetation_leaf_storage** map:</span>
<span class="sd">            Specific leaf storage [mm]</span>
<span class="sd">        * **vegetation_wood_storage** map:</span>
<span class="sd">            Fraction of wood in the vegetation/plant [-]</span>
<span class="sd">        * **vegetation_root_depth** map:</span>
<span class="sd">            Length of vegetation roots [mm]</span>
<span class="sd">        * **soil_compacted_fraction** map:</span>
<span class="sd">            The fraction of compacted or urban area per grid cell [-]</span>
<span class="sd">        * **land_water_fraction** map:</span>
<span class="sd">            The fraction of open water per grid cell [-]</span>
<span class="sd">        * **land_manning_n** map:</span>
<span class="sd">            Manning Roughness [-]</span>
<span class="sd">        * **vegetation_crop_factor** map:</span>
<span class="sd">            Crop coefficient [-]</span>
<span class="sd">        * **vegetation_feddes_alpha_h1** map:</span>
<span class="sd">            Root water uptake reduction at soil water pressure head</span>
<span class="sd">            h1 (0 or 1) [-]</span>
<span class="sd">        * **vegetation_feddes_h1** map:</span>
<span class="sd">            Soil water pressure head h1 at which root water</span>
<span class="sd">            uptake is reduced (Feddes) [cm]</span>
<span class="sd">        * **vegetation_feddes_h2** map:</span>
<span class="sd">            Soil water pressure head h2 at which root water</span>
<span class="sd">            uptake is reduced (Feddes) [cm]</span>
<span class="sd">        * **vegetation_feddes_h3_high** map:</span>
<span class="sd">            Soil water pressure head h3 (high) at which root water uptake is</span>
<span class="sd">            reduced (Feddes) [cm]</span>
<span class="sd">        * **vegetation_feddes_h3_low** map:</span>
<span class="sd">            Soil water pressure head h3 (low) at which root water uptake is</span>
<span class="sd">            reduced (Feddes) [cm]</span>
<span class="sd">        * **vegetation_feddes_h4** map:</span>
<span class="sd">            Soil water pressure head h4 at which root water</span>
<span class="sd">            uptake is reduced (Feddes) [cm]</span>
<span class="sd">        * **demand_paddy_h_min** value:</span>
<span class="sd">            Minimum required water depth for paddy fields [mm]</span>
<span class="sd">        * **demand_paddy_h_opt** value:</span>
<span class="sd">            Optimal water depth for paddy fields [mm]</span>
<span class="sd">        * **demand_paddy_h_max** value:</span>
<span class="sd">            Maximum water depth for paddy fields [mm]</span>
<span class="sd">        * **soil_ksat_vertical_factor**:</span>
<span class="sd">            Map with a multiplication factor for the vertical conductivity [-]</span>

<span class="sd">        Updates model layers:</span>

<span class="sd">        * **soil_brooks_corey_c**:</span>
<span class="sd">            Brooks Corey coefficients [-] based on pore size</span>
<span class="sd">            distribution, a map for each of the wflow_sbm soil layers (updated based</span>
<span class="sd">            on the newly specified layers)</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lulc_fn : str, Path, xr.DataArray</span>
<span class="sd">            RasterDataset or name in data catalog / path to landuse map.</span>
<span class="sd">        paddy_class : int</span>
<span class="sd">            Landuse class value for paddy fields either in landuse_fn or paddy_fn if</span>
<span class="sd">            provided.</span>
<span class="sd">        output_paddy_class : int, optional</span>
<span class="sd">            Landuse class value for paddy fields in the output landuse map. If None,</span>
<span class="sd">            the ``paddy_class`` is used, by default None. This can be useful when</span>
<span class="sd">            merging paddy location from ``paddy_fn`` into ``landuse_fn``.</span>
<span class="sd">        lulc_mapping_fn : str, Path, pd.DataFrame, optional</span>
<span class="sd">            Path to a mapping csv file from landuse in source name to parameter values</span>
<span class="sd">            in lulc_vars. If lulc_fn is one of {&quot;globcover&quot;, &quot;vito&quot;, &quot;corine&quot;,</span>
<span class="sd">            &quot;esa_worldcover&quot;, &quot;glmnco&quot;}, a default mapping is used and this argument</span>
<span class="sd">            becomes optional.</span>
<span class="sd">        paddy_fn : str, Path, xr.DataArray, optional</span>
<span class="sd">            RasterDataset or name in data catalog / path to paddy map.</span>
<span class="sd">        paddy_mapping_fn : str, Path, pd.DataFrame, optional</span>
<span class="sd">            Path to a mapping csv file from paddy in source name to parameter values</span>
<span class="sd">            in lulc_vars. A default mapping table for rice parameters is used if not</span>
<span class="sd">            provided.</span>
<span class="sd">        soil_fn : str, Path, xr.DataArray, optional</span>
<span class="sd">            Soil data to be used to recalculate the Brooks-Corey coefficients</span>
<span class="sd">            (`soil_brooks_corey_c` parameter), based on the provided</span>
<span class="sd">            ``wflow_thicknesslayers``, by default &quot;soilgrids&quot;, but should ideally</span>
<span class="sd">            be equal to the data used in :py:meth:`setup_soilmaps`</span>

<span class="sd">            * Required variables: &#39;bd_sl*&#39; [g/cm3], &#39;clyppt_sl*&#39; [%], &#39;sltppt_sl*&#39; [%],</span>
<span class="sd">              &#39;ph_sl*&#39; [-].</span>

<span class="sd">        wflow_thicknesslayers: list</span>
<span class="sd">            List of soil thickness per layer [mm], by default [50, 100, 50, 200, 800, ]</span>
<span class="sd">        target_conductivity: list</span>
<span class="sd">            List of target vertical conductivities [mm/day] for each layer in</span>
<span class="sd">            ``wflow_thicknesslayers``. Set value to `None` if no specific value is</span>
<span class="sd">            required, by default [None, None, 5, None, None].</span>
<span class="sd">        lulc_vars : Dict</span>
<span class="sd">            Dictionnary of landuse parameters to prepare. The names are the</span>
<span class="sd">            the columns of the mapping file and the values are the corresponding</span>
<span class="sd">            Wflow.jl variables.</span>
<span class="sd">        paddy_waterlevels : dict</span>
<span class="sd">            Dictionary with the minimum, optimal and maximum water levels for paddy</span>
<span class="sd">            fields [mm]. By default {&quot;demand_paddy_h_min&quot;: 20, &quot;demand_paddy_h_opt&quot;: 50,</span>
<span class="sd">            &quot;demand_paddy_h_max&quot;: 80}</span>
<span class="sd">        save_high_resolution_lulc : bool</span>
<span class="sd">            Save the high resolution landuse map merged with the paddies to the static</span>
<span class="sd">            folder. By default False.</span>
<span class="sd">        output_names_suffix : str, optional</span>
<span class="sd">            Suffix to be added to the output names to avoid having to rename all the</span>
<span class="sd">            columns of the mapping tables. For example if the suffix is &quot;vito&quot;, all</span>
<span class="sd">            variables in lulc_vars will be renamed to &quot;landuse_vito&quot;, &quot;Kext_vito&quot;, etc.</span>
<span class="sd">            Note that the suffix will also be used to rename the paddy parameter</span>
<span class="sd">            soil_ksat_vertical_factor but not the soil_brooks_corey_c parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing LULC parameter maps including paddies.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output_names_suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># rename lulc_vars with the suffix</span>
            <span class="n">output_names</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">v</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">output_names_suffix</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">lulc_vars</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="c1"># Add soil_ksat_vertical_factor</span>
            <span class="n">output_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;soil_ksat_vertical_factor&quot;</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;soil_ksat_vertical_factor_</span><span class="si">{</span><span class="n">output_names_suffix</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">lulc_vars</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="c1"># update self._MAPS and self._WFLOW_NAMES with user defined output names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>
        <span class="c1"># As landuse is not a wflow variable, we update the name manually in self._MAPS</span>
        <span class="k">if</span> <span class="n">output_names_suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;landuse&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;meta_landuse_</span><span class="si">{</span><span class="n">output_names_suffix</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Check if soil data is available</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;ksat_vertical&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;ksat_vertical and f are required to update the soil parameters with &quot;</span>
                <span class="s2">&quot;paddies. Please run setup_soilmaps first.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">lulc_mapping_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lulc_mapping_fn</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lulc_fn</span><span class="si">}</span><span class="s2">_mapping_default&quot;</span>
        <span class="c1"># read landuse map and mapping table</span>
        <span class="n">landuse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">lulc_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;landuse&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">df_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span>
            <span class="n">lulc_mapping_fn</span><span class="p">,</span>
            <span class="n">driver_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;index_col&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>  <span class="c1"># only used if fn_map is a file path</span>
        <span class="p">)</span>
        <span class="n">output_paddy_class</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">paddy_class</span> <span class="k">if</span> <span class="n">output_paddy_class</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">output_paddy_class</span>
        <span class="p">)</span>

        <span class="c1"># if needed, add paddies to landuse</span>
        <span class="k">if</span> <span class="n">paddy_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Read paddy map and mapping table</span>
            <span class="n">paddy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">paddy_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;paddy&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">paddy_mapping_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">paddy_mapping_fn</span> <span class="o">=</span> <span class="s2">&quot;paddy_mapping_default&quot;</span>
            <span class="n">df_paddy_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span>
                <span class="n">paddy_mapping_fn</span><span class="p">,</span>
                <span class="n">driver_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;index_col&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
            <span class="p">)</span>

            <span class="n">landuse</span><span class="p">,</span> <span class="n">df_mapping</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">add_paddy_to_landuse</span><span class="p">(</span>
                <span class="n">landuse</span><span class="p">,</span>
                <span class="n">paddy</span><span class="p">,</span>
                <span class="n">paddy_class</span><span class="p">,</span>
                <span class="n">output_paddy_class</span><span class="o">=</span><span class="n">output_paddy_class</span><span class="p">,</span>
                <span class="n">df_mapping</span><span class="o">=</span><span class="n">df_mapping</span><span class="p">,</span>
                <span class="n">df_paddy_mapping</span><span class="o">=</span><span class="n">df_paddy_mapping</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">save_high_resolution_lulc</span><span class="p">:</span>
                <span class="n">output_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;maps&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>
                <span class="n">landuse</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">to_raster</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;landuse_with_paddy.tif&quot;</span><span class="p">))</span>
                <span class="n">df_mapping</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;landuse_with_paddy_mapping.csv&quot;</span><span class="p">))</span>

        <span class="c1"># Prepare landuse parameters</span>
        <span class="n">landuse_maps</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">landuse</span><span class="p">(</span>
            <span class="n">da</span><span class="o">=</span><span class="n">landuse</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df_mapping</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">lulc_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">landuse_maps</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">landuse_maps</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
        <span class="c1"># update config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">landuse_maps</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>

        <span class="c1"># Update soil parameters if there are paddies in the domain</span>
        <span class="c1"># Get paddy pixels at model resolution</span>
        <span class="n">wflow_paddy</span> <span class="o">=</span> <span class="n">landuse_maps</span><span class="p">[</span><span class="s2">&quot;landuse&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">output_paddy_class</span>
        <span class="k">if</span> <span class="n">wflow_paddy</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;model.soil_layer__thickness&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">wflow_thicknesslayers</span>
            <span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;same thickness already present, skipping updating&quot;</span>
                    <span class="s2">&quot; `soil_brooks_corey_c` parameter&quot;</span>
                <span class="p">)</span>
                <span class="n">update_c</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Different thicknesslayers requested, updating &quot;</span>
                    <span class="s2">&quot;`soil_brooks_corey_c` parameter&quot;</span>
                <span class="p">)</span>
                <span class="n">update_c</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># Read soil data</span>
            <span class="n">soil</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">soil_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
            <span class="c1"># update soil parameters soil_brooks_corey_c and soil_ksat_vertical_factor</span>
            <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">v</span><span class="p">:</span> <span class="n">k</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data_vars</span>
            <span class="p">}</span>
            <span class="n">soil_maps</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">update_soil_with_paddy</span><span class="p">(</span>
                <span class="n">ds</span><span class="o">=</span><span class="n">soil</span><span class="p">,</span>
                <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
                <span class="n">paddy_mask</span><span class="o">=</span><span class="n">wflow_paddy</span><span class="p">,</span>
                <span class="n">soil_fn</span><span class="o">=</span><span class="n">soil_fn</span><span class="p">,</span>
                <span class="n">update_c</span><span class="o">=</span><span class="n">update_c</span><span class="p">,</span>
                <span class="n">wflow_layers</span><span class="o">=</span><span class="n">wflow_thicknesslayers</span><span class="p">,</span>
                <span class="n">target_conductivity</span><span class="o">=</span><span class="n">target_conductivity</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span>
                <span class="n">soil_maps</span><span class="p">[</span><span class="s2">&quot;soil_ksat_vertical_factor&quot;</span><span class="p">],</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;soil_ksat_vertical_factor&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;soil_ksat_vertical_factor&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;soil_brooks_corey_c&quot;</span> <span class="ow">in</span> <span class="n">soil_maps</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span>
                    <span class="n">soil_maps</span><span class="p">[</span><span class="s2">&quot;soil_brooks_corey_c&quot;</span><span class="p">],</span>
                    <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;soil_brooks_corey_c&quot;</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;soil_brooks_corey_c&quot;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.soil_layer__thickness&quot;</span><span class="p">,</span> <span class="n">wflow_thicknesslayers</span><span class="p">)</span>
            <span class="c1"># Add paddy water levels to the config</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">paddy_waterlevels</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;input.static.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="si">}</span><span class="s2">.value&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="c1"># Update the states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span>
                <span class="s2">&quot;state.variables.land_surface_water~paddy__depth&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_paddy_h&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No paddy fields found, skipping updating soil parameters&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_glaciers">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_glaciers.html#hydromt_wflow.WflowModel.setup_glaciers">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_glaciers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">glaciers_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">min_area</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;glacier_surface__area_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;glacier_fraction&quot;</span><span class="p">,</span>
            <span class="s2">&quot;glacier_ice__initial_leq-depth&quot;</span><span class="p">:</span> <span class="s2">&quot;glacier_initial_leq_depth&quot;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">geom_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;glaciers&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate maps of glacier areas, area fraction and volume fraction.</span>

<span class="sd">        The data is generated from features with ``min_area`` [km2] (default is 1 km2)</span>
<span class="sd">        from a database with glacier geometry, IDs and metadata.</span>

<span class="sd">        The required variables from glaciers_fn dataset are glacier ID &#39;simple_id&#39;.</span>
<span class="sd">        Optionally glacier area &#39;AREA&#39; [km2] can be present to filter the glaciers</span>
<span class="sd">        by size. If not present it will be computed on the fly.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **meta_glacier_area_id** map: glacier IDs [-]</span>
<span class="sd">        * **glacier_fraction** map: area fraction of glacier per cell [-]</span>
<span class="sd">        * **glacier_initial_leq_depth** map: storage (volume) of glacier per cell [mm]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        glaciers_fn :</span>
<span class="sd">            Name of data source for glaciers, see data/data_sources.yml.</span>

<span class="sd">            * Required variables: [&#39;simple_id&#39;]</span>
<span class="sd">        min_area : float, optional</span>
<span class="sd">            Minimum glacier area threshold [km2], by default 0 (all included)</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>
<span class="sd">        geom_name : str, optional</span>
<span class="sd">            Name of the geometry to be used in the model, by default &quot;glaciers&quot; for</span>
<span class="sd">            glaciers.geojson.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>
        <span class="c1"># retrieve data for basin</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing glacier maps.&quot;</span><span class="p">)</span>
        <span class="n">gdf_org</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">glaciers_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins_highres</span><span class="p">,</span>
            <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;intersects&quot;</span><span class="p">,</span>
            <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Check if there are glaciers found</span>
        <span class="k">if</span> <span class="n">gdf_org</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skipping method, as no data has been found&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># skip small size glacier</span>
        <span class="k">if</span> <span class="s2">&quot;AREA&quot;</span> <span class="ow">in</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gdf_org</span> <span class="o">=</span> <span class="n">gdf_org</span><span class="p">[</span><span class="n">gdf_org</span><span class="p">[</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_area</span><span class="p">]</span>
        <span class="c1"># get glacier maps and parameters</span>
        <span class="n">nb_glac</span> <span class="o">=</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="n">nb_glac</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;No glaciers of sufficient size found within region!&quot;</span>
                <span class="s2">&quot;Skipping glacier procedures!&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nb_glac</span><span class="si">}</span><span class="s2"> glaciers of sufficient size found within region.&quot;</span><span class="p">)</span>
        <span class="c1"># add glacier maps</span>
        <span class="n">ds_glac</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">glaciermaps</span><span class="p">(</span>
            <span class="n">gdf</span><span class="o">=</span><span class="n">gdf_org</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">id_column</span><span class="o">=</span><span class="s2">&quot;simple_id&quot;</span><span class="p">,</span>
            <span class="n">elevtn_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">],</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_glac</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_glac</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
        <span class="c1"># update config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">ds_glac</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.glacier__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;state.variables.glacier_ice__leq-depth&quot;</span><span class="p">,</span> <span class="s2">&quot;glacier_leq_depth&quot;</span><span class="p">)</span>
        <span class="c1"># update geoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_org</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">geom_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_constant_pars">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_constant_pars.html#hydromt_wflow.WflowModel.setup_constant_pars">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_constant_pars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate constant parameter maps for all active model cells.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **param_name** map: constant parameter map.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype: str</span>
<span class="sd">            data type</span>
<span class="sd">        nodata: int or float</span>
<span class="sd">            nodata value</span>
<span class="sd">        kwargs</span>
<span class="sd">            &quot;param_name: value&quot; pairs for constant grid.</span>
<span class="sd">            Param_name should be the Wflow.jl variable name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wflow_variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">wflow_var</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">wflow_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wflow_variables</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Parameter </span><span class="si">{</span><span class="n">wflow_var</span><span class="si">}</span><span class="s2"> not recognised as a Wflow variable. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Please check the name.&quot;</span>
                <span class="p">)</span>
            <span class="c1"># check if param is already in toml and will be overwritten</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="n">wflow_var</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Parameter </span><span class="si">{</span><span class="n">wflow_var</span><span class="si">}</span><span class="s2"> already in toml and will be overwritten.&quot;</span>
                <span class="p">)</span>
            <span class="c1"># remove from config</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">wflow_var</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="c1"># Add to config</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;input.static.</span><span class="si">{</span><span class="n">wflow_var</span><span class="si">}</span><span class="s2">.value&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_grid_from_raster">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_grid_from_raster.html#hydromt_wflow.WflowModel.setup_grid_from_raster">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_grid_from_raster</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">raster_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">reproject_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wflow_variables</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add data variable(s) from ``raster_fn`` to grid object.</span>

<span class="sd">        If raster is a dataset, all variables will be added unless ``variables``</span>
<span class="sd">        list is specified. The config toml can also be updated to include</span>
<span class="sd">        the new maps using ``wflow_variables``.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **raster.name** or **variables** grid: data from raster_fn</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        raster_fn: str</span>
<span class="sd">            Source name of RasterDataset in data_catalog.</span>
<span class="sd">        reproject_method: str</span>
<span class="sd">            Reprojection method from rasterio.enums.Resampling.</span>
<span class="sd">            Available methods: [&#39;nearest&#39;, &#39;bilinear&#39;, &#39;cubic&#39;, &#39;cubic_spline&#39;, \</span>
<span class="sd">&#39;lanczos&#39;, &#39;average&#39;, &#39;mode&#39;, &#39;gauss&#39;, &#39;max&#39;, &#39;min&#39;, &#39;med&#39;, &#39;q1&#39;, &#39;q3&#39;, \</span>
<span class="sd">&#39;sum&#39;, &#39;rms&#39;]</span>
<span class="sd">        variables: list, optional</span>
<span class="sd">            List of variables to add to grid from raster_fn. By default all.</span>
<span class="sd">        wflow_variables: list, optional</span>
<span class="sd">            List of corresponding wflow variables to update the config toml</span>
<span class="sd">            (e.g: [&quot;vegetation_root__depth&quot;]).</span>
<span class="sd">            Should match the variables list. variables list should be provided unless</span>
<span class="sd">            raster_fn contains a single variable (len 1).</span>
<span class="sd">        fill_method : str, optional</span>
<span class="sd">            If specified, fills nodata values using fill_nodata method.</span>
<span class="sd">            Available methods are {&#39;linear&#39;, &#39;nearest&#39;, &#39;cubic&#39;, &#39;rio_idw&#39;}.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Names of added model staticmap layers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparing grid data from raster source </span><span class="si">{</span><span class="n">raster_fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Read raster data and select variables</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">raster_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">single_var_as_array</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Fill nodata</span>
        <span class="k">if</span> <span class="n">fill_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">interpolate_na</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">fill_method</span><span class="p">)</span>
        <span class="c1"># Reprojection</span>
        <span class="n">ds_out</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">reproject_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">reproject_method</span><span class="p">)</span>
        <span class="c1"># Add to grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_out</span><span class="p">)</span>

        <span class="c1"># Update config</span>
        <span class="k">if</span> <span class="n">wflow_variables</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Updating the config for wflow_variables: </span><span class="si">{</span><span class="n">wflow_variables</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds_out</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ds_out</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot update the toml if raster_fn has more than </span><span class="se">\</span>
<span class="s2">one variable and variables list is not provided.&quot;</span>
                    <span class="p">)</span>

            <span class="c1"># Check on len</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wflow_variables</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Length of variables </span><span class="si">{</span><span class="n">variables</span><span class="si">}</span><span class="s2"> do not match wflow_variables </span><span class="se">\</span>
<span class="si">{</span><span class="n">wflow_variables</span><span class="si">}</span><span class="s2">. Cannot update the toml.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;input.static.</span><span class="si">{</span><span class="n">wflow_variables</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></div>


<div class="viewcode-block" id="WflowModel.setup_precip_forcing">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_precip_forcing.html#hydromt_wflow.WflowModel.setup_precip_forcing">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_precip_forcing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">precip_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">precip_clim_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate gridded precipitation forcing at model resolution.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **precip**: precipitation [mm]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        precip_fn : str, xarray.DataArray</span>
<span class="sd">            Precipitation RasterDataset source.</span>

<span class="sd">            * Required variable: &#39;precip&#39; [mm]</span>

<span class="sd">            * Required dimension: &#39;time&#39;  [timestamp]</span>
<span class="sd">        precip_clim_fn : str, xarray.DataArray, optional</span>
<span class="sd">            High resolution climatology precipitation RasterDataset source to correct</span>
<span class="sd">            precipitation.</span>

<span class="sd">            * Required variable: &#39;precip&#39; [mm]</span>

<span class="sd">            * Required dimension: &#39;time&#39;  [cyclic month]</span>
<span class="sd">        chunksize: int, optional</span>
<span class="sd">            Chunksize on time dimension for processing data (not for saving to disk!).</span>
<span class="sd">            If None the data chunksize is used, this can however be optimized for</span>
<span class="sd">            large/small catchments. By default None.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Additional arguments passed to the forcing function.</span>
<span class="sd">            See hydromt.workflows.forcing.precip for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.starttime&quot;</span><span class="p">)</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.endtime&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.timestepsecs&quot;</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="n">precip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">precip_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">time_tuple</span><span class="o">=</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">),</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;precip&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">precip</span> <span class="o">=</span> <span class="n">precip</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">chunksize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">precip</span> <span class="o">=</span> <span class="n">precip</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">chunksize</span><span class="p">})</span>

        <span class="n">clim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">precip_clim_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">clim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">precip_clim_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="n">precip</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">box</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;precip&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">clim</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="n">precip_out</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">processes</span><span class="o">.</span><span class="n">meteo</span><span class="o">.</span><span class="n">precip</span><span class="p">(</span>
            <span class="n">precip</span><span class="o">=</span><span class="n">precip</span><span class="p">,</span>
            <span class="n">da_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
            <span class="n">clim</span><span class="o">=</span><span class="n">clim</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">resample_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Update meta attributes (used for default output filename later)</span>
        <span class="n">precip_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;precip_fn&quot;</span><span class="p">:</span> <span class="n">precip_fn</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">precip_clim_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">precip_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;precip_clim_fn&quot;</span><span class="p">:</span> <span class="n">precip_clim_fn</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_forcing</span><span class="p">(</span><span class="n">precip_out</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;precip&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;precip&quot;</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;forcing&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_precip_from_point_timeseries">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_precip_from_point_timeseries.html#hydromt_wflow.WflowModel.setup_precip_from_point_timeseries">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_precip_from_point_timeseries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">precip_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">interp_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
        <span class="n">precip_stations_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">index_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">buffer</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e5</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate gridded precipitation from point timeseries (requires wradlib).</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **precip**: precipitation [mm]</span>

<span class="sd">        Supported interpolation methods:</span>
<span class="sd">        * uniform: Applies spatially uniform precipitation to the model. \</span>
<span class="sd">        Only works when `precip_fn` contains a single timeseries.</span>
<span class="sd">        * nearest: Nearest-neighbour interpolation, also works with a single station.</span>
<span class="sd">        * idw: Inverse-distance weighting using 1 / distance ** p.</span>
<span class="sd">        * linear: Linear interpolation using scipy.interpolate.LinearNDInterpolator, \</span>
<span class="sd">        may result in missing values when station coverage is limited.</span>
<span class="sd">        * ordinarykriging: Interpolate using Ordinary Kriging, see wradlib \</span>
<span class="sd">        documentation for a full explanation: `wradlib.ipol.OrdinaryKriging &lt;https://docs.wradlib.org/en/latest/generated/wradlib.ipol.OrdinaryKriging.html&gt;`.</span>
<span class="sd">        * externaldriftkriging: Kriging interpolation including an external drift, \</span>
<span class="sd">        see wradlib documentation for a full explanation: \</span>
<span class="sd">        `wradlib.ipol.ExternalDriftKriging &lt;https://docs.wradlib.org/en/latest/generated/wradlib.ipol.ExternalDriftKriging.html&gt;`.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        precip_fn : str, pd.DataFrame, xr.Dataset</span>
<span class="sd">            Precipitation source as DataFrame or GeoDataset. \</span>
<span class="sd">            - DataFrame: the index column should contain time and the other \</span>
<span class="sd">            columns should correspond to the name or ID values of the stations \</span>
<span class="sd">            in `precip_stations_fn`.</span>
<span class="sd">            - GeoDataset: the dataset should contain the variable &#39;precip&#39; and \</span>
<span class="sd">            the dimensions &#39;time&#39; and &#39;index&#39;.</span>

<span class="sd">            * Required variable: &#39;time&#39;, &#39;precip&#39; [mm]</span>
<span class="sd">        interp_type : str</span>
<span class="sd">            Interpolation method. Options: &quot;nearest&quot;, &quot;idw&quot;, &quot;linear&quot;, \</span>
<span class="sd">            &quot;ordinarykriging&quot;, &quot;externaldriftkriging&quot;.</span>
<span class="sd">        precip_stations_fn : str, gpd.GeoDataFrame, optional</span>
<span class="sd">            Source for the locations of the stations as points: (x, y) or (lat, lon). \</span>
<span class="sd">            Only required if precip_fn is of type DataFrame.</span>
<span class="sd">        index_col : str, optional</span>
<span class="sd">            Column in precip_stations_fn to use for station ID values, by default None.</span>
<span class="sd">        buffer: float, optional</span>
<span class="sd">            Buffer around the basins in metres to determine which</span>
<span class="sd">            stations to include. Set to 100 km (1e5 metres) by default.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments passed to the interpolation function. \</span>
<span class="sd">            Supported arguments depend on the interpolation type:</span>
<span class="sd">            - nnearest: Maximum number of neighbors for interpolation (default: 4).</span>
<span class="sd">            - p: Power parameter for IDW interpolation (default: 2).</span>
<span class="sd">            - remove_missing: Mask NaN values in the input data (default: False).</span>
<span class="sd">            - cov: Covariance model for Kriging (default: &#39;1.0 Exp(10000.)&#39;).</span>
<span class="sd">            - src_drift: External drift values at source points (stations).</span>
<span class="sd">            - trg_drift: External drift values at target points (grid).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hydromt_wflow.workflows.forcing.spatial_interpolation</span>
<span class="sd">        `wradlib.ipol.interpolate &lt;https://docs.wradlib.org/en/latest/ipol.html#wradlib.ipol.interpolate&gt;`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.starttime&quot;</span><span class="p">)</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.endtime&quot;</span><span class="p">)</span>
        <span class="n">timestep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.timestepsecs&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="c1"># Check data type of precip_fn if it is provided through the data catalog</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">precip_fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">precip_fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="p">:</span>
            <span class="n">_data_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="p">[</span><span class="n">precip_fn</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_data_type</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Read the precipitation timeseries</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">precip_fn</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_data_type</span> <span class="o">==</span> <span class="s2">&quot;GeoDataset&quot;</span><span class="p">:</span>
            <span class="n">da_precip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataset</span><span class="p">(</span>
                <span class="n">precip_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;precip&quot;</span><span class="p">],</span>
                <span class="n">time_tuple</span><span class="o">=</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">),</span>
                <span class="n">single_var_as_array</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Read timeseries</span>
            <span class="n">df_precip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span>
                <span class="n">precip_fn</span><span class="p">,</span>
                <span class="n">time_tuple</span><span class="o">=</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="c1"># Get locs</span>
            <span class="k">if</span> <span class="n">interp_type</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
                <span class="c1"># Use basin centroid as &#39;station&#39; for uniform case</span>
                <span class="n">gdf_stations</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">geometry</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">basins</span><span class="o">.</span><span class="n">unary_union</span><span class="o">.</span><span class="n">centroid</span><span class="p">],</span>
                    <span class="n">index</span><span class="o">=</span><span class="n">df_precip</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                    <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">index_col</span> <span class="o">=</span> <span class="n">df_precip</span><span class="o">.</span><span class="n">columns</span>
                <span class="n">interp_type</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span>
                <span class="k">if</span> <span class="n">df_precip</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                        Data source (</span><span class="si">{</span><span class="n">precip_fn</span><span class="si">}</span><span class="s2">) should contain</span>
<span class="s2">                        a single timeseries, not </span><span class="si">{</span><span class="n">df_precip</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;&quot;&quot;</span>
                    <span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Uniform interpolation is applied using method &#39;nearest&#39;.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">precip_stations_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Using a DataFrame as precipitation source requires that station &quot;</span>
                    <span class="s2">&quot;locations are provided separately through precip_station_fn.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Load the stations and their coordinates</span>
                <span class="n">gdf_stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
                    <span class="n">precip_stations_fn</span><span class="p">,</span>
                    <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins</span><span class="p">,</span>
                    <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
                    <span class="n">assert_gtype</span><span class="o">=</span><span class="s2">&quot;Point&quot;</span><span class="p">,</span>
                    <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># Use station ids from gdf_stations when reading the DataFrame</span>
                <span class="k">if</span> <span class="n">index_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">gdf_stations</span> <span class="o">=</span> <span class="n">gdf_stations</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">index_col</span><span class="p">)</span>

            <span class="c1"># Index is required to contruct GeoDataArray</span>
            <span class="k">if</span> <span class="n">gdf_stations</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gdf_stations</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;stations&quot;</span>

            <span class="c1"># Convert to geodataset</span>
            <span class="n">da_precip</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">GeoDataArray</span><span class="o">.</span><span class="n">from_gdf</span><span class="p">(</span>
                <span class="n">gdf</span><span class="o">=</span><span class="n">gdf_stations</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">df_precip</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;precip&quot;</span><span class="p">,</span>
                <span class="n">index_dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">gdf_stations</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
                <span class="n">keep_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">merge_index</span><span class="o">=</span><span class="s2">&quot;gdf&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Calling interpolation workflow</span>
        <span class="n">precip</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">spatial_interpolation</span><span class="p">(</span>
            <span class="n">forcing</span><span class="o">=</span><span class="n">da_precip</span><span class="p">,</span>
            <span class="n">interp_type</span><span class="o">=</span><span class="n">interp_type</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">mask_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">],</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Use precip workflow to create the forcing file</span>
        <span class="n">precip_out</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">processes</span><span class="o">.</span><span class="n">meteo</span><span class="o">.</span><span class="n">precip</span><span class="p">(</span>
            <span class="n">precip</span><span class="o">=</span><span class="n">precip</span><span class="p">,</span>
            <span class="n">da_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
            <span class="n">clim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">resample_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Update meta attributes (used for default output filename later)</span>
        <span class="n">precip_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;precip_fn&quot;</span><span class="p">:</span> <span class="n">precip_fn</span><span class="p">})</span>
        <span class="n">precip_out</span> <span class="o">=</span> <span class="n">precip_out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_forcing</span><span class="p">(</span><span class="n">precip_out</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;precip&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;precip&quot;</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;forcing&quot;</span><span class="p">)</span>

        <span class="c1"># Add to geoms</span>
        <span class="n">gdf_stations</span> <span class="o">=</span> <span class="n">da_precip</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">to_gdf</span><span class="p">()</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_stations</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;stations_precipitation&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_temp_pet_forcing">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_temp_pet_forcing.html#hydromt_wflow.WflowModel.setup_temp_pet_forcing">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_temp_pet_forcing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">temp_pet_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">pet_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;debruin&quot;</span><span class="p">,</span>
        <span class="n">press_correction</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">temp_correction</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wind_correction</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wind_altitude</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">reproj_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nearest_index&quot;</span><span class="p">,</span>
        <span class="n">fillna_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dem_forcing_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skip_pet</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate gridded temperature and reference evapotranspiration forcing.</span>

<span class="sd">        If `temp_correction` is True, the temperature will be reprojected and then</span>
<span class="sd">        downscaled to model resolution using the elevation lapse rate. For better</span>
<span class="sd">        accuracy, you can provide the elevation grid of the climate data in</span>
<span class="sd">        `dem_forcing_fn`. If not present, the upscaled elevation grid of the wflow model</span>
<span class="sd">        is used (&#39;land_elevation&#39;).</span>

<span class="sd">        To compute PET (`skip_pet` is False), several methods are available. Before</span>
<span class="sd">        computation, both the temperature and pressure can be downscaled. Wind speed</span>
<span class="sd">        should be given at 2m altitude and can be corrected if `wind_correction` is True</span>
<span class="sd">        and the wind data altitude is provided in `wind_altitude` [m].</span>
<span class="sd">        Several methods to compute pet are available: {&#39;debruin&#39;, &#39;makkink&#39;,</span>
<span class="sd">        &#39;penman-monteith_rh_simple&#39;, &#39;penman-monteith_tdew&#39;}.</span>

<span class="sd">        Depending on the methods, `temp_pet_fn` should contain temperature &#39;temp&#39; [C],</span>
<span class="sd">        pressure &#39;press_msl&#39; [hPa], incoming shortwave radiation &#39;kin&#39; [W/m2], outgoing</span>
<span class="sd">        shortwave radiation &#39;kout&#39; [W/m2], wind speed &#39;wind&#39; [m/s], relative humidity</span>
<span class="sd">        &#39;rh&#39; [%], dew point temperature &#39;temp_dew&#39; [C], wind speed either total &#39;wind&#39;</span>
<span class="sd">        or the U- &#39;wind10_u&#39; [m/s] and V- &#39;wind10_v&#39; components [m/s].</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **pet**: reference evapotranspiration [mm]</span>
<span class="sd">        * **temp**: temperature [C]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        temp_pet_fn : str, xarray.Dataset</span>
<span class="sd">            Name or path of RasterDataset source with variables to calculate temperature</span>
<span class="sd">            and reference evapotranspiration.</span>

<span class="sd">            * Required variable for temperature: &#39;temp&#39; [C]</span>

<span class="sd">            * Required variables for De Bruin reference evapotranspiration: \</span>
<span class="sd">&#39;temp&#39; [C], &#39;press_msl&#39; [hPa], &#39;kin&#39; [W/m2], &#39;kout&#39; [W/m2]</span>

<span class="sd">            * Required variables for Makkink reference evapotranspiration: \</span>
<span class="sd">&#39;temp&#39; [C], &#39;press_msl&#39; [hPa], &#39;kin&#39;[W/m2]</span>

<span class="sd">            * Required variables for daily Penman-Monteith \</span>
<span class="sd">reference evapotranspiration: \</span>
<span class="sd">either {&#39;temp&#39; [C], &#39;temp_min&#39; [C], &#39;temp_max&#39; [C], &#39;wind&#39; [m/s], &#39;rh&#39; [%], &#39;kin&#39; \</span>
<span class="sd">[W/m2]} for &#39;penman-monteith_rh_simple&#39; or {&#39;temp&#39; [C], &#39;temp_min&#39; [C], &#39;temp_max&#39; \</span>
<span class="sd">[C], &#39;temp_dew&#39; [C], &#39;wind&#39; [m/s], &#39;kin&#39; [W/m2], &#39;press_msl&#39; [hPa], &#39;wind10_u&#39; [m/s],\</span>
<span class="sd">&quot;wind10_v&quot; [m/s]} for &#39;penman-monteith_tdew&#39; (these are the variables available in ERA5)</span>
<span class="sd">        pet_method : {&#39;debruin&#39;, &#39;makkink&#39;, &#39;penman-monteith_rh_simple&#39;, \</span>
<span class="sd">&#39;penman-monteith_tdew&#39;}, optional</span>
<span class="sd">            Reference evapotranspiration method, by default &#39;debruin&#39;.</span>
<span class="sd">            If penman-monteith is used, requires the installation of the pyet package.</span>
<span class="sd">        press_correction, temp_correction : bool, optional</span>
<span class="sd">            If True pressure, temperature are corrected using elevation lapse rate,</span>
<span class="sd">            by default False.</span>
<span class="sd">        dem_forcing_fn : str, default None</span>
<span class="sd">            Elevation data source with coverage of entire meteorological forcing domain.</span>
<span class="sd">            If temp_correction is True and dem_forcing_fn is provided this is used in</span>
<span class="sd">            combination with elevation at model resolution to correct the temperature.</span>

<span class="sd">            * Required variable: &#39;elevtn&#39; [m+REF]</span>
<span class="sd">        wind_correction : bool, optional</span>
<span class="sd">            If True wind speed is corrected to wind at 2m altitude using</span>
<span class="sd">            ``wind_altitude``. By default True.</span>
<span class="sd">        wind_altitude : int, optional</span>
<span class="sd">            Altitude of wind speed [m] variable, by default 10. Only used if</span>
<span class="sd">            ``wind_correction`` is True.</span>
<span class="sd">        skip_pet : bool, optional</span>
<span class="sd">            If True calculate temp only.</span>
<span class="sd">        reproj_method : str, optional</span>
<span class="sd">            Reprojection method from rasterio.enums.Resampling. to reproject the climate</span>
<span class="sd">            data to the model resolution. By default &#39;nearest_index&#39;.</span>
<span class="sd">        fillna_method: str, optional</span>
<span class="sd">            Method to fill NaN cells within the active model domain in the</span>
<span class="sd">            temperature data e.g. &#39;nearest&#39;</span>
<span class="sd">            By default None for no interpolation.</span>
<span class="sd">        chunksize: int, optional</span>
<span class="sd">            Chunksize on time dimension for processing data (not for saving to disk!).</span>
<span class="sd">            If None the data chunksize is used, this can however be optimized for</span>
<span class="sd">            large/small catchments. By default None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.starttime&quot;</span><span class="p">)</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.endtime&quot;</span><span class="p">)</span>
        <span class="n">timestep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.timestepsecs&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_pet</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pet_method</span> <span class="o">==</span> <span class="s2">&quot;debruin&quot;</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;press_msl&quot;</span><span class="p">,</span> <span class="s2">&quot;kin&quot;</span><span class="p">,</span> <span class="s2">&quot;kout&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">pet_method</span> <span class="o">==</span> <span class="s2">&quot;makkink&quot;</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;press_msl&quot;</span><span class="p">,</span> <span class="s2">&quot;kin&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">pet_method</span> <span class="o">==</span> <span class="s2">&quot;penman-monteith_rh_simple&quot;</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;temp_min&quot;</span><span class="p">,</span> <span class="s2">&quot;temp_max&quot;</span><span class="p">,</span> <span class="s2">&quot;wind&quot;</span><span class="p">,</span> <span class="s2">&quot;rh&quot;</span><span class="p">,</span> <span class="s2">&quot;kin&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">pet_method</span> <span class="o">==</span> <span class="s2">&quot;penman-monteith_tdew&quot;</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="s2">&quot;temp_min&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;temp_max&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;wind10_u&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;wind10_v&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;temp_dew&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;kin&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;press_msl&quot;</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s2">&quot;debruin&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;makkink&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;penman-monteith_rh_simple&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;penman-monteith_tdew&quot;</span><span class="p">,</span>
                <span class="p">]</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unknown pet method </span><span class="si">{</span><span class="n">pet_method</span><span class="si">}</span><span class="s2">, select from </span><span class="si">{</span><span class="n">methods</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">temp_pet_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">time_tuple</span><span class="o">=</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">),</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">single_var_as_array</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># always return dataset</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">chunksize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">chunksize</span><span class="p">})</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="n">dem_forcing</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">dem_forcing_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dem_forcing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">dem_forcing_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">box</span><span class="p">,</span>  <span class="c1"># clip dem with forcing bbox for full coverage</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">],</span>
            <span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">dem_forcing</span> <span class="o">=</span> <span class="n">dem_forcing</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="n">temp_in</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">workflows</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">temp</span><span class="p">(</span>
            <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">],</span>
            <span class="n">dem_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
            <span class="n">dem_forcing</span><span class="o">=</span><span class="n">dem_forcing</span><span class="p">,</span>
            <span class="n">lapse_correction</span><span class="o">=</span><span class="n">temp_correction</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># resample time after pet workflow</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="s2">&quot;penman-monteith&quot;</span> <span class="ow">in</span> <span class="n">pet_method</span>
        <span class="p">):</span>  <span class="c1"># also downscaled temp_min and temp_max for Penman needed</span>
            <span class="n">temp_max_in</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">workflows</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">temp</span><span class="p">(</span>
                <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;temp_max&quot;</span><span class="p">],</span>
                <span class="n">dem_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
                <span class="n">dem_forcing</span><span class="o">=</span><span class="n">dem_forcing</span><span class="p">,</span>
                <span class="n">lapse_correction</span><span class="o">=</span><span class="n">temp_correction</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
                <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># resample time after pet workflow</span>
            <span class="p">)</span>
            <span class="n">temp_max_in</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;temp_max&quot;</span>

            <span class="n">temp_min_in</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">workflows</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">temp</span><span class="p">(</span>
                <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;temp_min&quot;</span><span class="p">],</span>
                <span class="n">dem_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
                <span class="n">dem_forcing</span><span class="o">=</span><span class="n">dem_forcing</span><span class="p">,</span>
                <span class="n">lapse_correction</span><span class="o">=</span><span class="n">temp_correction</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
                <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># resample time after pet workflow</span>
            <span class="p">)</span>
            <span class="n">temp_min_in</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;temp_min&quot;</span>

            <span class="n">temp_in</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">temp_in</span><span class="p">,</span> <span class="n">temp_max_in</span><span class="p">,</span> <span class="n">temp_min_in</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_pet</span><span class="p">:</span>
            <span class="n">pet_out</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">workflows</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">pet</span><span class="p">(</span>
                <span class="n">ds</span><span class="p">[</span><span class="n">variables</span><span class="p">[</span><span class="mi">1</span><span class="p">:]],</span>
                <span class="n">temp</span><span class="o">=</span><span class="n">temp_in</span><span class="p">,</span>
                <span class="n">dem_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
                <span class="n">method</span><span class="o">=</span><span class="n">pet_method</span><span class="p">,</span>
                <span class="n">press_correction</span><span class="o">=</span><span class="n">press_correction</span><span class="p">,</span>
                <span class="n">wind_correction</span><span class="o">=</span><span class="n">wind_correction</span><span class="p">,</span>
                <span class="n">wind_altitude</span><span class="o">=</span><span class="n">wind_altitude</span><span class="p">,</span>
                <span class="n">reproj_method</span><span class="o">=</span><span class="n">reproj_method</span><span class="p">,</span>
                <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                <span class="n">resample_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Update meta attributes with setup opt</span>
            <span class="n">opt_attr</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;pet_fn&quot;</span><span class="p">:</span> <span class="n">temp_pet_fn</span><span class="p">,</span>
                <span class="s2">&quot;pet_method&quot;</span><span class="p">:</span> <span class="n">pet_method</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">pet_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">opt_attr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_forcing</span><span class="p">(</span><span class="n">pet_out</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;pet&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;forcing&quot;</span><span class="p">)</span>

        <span class="c1"># make sure only temp is written to netcdf</span>
        <span class="k">if</span> <span class="s2">&quot;penman-monteith&quot;</span> <span class="ow">in</span> <span class="n">pet_method</span><span class="p">:</span>
            <span class="n">temp_in</span> <span class="o">=</span> <span class="n">temp_in</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">]</span>
        <span class="c1"># resample temp after pet workflow</span>
        <span class="n">temp_out</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">workflows</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">resample_time</span><span class="p">(</span>
            <span class="n">temp_in</span><span class="p">,</span>
            <span class="n">freq</span><span class="p">,</span>
            <span class="n">upsampling</span><span class="o">=</span><span class="s2">&quot;bfill&quot;</span><span class="p">,</span>  <span class="c1"># we assume right labeled original data</span>
            <span class="n">downsampling</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span>
            <span class="n">closed</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span>
            <span class="n">conserve_mass</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Update meta attributes with setup opt (used for default naming later)</span>
        <span class="n">opt_attr</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;temp_fn&quot;</span><span class="p">:</span> <span class="n">temp_pet_fn</span><span class="p">,</span>
            <span class="s2">&quot;temp_correction&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">temp_correction</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="n">temp_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">opt_attr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fillna_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">temp_out</span> <span class="o">=</span> <span class="n">temp_out</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">interpolate_na</span><span class="p">(</span>
                <span class="n">dim</span><span class="o">=</span><span class="n">temp_out</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">x_dim</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">fillna_method</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_forcing</span><span class="p">(</span><span class="n">temp_out</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;forcing&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_pet_forcing">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_pet_forcing.html#hydromt_wflow.WflowModel.setup_pet_forcing">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_pet_forcing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pet_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare PET forcing from existig PET data.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **pet**: reference evapotranspiration [mm]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pet_fn: str, xr.DataArray</span>
<span class="sd">            RasterDataset source or data for PET to be resampled.</span>

<span class="sd">            * Required variable: &#39;pet&#39; [mm]</span>

<span class="sd">        chunksize: int, optional</span>
<span class="sd">            Chunksize on time dimension for processing data (not for saving to disk!).</span>
<span class="sd">            If None the data chunksize is used, this can however be optimized for</span>
<span class="sd">            large/small catchments. By default None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing potential evapotranspiration forcing maps.&quot;</span><span class="p">)</span>

        <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.starttime&quot;</span><span class="p">)</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.endtime&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.timestepsecs&quot;</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>

        <span class="n">pet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">pet_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">],</span>
            <span class="n">time_tuple</span><span class="o">=</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">pet</span> <span class="o">=</span> <span class="n">pet</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="n">pet_out</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">pet</span><span class="p">(</span>
            <span class="n">pet</span><span class="o">=</span><span class="n">pet</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">mask_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">],</span>
            <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Update meta attributes (used for default output filename later)</span>
        <span class="n">pet_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;pet_fn&quot;</span><span class="p">:</span> <span class="n">pet_fn</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_forcing</span><span class="p">(</span><span class="n">pet_out</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;pet&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;forcing&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_rootzoneclim">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_rootzoneclim.html#hydromt_wflow.WflowModel.setup_rootzoneclim">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_rootzoneclim</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">run_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">forcing_obs_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">forcing_cc_hist_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">forcing_cc_fut_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">return_period</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
        <span class="n">Imax</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">start_hydro_year</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Sep&quot;</span><span class="p">,</span>
        <span class="n">start_field_capacity</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Apr&quot;</span><span class="p">,</span>
        <span class="n">LAI</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">rootzone_storage</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">correct_cc_deficit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">time_tuple</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">time_tuple_fut</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">missing_days_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">330</span><span class="p">,</span>
        <span class="n">output_name_rootingdepth</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;vegetation_root_depth_obs_20&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the vegetation_root_depth.</span>

<span class="sd">        Done by estimating the catchment-scale root-zone storage capacity from observed</span>
<span class="sd">        hydroclimatic data (and optionally also for climate change historical and</span>
<span class="sd">        future periods).</span>

<span class="sd">        This presents an alternative approach to determine the vegetation_root_depth</span>
<span class="sd">        based on hydroclimatic data instead of through a look-up table relating</span>
<span class="sd">        land use to rooting depth (as usually done for the wflow_sbm model).</span>
<span class="sd">        The method is based on the estimation of maximum annual storage deficits</span>
<span class="sd">        based on precipitation and estimated actual evaporation time series,</span>
<span class="sd">        which in turn are estimated from observed streamflow data and</span>
<span class="sd">        long-term precipitation and potential evap. data, as explained in</span>
<span class="sd">        Bouaziz et al. (2022).</span>

<span class="sd">        The main assumption is that vegetation adapts its rootzone storage capacity</span>
<span class="sd">        to overcome dry spells with a certain return period (typically 20 years for</span>
<span class="sd">        forest ecosystems). In response to a changing climtate,</span>
<span class="sd">        it is likely that vegetation also adapts its rootzone storage capacity,</span>
<span class="sd">        thereby changing model parameters for future conditions.</span>
<span class="sd">        This method also allows to estimate the change in rootzone storage capacity</span>
<span class="sd">        in response to a changing climate.</span>

<span class="sd">        As the method requires precipitation and potential evaporation timeseries,</span>
<span class="sd">        it may be useful to run this method as an update step in the setting-up of</span>
<span class="sd">        the hydrological model, once the forcing files have already been derived.</span>
<span class="sd">        In addition the setup_soilmaps method is also required to calculate</span>
<span class="sd">        the vegetation_root_depth (rootzone_storage / (theta_s-theta_r)).</span>
<span class="sd">        The setup_laimaps method is also required if LAI is set to True</span>
<span class="sd">        (interception capacity estimated from LAI maps, instead of providing</span>
<span class="sd">        a default maximum interception capacity).</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Bouaziz, L. J. E., Aalbers, E. E., Weerts, A. H., Hegnauer, M., Buiteveld,</span>
<span class="sd">        H., Lammersen, R., Stam, J., Sprokkereef, E., Savenije, H. H. G. and</span>
<span class="sd">        Hrachowitz, M. (2022). Ecosystem adaptation to climate change: the</span>
<span class="sd">        sensitivity of hydrological predictions to time-dynamic model parameters,</span>
<span class="sd">        Hydrology and Earth System Sciences, 26(5), 1295-1318. DOI:</span>
<span class="sd">        10.5194/hess-26-1295-2022.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **vegetation_root_depth_{forcing}_{RP}** map: rooting depth [mm of the soil \</span>
<span class="sd">column] estimated from hydroclimatic data {forcing: obs, cc_hist or cc_fut} for \</span>
<span class="sd">different return periods RP. The translation to vegetation_root_depth is done by \</span>
<span class="sd">dividing the rootzone_storage by (theta_s - theta_r).</span>
<span class="sd">        * **meta_rootzone_storage_{forcing}_{RP}** geom: polygons of rootzone \</span>
<span class="sd">storage capacity [mm of water] for each catchment estimated before filling \</span>
<span class="sd">the missing with data from downstream catchments.</span>
<span class="sd">        * **meta_rootzone_storage_{forcing}_{RP}** map: rootzone storage capacity \</span>
<span class="sd">[mm of water] estimated from hydroclimatic data {forcing: obs, cc_hist or cc_fut} for \</span>
<span class="sd">different return periods RP. Only if rootzone_storage is set to True!</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_fn : str, Path, xr.Dataset</span>
<span class="sd">            Geodataset with streamflow timeseries (m3/s) per x,y location.</span>
<span class="sd">            The geodataset expects the coordinate names &quot;index&quot; (for each station id)</span>
<span class="sd">            and the variable name &quot;discharge&quot;.</span>
<span class="sd">        forcing_obs_fn : str, Path, xr.Dataset</span>
<span class="sd">            Gridded timeseries with the observed forcing [mm/timestep].</span>
<span class="sd">            Expects to have variables &quot;precip&quot; and &quot;pet&quot;.</span>
<span class="sd">        forcing_cc_hist_fn : str, Path, xr.Dataset, optional</span>
<span class="sd">            Gridded timeseries with the simulated historical forcing [mm/timestep],</span>
<span class="sd">            based on a climate model. Expects to have variables &quot;precip&quot; and &quot;pet&quot;.</span>
<span class="sd">            The default is None.</span>
<span class="sd">        forcing_cc_fut_fn : str, optional</span>
<span class="sd">            Gridded timeseries with the simulated climate forcing [mm/timestep],</span>
<span class="sd">            based on a climate model. Expects to have variables &quot;precip&quot; and &quot;pet&quot;.</span>
<span class="sd">            The default is None.</span>
<span class="sd">        chunksize : int, optional</span>
<span class="sd">            Chunksize on time dimension for processing data (not for saving to</span>
<span class="sd">            disk!). The default is 100.</span>
<span class="sd">        return_period : list, optional</span>
<span class="sd">            List with one or more values indicating the return period(s) (in</span>
<span class="sd">            years) for which the rootzone storage depth should be calculated. The</span>
<span class="sd">            default is [2,3,5,10,15,20,25,50,60,100] years.</span>
<span class="sd">        Imax : float, optional</span>
<span class="sd">            The maximum interception storage capacity [mm]. The default is 2.0 mm.</span>
<span class="sd">        start_hydro_year : str, optional</span>
<span class="sd">            The start month (abbreviated to the first three letters of the month,</span>
<span class="sd">            starting with a capital letter) of the hydrological year. The</span>
<span class="sd">            default is &#39;Sep&#39;.</span>
<span class="sd">        start_field_capacity : str, optional</span>
<span class="sd">            The end of the wet season / commencement of dry season. This is the</span>
<span class="sd">            moment when the soil is at field capacity, i.e. there is no storage</span>
<span class="sd">            deficit yet. The default is &#39;Apr&#39;.</span>
<span class="sd">        LAI : bool, optional</span>
<span class="sd">            Determine whether the leaf area index will be used to</span>
<span class="sd">            determine Imax. The default is False.</span>
<span class="sd">            If set to True, requires to have run setup_laimaps.</span>
<span class="sd">        rootzone_storage : bool, optional</span>
<span class="sd">            Determines whether the rootzone storage maps</span>
<span class="sd">            should be stored in the grid or not. The default is False.</span>
<span class="sd">        correct_cc_deficit : bool, optional</span>
<span class="sd">            Determines whether a bias-correction of the future deficit should be</span>
<span class="sd">            applied using the cc_hist deficit. Only works if the time periods of</span>
<span class="sd">            cc_hist and cc_fut are the same. If the climate change scenario and</span>
<span class="sd">            hist period are bias-corrected, this should probably set to False.</span>
<span class="sd">            The default is False.</span>
<span class="sd">        time_tuple: tuple, optional</span>
<span class="sd">            Select which time period to read from all the forcing files.</span>
<span class="sd">            There should be some overlap between the time period available in the</span>
<span class="sd">            forcing files for the historical period and in the observed streamflow data.</span>
<span class="sd">        missing_days_threshold: int, optional</span>
<span class="sd">            Minimum number of days within a year for that year to be counted in</span>
<span class="sd">            the long-term Budyko analysis.</span>
<span class="sd">        output_name_rootingdepth: str, optional</span>
<span class="sd">            Update the wflow_sbm model config of the vegetation_root_depth variable with</span>
<span class="sd">            the estimated vegetation_root_depth.</span>
<span class="sd">            The default is vegetation_root_depth_obs_20,</span>
<span class="sd">            which requires to have RP 20 in the list provided for \</span>
<span class="sd">the return_period argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing climate based root zone storage parameter maps.&quot;</span><span class="p">)</span>
        <span class="c1"># Open the data sets</span>
        <span class="n">ds_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">forcing_obs_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">,</span> <span class="s2">&quot;precip&quot;</span><span class="p">],</span>
            <span class="n">time_tuple</span><span class="o">=</span><span class="n">time_tuple</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ds_cc_hist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">forcing_cc_hist_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ds_cc_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">forcing_cc_hist_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">,</span> <span class="s2">&quot;precip&quot;</span><span class="p">],</span>
                <span class="n">time_tuple</span><span class="o">=</span><span class="n">time_tuple</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">ds_cc_fut</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">forcing_cc_fut_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ds_cc_fut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">forcing_cc_fut_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">,</span> <span class="s2">&quot;precip&quot;</span><span class="p">],</span>
                <span class="n">time_tuple</span><span class="o">=</span><span class="n">time_tuple_fut</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># observed streamflow data</span>
        <span class="n">dsrun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataset</span><span class="p">(</span>
            <span class="n">run_fn</span><span class="p">,</span> <span class="n">single_var_as_array</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">time_tuple</span><span class="o">=</span><span class="n">time_tuple</span>
        <span class="p">)</span>

        <span class="c1"># make sure dsrun overlaps with ds_obs, otherwise give error</span>
        <span class="k">if</span> <span class="n">dsrun</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ds_obs</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">dsrun</span> <span class="o">=</span> <span class="n">dsrun</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">ds_obs</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dsrun</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ds_obs</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">dsrun</span> <span class="o">=</span> <span class="n">dsrun</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">ds_obs</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dsrun</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;No overlapping period between the meteo and observed streamflow data&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check if setup_soilmaps and setup_laimaps were run when:</span>
        <span class="c1"># if LAI == True and rooting_depth == True</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">LAI</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;LAI variable not found in grid. </span><span class="se">\</span>
<span class="s2">Set LAI to False or run setup_laimaps first&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;theta_r&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;theta_s&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span>
        <span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;theta_s or theta_r variables not found in grid. </span><span class="se">\</span>
<span class="s2">Run setup_soilmaps first&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Run the rootzone clim workflow</span>
        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data_vars</span>
        <span class="p">}</span>
        <span class="n">dsout</span><span class="p">,</span> <span class="n">gdf</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">rootzoneclim</span><span class="p">(</span>
            <span class="n">dsrun</span><span class="o">=</span><span class="n">dsrun</span><span class="p">,</span>
            <span class="n">ds_obs</span><span class="o">=</span><span class="n">ds_obs</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span>
            <span class="n">ds_cc_hist</span><span class="o">=</span><span class="n">ds_cc_hist</span><span class="p">,</span>
            <span class="n">ds_cc_fut</span><span class="o">=</span><span class="n">ds_cc_fut</span><span class="p">,</span>
            <span class="n">return_period</span><span class="o">=</span><span class="n">return_period</span><span class="p">,</span>
            <span class="n">Imax</span><span class="o">=</span><span class="n">Imax</span><span class="p">,</span>
            <span class="n">start_hydro_year</span><span class="o">=</span><span class="n">start_hydro_year</span><span class="p">,</span>
            <span class="n">start_field_capacity</span><span class="o">=</span><span class="n">start_field_capacity</span><span class="p">,</span>
            <span class="n">LAI</span><span class="o">=</span><span class="n">LAI</span><span class="p">,</span>
            <span class="n">rootzone_storage</span><span class="o">=</span><span class="n">rootzone_storage</span><span class="p">,</span>
            <span class="n">correct_cc_deficit</span><span class="o">=</span><span class="n">correct_cc_deficit</span><span class="p">,</span>
            <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
            <span class="n">missing_days_threshold</span><span class="o">=</span><span class="n">missing_days_threshold</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># set nodata value outside basin</span>
        <span class="n">dsout</span> <span class="o">=</span> <span class="n">dsout</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">999</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">dsout</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="n">dsout</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">set_nodata</span><span class="p">(</span><span class="o">-</span><span class="mi">999</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">dsout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;rootzone_storage&quot;</span><span class="p">)</span>

        <span class="c1"># update config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.static.vegetation_root__depth&quot;</span><span class="p">,</span> <span class="n">output_name_rootingdepth</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_1dmodel_connection">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_1dmodel_connection.html#hydromt_wflow.WflowModel.setup_1dmodel_connection">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_1dmodel_connection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">river1d_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">connection_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;subbasin_area&quot;</span><span class="p">,</span>
        <span class="n">area_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">30.0</span><span class="p">,</span>
        <span class="n">add_tributaries</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">include_river_boundaries</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mapname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;1dmodel&quot;</span><span class="p">,</span>
        <span class="n">update_toml</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">toml_output</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;netcdf_scalar&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Connect wflow to a 1D model by deriving linked subcatch (and tributaries).</span>

<span class="sd">        There are two methods to connect models:</span>

<span class="sd">        - `subbasin_area`:</span>
<span class="sd">            creates subcatchments linked to the 1d river based</span>
<span class="sd">            on an area threshold (area_max) for the subbasin size. With this method,</span>
<span class="sd">            if a tributary is larger than the `area_max`, it will be connected to</span>
<span class="sd">            the 1d river directly.</span>
<span class="sd">        - `nodes`:</span>
<span class="sd">            subcatchments are derived based on the 1driver nodes (used as</span>
<span class="sd">            gauges locations). With this method, large tributaries can also be derived</span>
<span class="sd">            separately using the `add_tributaries` option and adding a `area_max`</span>
<span class="sd">            threshold for the tributaries.</span>

<span class="sd">        If `add_tributary` option is on, you can decide to include or exclude the</span>
<span class="sd">        upstream boundary of the 1d river as an additional tributary using the</span>
<span class="sd">        `include_river_boundaries` option.</span>

<span class="sd">        River edges or river nodes are snapped to the closest downstream wflow river</span>
<span class="sd">        cell using the :py:meth:`hydromt.flw.gauge_map` method.</span>

<span class="sd">        Optionally, the toml file can also be updated to save lateral.river.inwater to</span>
<span class="sd">        save all river inflows for the subcatchments and lateral.river.q_av for the</span>
<span class="sd">        tributaries using :py:meth:`hydromt_wflow.wflow.setup_config_output_timeseries`.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **subcatchment_{mapname}** map/geom:  connection subbasins between</span>
<span class="sd">          wflow and the 1D model.</span>
<span class="sd">        * **subcatchment_river_{mapname}** map/geom:  connection subbasins between</span>
<span class="sd">          wflow and the 1D model for river cells only.</span>
<span class="sd">        * **gauges_{mapname}** map/geom, optional: outlets of the tributaries</span>
<span class="sd">          flowing into the 1D model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        river1d_fn : str, Path, gpd.GeoDataFrame</span>
<span class="sd">            GeodataFrame with the 1D model river network and nodes where to derive</span>
<span class="sd">            subbasins for connection_method **nodes**.</span>
<span class="sd">        connection_method : str, default subbasin_area</span>
<span class="sd">            Method to connect wflow to the 1D model. Available methods are {</span>
<span class="sd">                &#39;subbasin_area&#39;, &#39;nodes&#39;}.</span>
<span class="sd">        area_max : float, default 10.0</span>
<span class="sd">            Maximum area [km2] of the subbasins to connect to the 1D model in km2 with</span>
<span class="sd">            connection_method **subbasin_area** or **nodes** with add_tributaries</span>
<span class="sd">            set to True.</span>
<span class="sd">        add_tributaries : bool, default True</span>
<span class="sd">            If True, derive tributaries for the subbasins larger than area_max. Always</span>
<span class="sd">            True for **subbasin_area** method.</span>
<span class="sd">        include_river_boundaries : bool, default True</span>
<span class="sd">            If True, include the upstream boundary(ies) of the 1d river as an</span>
<span class="sd">            additional tributary(ies).</span>
<span class="sd">        mapname : str, default 1dmodel</span>
<span class="sd">            Name of the map to save the subcatchments and tributaries in the wflow model</span>
<span class="sd">            staticmaps and geoms (subcatchment_{mapname}).</span>
<span class="sd">        update_toml : bool, default True</span>
<span class="sd">            If True, updates the wflow configuration file to save the required outputs</span>
<span class="sd">            for the 1D model.</span>
<span class="sd">        toml_output : str, optional</span>
<span class="sd">            One of [&#39;csv&#39;, &#39;netcdf_scalar&#39;, None] to update [output.csv] or</span>
<span class="sd">            [output.netcdf_scalar] section of wflow toml file or do nothing. By</span>
<span class="sd">            default, &#39;netcdf_scalar&#39;.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments passed to the snapping method</span>
<span class="sd">            hydromt.flw.gauge_map. See its documentation for more information.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hydromt.flw.gauge_map</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check connection method values</span>
        <span class="k">if</span> <span class="n">connection_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;subbasin_area&quot;</span><span class="p">,</span> <span class="s2">&quot;nodes&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown connection method </span><span class="si">{</span><span class="n">connection_method</span><span class="si">}</span><span class="s2">,&quot;</span>
                <span class="s2">&quot;select from [&#39;subbasin_area&#39;, &#39;nodes&#39;]&quot;</span>
            <span class="p">)</span>
        <span class="c1"># read 1d model river network</span>
        <span class="n">gdf_riv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">river1d_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># derive subcatchments and tributaries</span>
        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">}</span>
        <span class="n">ds_out</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">wflow_1dmodel_connection</span><span class="p">(</span>
            <span class="n">gdf_riv</span><span class="p">,</span>
            <span class="n">ds_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">connection_method</span><span class="o">=</span><span class="n">connection_method</span><span class="p">,</span>
            <span class="n">area_max</span><span class="o">=</span><span class="n">area_max</span><span class="p">,</span>
            <span class="n">add_tributaries</span><span class="o">=</span><span class="n">add_tributaries</span><span class="p">,</span>
            <span class="n">include_river_boundaries</span><span class="o">=</span><span class="n">include_river_boundaries</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Derive tributary gauge map</span>
        <span class="k">if</span> <span class="s2">&quot;gauges&quot;</span> <span class="ow">in</span> <span class="n">ds_out</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;gauges&quot;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;gauges_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Derive the gauges staticgeoms</span>
            <span class="n">gdf_tributary</span> <span class="o">=</span> <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;gauges&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">vectorize</span><span class="p">()</span>
            <span class="n">gdf_tributary</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_tributary</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>
            <span class="n">gdf_tributary</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_tributary</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;gauges&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_tributary</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;gauges_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Add a check that all gauges are on the river</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">gdf_tributary</span><span class="p">)</span>
                <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">nodata</span>
            <span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">river_upa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;river_upa&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
                <span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Not all tributary gauges are on the river network and river &quot;</span>
                    <span class="s2">&quot;discharge cannot be saved. You should use a higher threshold &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for the subbasin area than </span><span class="si">{</span><span class="n">area_max</span><span class="si">}</span><span class="s2"> to match better the &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;wflow river in your model </span><span class="si">{</span><span class="n">river_upa</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="n">all_gauges_on_river</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_gauges_on_river</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Update toml</span>
            <span class="k">if</span> <span class="n">update_toml</span> <span class="ow">and</span> <span class="n">all_gauges_on_river</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setup_config_output_timeseries</span><span class="p">(</span>
                    <span class="n">mapname</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;gauges_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">toml_output</span><span class="o">=</span><span class="n">toml_output</span><span class="p">,</span>
                    <span class="n">header</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">],</span>
                    <span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;river_water__volume_flow_rate&quot;</span><span class="p">],</span>
                    <span class="n">reducer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># Derive subcatchment map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch&quot;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;subcatchment_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">gdf_subcatch</span> <span class="o">=</span> <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">vectorize</span><span class="p">()</span>
        <span class="n">gdf_subcatch</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_subcatch</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_subcatch</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;subcatchment_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Subcatchment map for river cells only (to be able to save river outputs</span>
        <span class="c1"># in wflow)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch_riv&quot;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;subcatchment_riv_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">gdf_subcatch_riv</span> <span class="o">=</span> <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch_riv&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">vectorize</span><span class="p">()</span>
        <span class="n">gdf_subcatch_riv</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_subcatch_riv</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_subcatch_riv</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;subcatchment_riv_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Update toml</span>
        <span class="k">if</span> <span class="n">update_toml</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setup_config_output_timeseries</span><span class="p">(</span>
                <span class="n">mapname</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;subcatchment_river_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">toml_output</span><span class="o">=</span><span class="n">toml_output</span><span class="p">,</span>
                <span class="n">header</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Qlat&quot;</span><span class="p">],</span>
                <span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;river_water_inflow~lateral__volume_flow_rate&quot;</span><span class="p">],</span>
                <span class="n">reducer</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sum&quot;</span><span class="p">],</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_allocation_areas">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_allocation_areas.html#hydromt_wflow.WflowModel.setup_allocation_areas">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_allocation_areas</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">waterareas_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">priority_basins</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">minimum_area</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">50.0</span><span class="p">,</span>
        <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;demand_allocation_area_id&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create water demand allocation areas.</span>

<span class="sd">        The areas are based on the wflow model basins (at model resolution), the</span>
<span class="sd">        wflow model rivers and water areas or regions for allocation.</span>

<span class="sd">        Water regions are generally defined by sub-river-basins within a Country. In</span>
<span class="sd">        order to mimic reality, it is advisable to avoid cross-Country-border</span>
<span class="sd">        abstractions. Whenever information is available, it is strongly recommended to</span>
<span class="sd">        align the water regions with the actual areas managed by water management</span>
<span class="sd">        authorities, such as regional water boards.</span>

<span class="sd">        The allocation area will be an intersection of the wflow model basins and the</span>
<span class="sd">        water areas. For areas that do not contain river cells after intersection with</span>
<span class="sd">        the water areas, the priority_basins flag can be used to decide if these basins</span>
<span class="sd">        should be merged with the closest downstream basin or with any large enough</span>
<span class="sd">        basin in the same water area.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        waterareas_fn : str | gpd.GeoDataFrame</span>
<span class="sd">            Administrative boundaries GeoDataFrame data, this could be</span>
<span class="sd">            e.g. water management areas by water boards or the administrative</span>
<span class="sd">            boundaries of countries.</span>
<span class="sd">        priority_basins : bool, optional</span>
<span class="sd">            If True, merge the basins with the closest downstream basin, else merge</span>
<span class="sd">            with any large enough basin in the same water area, by default True.</span>
<span class="sd">        minimum_area : float</span>
<span class="sd">            Minimum area of the subbasins to keep in km2. Default is 50 km2.</span>
<span class="sd">        output_name : str, optional</span>
<span class="sd">            Name of the allocation areas map to be saved in the wflow model staticmaps</span>
<span class="sd">            and staticgeoms. Default is &#39;demand_allocation_area_id&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing water demand allocation map.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="s2">&quot;land_water_allocation_area__count&quot;</span><span class="p">:</span> <span class="n">output_name</span><span class="p">})</span>
        <span class="c1"># Read the data</span>
        <span class="n">waterareas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">waterareas_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Create the allocation grid</span>
        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">}</span>
        <span class="n">da_alloc</span><span class="p">,</span> <span class="n">gdf_alloc</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">allocation_areas</span><span class="p">(</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">waterareas</span><span class="o">=</span><span class="n">waterareas</span><span class="p">,</span>
            <span class="n">basins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins</span><span class="p">,</span>
            <span class="n">priority_basins</span><span class="o">=</span><span class="n">priority_basins</span><span class="p">,</span>
            <span class="n">minimum_area</span><span class="o">=</span><span class="n">minimum_area</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_alloc</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">output_name</span><span class="p">)</span>
        <span class="c1"># Update the config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.static.land_water_allocation_area__count&quot;</span><span class="p">,</span> <span class="n">output_name</span><span class="p">)</span>
        <span class="c1"># Add alloc to geoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_alloc</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">output_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_allocation_surfacewaterfrac">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_allocation_surfacewaterfrac.html#hydromt_wflow.WflowModel.setup_allocation_surfacewaterfrac">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_allocation_surfacewaterfrac</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">gwfrac_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">waterareas_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">gwbodies_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ncfrac_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">interpolate_nodata</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">mask_and_scale_gwfrac</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;demand_surface_water_ratio&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the fraction of water allocated from surface water.</span>

<span class="sd">        This fraction entails the division of the water demand between surface water,</span>
<span class="sd">        ground water (aquifers) and non conventional sources (e.g. desalination plants).</span>

<span class="sd">        The surface water fraction is based on the raw groundwater fraction, if</span>
<span class="sd">        groundwater bodies are present (these are absent in e.g. mountainous regions),</span>
<span class="sd">        a fraction of water consumed that is obtained by non-conventional means and the</span>
<span class="sd">        water source areas.</span>

<span class="sd">        Non-conventional water could e.g. be water acquired by desalination of ocean or</span>
<span class="sd">        other brackish water.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **demand_surface_water_ratio**: fraction of water allocated from surface water</span>
<span class="sd">          [0-1]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gwfrac_fn : str | xr.DataArray</span>
<span class="sd">            The raw groundwater fraction per grid cell. The values of these cells need</span>
<span class="sd">            to be between 0 and 1.</span>
<span class="sd">        waterareas_fn : str| xr.DataArray</span>
<span class="sd">            The areas over which the water has to be distributed. This may either be</span>
<span class="sd">            a global (or more local map). If not provided, the source areas created by</span>
<span class="sd">            the `setup_allocation_areas` will be used.</span>
<span class="sd">        gwbodies_fn : str | xr.DataArray | None</span>
<span class="sd">            The presence of groundwater bodies per grid cell. The values are ought to</span>
<span class="sd">            be binary (either 0 or 1). If they are not provided, we assume groundwater</span>
<span class="sd">            bodies are present where gwfrac is more than 0.</span>
<span class="sd">        ncfrac_fn : str | xr.DataArray | None</span>
<span class="sd">            The non-conventional fraction. Same types of values apply as for</span>
<span class="sd">            `gwfrac_fn`. If not provided, we assume no non-conventional sources are</span>
<span class="sd">            used.</span>
<span class="sd">        interpolate_nodata : bool, optional</span>
<span class="sd">            If True, nodata values in the resulting demand_surface_water_ratio map will</span>
<span class="sd">            be linearly</span>
<span class="sd">            interpolated. Else a default value of 1 will be used for nodata values</span>
<span class="sd">            (default).</span>
<span class="sd">        mask_and_scale_gwfrac : bool, optional</span>
<span class="sd">            If True, gwfrac will be masked for areas with no groundwater bodies. To keep</span>
<span class="sd">            the average gwfrac used over waterareas similar after the masking, gwfrac</span>
<span class="sd">            for areas with groundwater bodies can increase. If False, gwfrac will be</span>
<span class="sd">            used as is. By default True.</span>
<span class="sd">        output_name : str, optional</span>
<span class="sd">            Name of the fraction of surface water used map to be saved in the wflow</span>
<span class="sd">            model staticmaps file. Default is &#39;demand_surface_water_ratio&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing surface water fraction map.&quot;</span><span class="p">)</span>
        <span class="c1"># Load the data</span>
        <span class="n">gwfrac_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">gwfrac_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">gwbodies_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gwbodies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">gwbodies_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gwbodies</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">ncfrac_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ncfrac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">ncfrac_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ncfrac</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># check whether to use the models own allocation areas</span>
        <span class="k">if</span> <span class="n">waterareas_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using wflow model allocation areas.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;allocation_areas&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;No allocation areas found. Run setup_allocation_areas first &quot;</span>
                    <span class="s2">&quot;or provide a waterareas_fn.&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span>
            <span class="n">waterareas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;allocation_areas&quot;</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">waterareas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">waterareas_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Call the workflow</span>
        <span class="n">w_frac</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">surfacewaterfrac_used</span><span class="p">(</span>
            <span class="n">gwfrac_raw</span><span class="o">=</span><span class="n">gwfrac_raw</span><span class="p">,</span>
            <span class="n">da_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
            <span class="n">waterareas</span><span class="o">=</span><span class="n">waterareas</span><span class="p">,</span>
            <span class="n">gwbodies</span><span class="o">=</span><span class="n">gwbodies</span><span class="p">,</span>
            <span class="n">ncfrac</span><span class="o">=</span><span class="n">ncfrac</span><span class="p">,</span>
            <span class="n">interpolate</span><span class="o">=</span><span class="n">interpolate_nodata</span><span class="p">,</span>
            <span class="n">mask_and_scale_gwfrac</span><span class="o">=</span><span class="n">mask_and_scale_gwfrac</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Update the settings toml</span>
        <span class="n">wflow_var</span> <span class="o">=</span> <span class="s2">&quot;land_surface_water__withdrawal_fraction&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="n">wflow_var</span><span class="p">:</span> <span class="n">output_name</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;input.static.</span><span class="si">{</span><span class="n">wflow_var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">output_name</span><span class="p">)</span>

        <span class="c1"># Set the dataarray to the wflow grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">w_frac</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">output_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_domestic_demand">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_domestic_demand.html#hydromt_wflow.WflowModel.setup_domestic_demand">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_domestic_demand</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">domestic_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">population_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">domestic_fn_original_res</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;land~domestic__gross_water_demand_volume_flux&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_domestic_gross&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land~domestic__net_water_demand_volume_flux&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_domestic_net&quot;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare domestic water demand maps from a raster dataset.</span>

<span class="sd">        Both gross and netto domestic demand should be provided in `domestic_fn`. They</span>
<span class="sd">        can either be cyclic or non-cyclic.</span>

<span class="sd">        To improve accuracy, the domestic demand can be downsampled based on a provided</span>
<span class="sd">        population dataset. If the data you are using was already downscaled using a</span>
<span class="sd">        different source for population data, you may decide to first resample to the</span>
<span class="sd">        original resolution of `domestic_fn` before downsampling with `population_fn`.</span>
<span class="sd">        For example, the pcr_globwb dataset is at a resolution of 0.0083333333 degrees,</span>
<span class="sd">        while the original data has a resolution of 0.5 degrees. Use the</span>
<span class="sd">        `domestic_fn_original_res` parameter to specify the original resolution.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **demand_domestic_gross**: gross domestic water demand [mm/day]</span>
<span class="sd">        * **demand_domestic_net**: net domestic water demand [mm/day]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        domestic_fn : str | xr.Dataset</span>
<span class="sd">            The domestic dataset. This can either be the dataset directly (xr.Dataset),</span>
<span class="sd">            a string referring to an entry in the data catalog or a dictionary</span>
<span class="sd">            containing the name of the dataset (keyword: `source`) and any optional</span>
<span class="sd">            keyword arguments (e.g. `version`). The data can be cyclic</span>
<span class="sd">            (with a `time` dimension) or non-cyclic. Allowed cyclic data can be monthly</span>
<span class="sd">            (12) or dayofyear (365 or 366).</span>

<span class="sd">            * Required variables: &#39;domestic_gross&#39; [mm/day], &#39;domestic_net&#39; [mm/day]</span>
<span class="sd">        population_fn : str | xr.Dataset</span>
<span class="sd">            The population dataset in capita. Either provided as a dataset directly or</span>
<span class="sd">            as a string referring to an entry in the data catalog.</span>
<span class="sd">        domestic_fn_original_res : Optional[float], optional</span>
<span class="sd">            The original resolution of the domestic dataset, by default None to skip</span>
<span class="sd">            upscaling before downsampling with population.</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing domestic demand maps.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>
        <span class="c1"># Set flag for cyclic data</span>
        <span class="n">_cyclic</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Read data</span>
        <span class="n">domestic_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">domestic_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;domestic_gross&quot;</span><span class="p">,</span> <span class="s2">&quot;domestic_net&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="c1"># Increase the buffer if original resolution is provided</span>
        <span class="k">if</span> <span class="n">domestic_fn_original_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">buffer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">domestic_fn_original_res</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">domestic_raw</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">domestic_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">domestic_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;domestic_gross&quot;</span><span class="p">,</span> <span class="s2">&quot;domestic_net&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="c1"># Check if data is time dependent</span>
        <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">domestic_raw</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="c1"># Check that this is indeed cyclic data</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">domestic_raw</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">365</span><span class="p">,</span> <span class="mi">366</span><span class="p">]:</span>
                <span class="n">_cyclic</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">domestic_raw</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">domestic_raw</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;The provided domestic demand data is cyclic but the time &quot;</span>
                    <span class="s2">&quot;dimension does not match the expected length of 12, 365 or 366.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Get population data</span>
        <span class="n">pop_raw</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">population_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pop_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">population_fn</span><span class="p">,</span>
                <span class="n">bbox</span><span class="o">=</span><span class="n">domestic_raw</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Compute domestic demand</span>
        <span class="n">domestic</span><span class="p">,</span> <span class="n">pop</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">domestic</span><span class="p">(</span>
            <span class="n">domestic_raw</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">popu</span><span class="o">=</span><span class="n">pop_raw</span><span class="p">,</span>
            <span class="n">original_res</span><span class="o">=</span><span class="n">domestic_fn_original_res</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Add to grid</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">domestic</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">domestic</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">population_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;meta_population&quot;</span><span class="p">)</span>

        <span class="c1"># Update toml</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.water_demand.domestic__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;cyclic&quot;</span> <span class="k">if</span> <span class="n">_cyclic</span> <span class="k">else</span> <span class="s2">&quot;static&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">domestic</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">,</span> <span class="n">data_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_domestic_demand_from_population">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_domestic_demand_from_population.html#hydromt_wflow.WflowModel.setup_domestic_demand_from_population">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_domestic_demand_from_population</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">population_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">domestic_gross_per_capita</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">domestic_net_per_capita</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;land~domestic__gross_water_demand_volume_flux&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_domestic_gross&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land~domestic__net_water_demand_volume_flux&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_domestic_net&quot;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare domestic water demand maps from statistics per capita.</span>

<span class="sd">        Gross and net demands per capita can be provide as cyclic (list) or non-cyclic</span>
<span class="sd">        (constant). The statistics are then multiplied by the population dataset to</span>
<span class="sd">        derive the gross and net domestic demand.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **demand_domestic_gross**: gross domestic water demand [mm/day]</span>
<span class="sd">        * **demand_domestic_net**: net domestic water demand [mm/day]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        population_fn : str | xr.Dataset</span>
<span class="sd">            The (gridded) population dataset in capita. Either provided as a dataset</span>
<span class="sd">            directly or as a string referring to an entry in the data catalog.</span>
<span class="sd">        domestic_gross_per_capita : float | List[float]</span>
<span class="sd">            The gross domestic water demand per capita [m3/day]. If cyclic, provide a</span>
<span class="sd">            list with 12 values for monthly data or 365/366 values for daily data.</span>
<span class="sd">        domestic_net_per_capita : float | List[float] | None</span>
<span class="sd">            The net domestic water demand per capita [m3/day]. If cyclic, provide a</span>
<span class="sd">            list with 12 values for monthly data or 365/366 values for daily data. If</span>
<span class="sd">            not provided, the gross demand will be used as net demand.</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing domestic demand maps based on population.&quot;</span><span class="p">)</span>

        <span class="c1"># Set flag for cyclic data</span>
        <span class="n">_cyclic</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>

        <span class="c1"># Check if data is time dependent</span>
        <span class="n">time_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">domestic_gross_per_capita</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">time_length</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">365</span><span class="p">,</span> <span class="mi">366</span><span class="p">]:</span>
            <span class="n">_cyclic</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">time_length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The provided domestic demand data is cyclic but the length &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">time_length</span><span class="si">}</span><span class="s2">)does not match the expected length of 12, 365 or 366.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">domestic_net_per_capita</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">domestic_net_per_capita</span> <span class="o">=</span> <span class="n">domestic_gross_per_capita</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Net domestic demand not provided, using gross demand.&quot;</span><span class="p">)</span>

        <span class="c1"># Get population data</span>
        <span class="n">popu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">population_fn</span><span class="p">,</span>
            <span class="n">bbox</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Compute domestic demand</span>
        <span class="n">domestic</span><span class="p">,</span> <span class="n">popu_scaled</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">domestic_from_population</span><span class="p">(</span>
            <span class="n">popu</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">gross_per_capita</span><span class="o">=</span><span class="n">domestic_gross_per_capita</span><span class="p">,</span>
            <span class="n">net_per_capita</span><span class="o">=</span><span class="n">domestic_net_per_capita</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Add to grid</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">domestic</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">domestic</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">population_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">popu_scaled</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;meta_population&quot;</span><span class="p">)</span>

        <span class="c1"># Update toml</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.water_demand.domestic__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;cyclic&quot;</span> <span class="k">if</span> <span class="n">_cyclic</span> <span class="k">else</span> <span class="s2">&quot;static&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">domestic</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">,</span> <span class="n">data_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_other_demand">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_other_demand.html#hydromt_wflow.WflowModel.setup_other_demand">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_other_demand</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">demand_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;industry_gross&quot;</span><span class="p">,</span>
            <span class="s2">&quot;industry_net&quot;</span><span class="p">,</span>
            <span class="s2">&quot;livestock_gross&quot;</span><span class="p">,</span>
            <span class="s2">&quot;livestock_net&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">resampling_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;average&quot;</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;land~industry__gross_water_demand_volume_flux&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_industry_gross&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land~industry__net_water_demand_volume_flux&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_industry_net&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land~livestock__gross_water_demand_volume_flux&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_livestock_gross&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land~livestock__net_water_demand_volume_flux&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_livestock_net&quot;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create water demand maps from other sources (e.g. industry, livestock).</span>

<span class="sd">        These maps are created from a supplied dataset that either contains one</span>
<span class="sd">        or all of the following variables:</span>
<span class="sd">        - `Industrial` water demand</span>
<span class="sd">        - `Livestock` water demand</span>
<span class="sd">        - `Domestic` water demand (without population downsampling)</span>

<span class="sd">        For each of these datasets/ variables a gross and a netto water demand</span>
<span class="sd">        should be provided. They can either be provided cyclic or non-cyclic. The</span>
<span class="sd">        maps are then resampled to the model resolution using the provided</span>
<span class="sd">        `resampling_method`.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **{var}_gross**: gross water demand [mm/day]</span>
<span class="sd">        * **{var}_net**: net water demand [mm/day]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        demand_fn : str | Dict[str, Dict[str, Any]], xr.Dataset]</span>
<span class="sd">            The water demand dataset. This can either be the dataset directly</span>
<span class="sd">            (xr.Dataset), a string referring to an entry in the data catalog or</span>
<span class="sd">            a dictionary containing the name of the dataset (keyword: `source`) and</span>
<span class="sd">            any optional keyword arguments (e.g. `version`). The data can be cyclic</span>
<span class="sd">            (with a `time` dimension) or non-cyclic. Allowed cyclic data can be monthly</span>
<span class="sd">            (12) or dayofyear (365 or 366).</span>

<span class="sd">            * Required variables: variables listed in `variables` in [mm/day].</span>
<span class="sd">        variables : list, optional</span>
<span class="sd">            The variables to be processed. Supported variables are [&#39;domestic_gross&#39;,</span>
<span class="sd">            &#39;domestic_net&#39;, &#39;industry_gross&#39;, &#39;industry_net&#39;, &#39;livestock_gross&#39;,</span>
<span class="sd">            &#39;livestock_net&#39;]. By default gross and net demand for industry and livestock</span>
<span class="sd">            are processed.</span>
<span class="sd">        resampling_method : str, optional</span>
<span class="sd">            Resampling method for the demand maps, by default &quot;average&quot;</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparing water demand maps for </span><span class="si">{</span><span class="n">variables</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="c1"># Set flag for cyclic data</span>
        <span class="n">_cyclic</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>

        <span class="c1"># Selecting data</span>
        <span class="n">demand_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">demand_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">demand_raw</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="c1"># Check that this is indeed cyclic data</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">demand_raw</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">365</span><span class="p">,</span> <span class="mi">366</span><span class="p">]:</span>
                <span class="n">_cyclic</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">demand_raw</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">demand_raw</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;The provided demand data is cyclic but the time dimension does &quot;</span>
                    <span class="s2">&quot;not match the expected length of 12, 365 or 366.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Create static water demand rasters</span>
        <span class="n">demand</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">other_demand</span><span class="p">(</span>
            <span class="n">demand_raw</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">ds_method</span><span class="o">=</span><span class="n">resampling_method</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">demand</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">demand</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>

        <span class="c1"># Update the settings toml</span>
        <span class="k">if</span> <span class="s2">&quot;domestic_gross&quot;</span> <span class="ow">in</span> <span class="n">demand</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.water_demand.domestic__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;industry_gross&quot;</span> <span class="ow">in</span> <span class="n">demand</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.water_demand.industry__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;livestock_gross&quot;</span> <span class="ow">in</span> <span class="n">demand</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.water_demand.livestock__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;cyclic&quot;</span> <span class="k">if</span> <span class="n">_cyclic</span> <span class="k">else</span> <span class="s2">&quot;static&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">demand</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">,</span> <span class="n">data_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_irrigation">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_irrigation.html#hydromt_wflow.WflowModel.setup_irrigation">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_irrigation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">irrigated_area_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">irrigation_value</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">cropland_class</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">paddy_class</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">area_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.6</span><span class="p">,</span>
        <span class="n">lai_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">lulcmap_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;meta_landuse&quot;</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;land~irrigated-paddy_area__count&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land~irrigated-non-paddy_area__count&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land~irrigated-paddy__irrigation_trigger_flag&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_paddy_irrigation_trigger&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;land~irrigated-non-paddy__irrigation_trigger_flag&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_nonpaddy_irrigation_trigger&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add required information to simulate irrigation water demand from grid.</span>

<span class="sd">        THIS FUNCTION SHOULD BE RUN AFTER LANDUSE AND LAI MAPS ARE CREATED.</span>

<span class="sd">        The function requires data that contains information about the location of the</span>
<span class="sd">        irrigated areas (``irrigated_area_fn``). This, combined with the wflow landuse</span>
<span class="sd">        map that contains classes for cropland (``cropland_class``) and optionally for</span>
<span class="sd">        paddy (rice) (``paddy_class``), determines which locations are considered to be</span>
<span class="sd">        paddy irrigation, and which locations are considered to be non-paddy irrigation.</span>

<span class="sd">        Next, the irrigated area map is reprojected to the model resolution, where a</span>
<span class="sd">        threshold (``area_threshold``) determines when pixels are considered to be</span>
<span class="sd">        classified as irrigation or rainfed cells (both paddy and non-paddy). It adds</span>
<span class="sd">        the resulting maps to the input data.</span>

<span class="sd">        To determine when irrigation is allowed to occur, an irrigation trigger map is</span>
<span class="sd">        defined. This is a cyclic map, that defines (with a mask) when irrigation is</span>
<span class="sd">        expected to occur. This is done based on the Leaf Area Index (LAI), that is</span>
<span class="sd">        already present in the wflow model configuration. We follow the procedure</span>
<span class="sd">        described by Peano et al. (2019). They describe a threshold value based on the</span>
<span class="sd">        LAI variability to determine the growing season. This threshold is defined as</span>
<span class="sd">        20% (default value) of the LAI variability, but can be adjusted via the</span>
<span class="sd">        ``lai_threshold`` argument.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **demand_nonpaddy_irrigated_mask**: Irrigated (non-paddy) mask [-]</span>
<span class="sd">        * **demand_paddy_irrigated_mask**: Irrigated (paddy) mask [-]</span>
<span class="sd">        * **demand_paddy_irrigation_trigger**: Map with monthly values, indicating</span>
<span class="sd">          whether irrigation is allowed (1) or not (0) [-] for paddy areas</span>
<span class="sd">        * **demand_paddy_irrigation_trigger**: Map with monthly values, indicating</span>
<span class="sd">          whether irrigation is allowed (1) or not (0) [-] for non-paddy areas</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        irrigated_area_fn: str, Path, xarray.DataArray</span>
<span class="sd">            Name of the (gridded) dataset that contains the location of irrigated areas.</span>
<span class="sd">        irrigation_value: list</span>
<span class="sd">            List of values that are considered to be irrigated areas in</span>
<span class="sd">            ``irrigated_area_fn``.</span>
<span class="sd">        cropland_class: list</span>
<span class="sd">            List of values that are considered to be cropland in the wflow landuse data.</span>
<span class="sd">        paddy_class: int</span>
<span class="sd">            Class in the wflow landuse data that is considered as paddy or rice. Leave</span>
<span class="sd">            empty if not present (default).</span>
<span class="sd">        area_threshold: float</span>
<span class="sd">            Fractional area of a (wflow) pixel before it gets classified as an irrigated</span>
<span class="sd">            pixel, by default 0.6</span>
<span class="sd">        lai_threshold: float</span>
<span class="sd">            Value of LAI variability to be used to determine the irrigation trigger. By</span>
<span class="sd">            default 0.2.</span>
<span class="sd">        lulcmap_name: str</span>
<span class="sd">            Name of the landuse map layer in the wflow model staticmaps. By default</span>
<span class="sd">            &#39;meta_landuse&#39;. Please update if your landuse map has a different name</span>
<span class="sd">            (eg &#39;landuse_globcover&#39;).</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        workflows.demand.irrigation</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Peano, D., Materia, S., Collalti, A., Alessandri, A., Anav, A., Bombelli, A., &amp;</span>
<span class="sd">        Gualdi, S. (2019). Global variability of simulated and observed vegetation</span>
<span class="sd">        growing season. Journal of Geophysical Research: Biogeosciences, 124, 35693587.</span>
<span class="sd">        https://doi.org/10.1029/2018JG004881</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing irrigation maps.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lulcmap_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="c1"># update the internal mapping</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;landuse&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lulcmap_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Landuse map </span><span class="si">{</span><span class="n">lulcmap_name</span><span class="si">}</span><span class="s2"> not found in the model grid. Please &quot;</span>
                <span class="s2">&quot;provide a valid landuse map name or run setup_lulcmaps.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Extract irrigated area dataset</span>
        <span class="n">irrigated_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">irrigated_area_fn</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">3</span>
        <span class="p">)</span>

        <span class="c1"># Get irrigation areas for paddy, non paddy and irrigation trigger</span>
        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">}</span>
        <span class="n">ds_irrigation</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">irrigation</span><span class="p">(</span>
            <span class="n">da_irrigation</span><span class="o">=</span><span class="n">irrigated_area</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">irrigation_value</span><span class="o">=</span><span class="n">irrigation_value</span><span class="p">,</span>
            <span class="n">cropland_class</span><span class="o">=</span><span class="n">cropland_class</span><span class="p">,</span>
            <span class="n">paddy_class</span><span class="o">=</span><span class="n">paddy_class</span><span class="p">,</span>
            <span class="n">area_threshold</span><span class="o">=</span><span class="n">area_threshold</span><span class="p">,</span>
            <span class="n">lai_threshold</span><span class="o">=</span><span class="n">lai_threshold</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Check if paddy and non paddy are present</span>
        <span class="n">cyclic_lai</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span> <span class="ow">in</span> <span class="n">ds_irrigation</span><span class="o">.</span><span class="n">data_vars</span>
            <span class="ow">and</span> <span class="n">ds_irrigation</span><span class="p">[</span><span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">mask_nodata</span><span class="p">()</span>
            <span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="o">.</span><span class="n">values</span>
            <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="c1"># Select the paddy variables in output_names</span>
            <span class="n">paddy_names</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">output_names</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;irrigated-paddy&quot;</span> <span class="ow">in</span> <span class="n">k</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">paddy_names</span><span class="p">)</span>
            <span class="n">ds_paddy</span> <span class="o">=</span> <span class="n">ds_irrigation</span><span class="p">[</span>
                <span class="p">[</span><span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_paddy_irrigation_trigger&quot;</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_paddy</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_paddy</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.water_demand.paddy__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span>
                <span class="p">),</span>
                <span class="s2">&quot;static&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;cyclic&quot;</span> <span class="k">if</span> <span class="n">cyclic_lai</span> <span class="k">else</span> <span class="s2">&quot;static&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;demand_paddy_irrigation_trigger&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_paddy_irrigation_trigger&quot;</span>
                <span class="p">),</span>
                <span class="n">data_type</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.water_demand.paddy__flag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">ds_irrigation</span><span class="p">[</span><span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">mask_nodata</span><span class="p">()</span>
            <span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="o">.</span><span class="n">values</span>
            <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="n">nonpaddy_names</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">output_names</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;irrigated-non-paddy&quot;</span> <span class="ow">in</span> <span class="n">k</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">nonpaddy_names</span><span class="p">)</span>
            <span class="n">ds_nonpaddy</span> <span class="o">=</span> <span class="n">ds_irrigation</span><span class="p">[</span>
                <span class="p">[</span><span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_nonpaddy_irrigation_trigger&quot;</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_nonpaddy</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_nonpaddy</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
            <span class="c1"># Update the config</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.water_demand.nonpaddy__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span>
                <span class="p">),</span>
                <span class="s2">&quot;static&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;cyclic&quot;</span> <span class="k">if</span> <span class="n">cyclic_lai</span> <span class="k">else</span> <span class="s2">&quot;static&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;demand_nonpaddy_irrigation_trigger&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;demand_nonpaddy_irrigation_trigger&quot;</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">data_type</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.water_demand.nonpaddy__flag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_irrigation_from_vector">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_irrigation_from_vector.html#hydromt_wflow.WflowModel.setup_irrigation_from_vector">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_irrigation_from_vector</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">irrigated_area_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">cropland_class</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">paddy_class</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">area_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.6</span><span class="p">,</span>
        <span class="n">lai_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;land~irrigated-paddy_area__count&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land~irrigated-non-paddy_area__count&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land~irrigated-paddy__irrigation_trigger_flag&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_paddy_irrigation_trigger&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;land~irrigated-non-paddy__irrigation_trigger_flag&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_nonpaddy_irrigation_trigger&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add required information to simulate irrigation water demand from vector.</span>

<span class="sd">        THIS FUNCTION SHOULD BE RUN AFTER LANDUSE AND LAI MAPS ARE CREATED.</span>

<span class="sd">        The function requires data that contains information about the location of the</span>
<span class="sd">        irrigated areas (``irrigated_area_fn``). This, combined with the wflow landuse</span>
<span class="sd">        map that contains classes for cropland (``cropland_class``) and optionally for</span>
<span class="sd">        paddy (rice) (``paddy_class``), determines which locations are considered to be</span>
<span class="sd">        paddy irrigation, and which locations are considered to be non-paddy irrigation.</span>

<span class="sd">        Next, the irrigated area geometries are rasterized, where a threshold</span>
<span class="sd">        (``area_threshold``) determines when pixels are considered to be</span>
<span class="sd">        classified as irrigation or rainfed cells (both paddy and non-paddy). It adds</span>
<span class="sd">        the resulting maps to the input data.</span>

<span class="sd">        To determine when irrigation is allowed to occur, an irrigation trigger map is</span>
<span class="sd">        defined. This is a cyclic map, that defines (with a mask) when irrigation is</span>
<span class="sd">        expected to occur. This is done based on the Leaf Area Index (LAI), that is</span>
<span class="sd">        already present in the wflow model configuration. We follow the procedure</span>
<span class="sd">        described by Peano et al. (2019). They describe a threshold value based on the</span>
<span class="sd">        LAI variability to determine the growing season. This threshold is defined as</span>
<span class="sd">        20% (default value) of the LAI variability, but can be adjusted via the</span>
<span class="sd">        ``lai_threshold`` argument.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **demand_paddy_irrigated_mask**: Irrigated (paddy) mask [-]</span>
<span class="sd">        * **demand_nonpaddy_irrigated_mask**: Irrigated (non-paddy) mask [-]</span>
<span class="sd">        * **demand_paddy_irrigation_trigger**: Map with monthly values, indicating</span>
<span class="sd">          whether irrigation is allowed (1) or not (0) [-] for paddy areas</span>
<span class="sd">        * **demand_nonpaddy_irrigation_trigger**: Map with monthly values, indicating</span>
<span class="sd">          whether irrigation is allowed (1) or not (0) [-] for non-paddy areas</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        irrigated_area_fn: str, Path, geopandas.GeoDataFrame</span>
<span class="sd">            Name of the (vector) dataset that contains the location of irrigated areas.</span>
<span class="sd">        cropland_class: list</span>
<span class="sd">            List of values that are considered to be cropland in the wflow landuse data.</span>
<span class="sd">        paddy_class: int</span>
<span class="sd">            Class in the wflow landuse data that is considered as paddy or rice. Leave</span>
<span class="sd">            empty if not present (default).</span>
<span class="sd">        area_threshold: float</span>
<span class="sd">            Fractional area of a (wflow) pixel before it gets classified as an irrigated</span>
<span class="sd">            pixel, by default 0.6</span>
<span class="sd">        lai_threshold: float</span>
<span class="sd">            Value of LAI variability to be used to determine the irrigation trigger. By</span>
<span class="sd">            default 0.2.</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        workflows.demand.irrigation</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Peano, D., Materia, S., Collalti, A., Alessandri, A., Anav, A., Bombelli, A., &amp;</span>
<span class="sd">        Gualdi, S. (2019). Global variability of simulated and observed vegetation</span>
<span class="sd">        growing season. Journal of Geophysical Research: Biogeosciences, 124, 35693587.</span>
<span class="sd">        https://doi.org/10.1029/2018JG004881</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing irrigation maps.&quot;</span><span class="p">)</span>

        <span class="c1"># Extract irrigated area dataset</span>
        <span class="n">irrigated_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">irrigated_area_fn</span><span class="p">,</span>
            <span class="n">bbox</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
            <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;intersects&quot;</span><span class="p">,</span>
            <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Check if the geodataframe is empty</span>
        <span class="k">if</span> <span class="n">irrigated_area</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">irrigated_area</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No irrigated areas found in the provided geodataframe.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Get irrigation areas for paddy, non paddy and irrigation trigger</span>
        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">}</span>
        <span class="n">ds_irrigation</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">irrigation_from_vector</span><span class="p">(</span>
            <span class="n">gdf_irrigation</span><span class="o">=</span><span class="n">irrigated_area</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">cropland_class</span><span class="o">=</span><span class="n">cropland_class</span><span class="p">,</span>
            <span class="n">paddy_class</span><span class="o">=</span><span class="n">paddy_class</span><span class="p">,</span>
            <span class="n">area_threshold</span><span class="o">=</span><span class="n">area_threshold</span><span class="p">,</span>
            <span class="n">lai_threshold</span><span class="o">=</span><span class="n">lai_threshold</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Check if paddy and non paddy are present</span>
        <span class="n">cyclic_lai</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span> <span class="ow">in</span> <span class="n">ds_irrigation</span><span class="o">.</span><span class="n">data_vars</span>
            <span class="ow">and</span> <span class="n">ds_irrigation</span><span class="p">[</span><span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">mask_nodata</span><span class="p">()</span>
            <span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="o">.</span><span class="n">values</span>
            <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="n">paddy_names</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">output_names</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;irrigated-paddy&quot;</span> <span class="ow">in</span> <span class="n">k</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">paddy_names</span><span class="p">)</span>
            <span class="n">ds_paddy</span> <span class="o">=</span> <span class="n">ds_irrigation</span><span class="p">[</span>
                <span class="p">[</span><span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_paddy_irrigation_trigger&quot;</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_paddy</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_paddy</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
            <span class="c1"># Update the config</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.water_demand.paddy__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span>
                <span class="p">),</span>
                <span class="s2">&quot;static&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;cyclic&quot;</span> <span class="k">if</span> <span class="n">cyclic_lai</span> <span class="k">else</span> <span class="s2">&quot;static&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;demand_paddy_irrigation_trigger&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_paddy_irrigation_trigger&quot;</span>
                <span class="p">),</span>
                <span class="n">data_type</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.water_demand.paddy__flag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">ds_irrigation</span><span class="p">[</span><span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">mask_nodata</span><span class="p">()</span>
            <span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="o">.</span><span class="n">values</span>
            <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="n">nonpaddy_names</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">output_names</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;irrigated-non-paddy&quot;</span> <span class="ow">in</span> <span class="n">k</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">nonpaddy_names</span><span class="p">)</span>
            <span class="n">ds_nonpaddy</span> <span class="o">=</span> <span class="n">ds_irrigation</span><span class="p">[</span>
                <span class="p">[</span><span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_nonpaddy_irrigation_trigger&quot;</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_nonpaddy</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_nonpaddy</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
            <span class="c1"># Update the config</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.water_demand.nonpaddy__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span>
                <span class="p">),</span>
                <span class="s2">&quot;static&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;cyclic&quot;</span> <span class="k">if</span> <span class="n">cyclic_lai</span> <span class="k">else</span> <span class="s2">&quot;static&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;demand_nonpaddy_irrigation_trigger&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;demand_nonpaddy_irrigation_trigger&quot;</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">data_type</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.water_demand.nonpaddy__flag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_cold_states">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_cold_states.html#hydromt_wflow.WflowModel.setup_cold_states">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_cold_states</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">timestamp</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare cold states for Wflow.</span>

<span class="sd">        To be run last as this requires some soil parameters or constant_pars to be</span>
<span class="sd">        computed already.</span>

<span class="sd">        To be run after setup_lakes, setup_reservoirs and setup_glaciers to also create</span>
<span class="sd">        cold states for them if they are present in the basin.</span>

<span class="sd">        This function is mainly useful in case the wflow model is read into Delft-FEWS.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **soil_saturated_depth**: saturated store [mm]</span>
<span class="sd">        * **snow_leq_depth**: snow storage [mm]</span>
<span class="sd">        * **soil_temp**: top soil temperature [C]</span>
<span class="sd">        * **soil_unsaturated_depth**: amount of water in the unsaturated store, per</span>
<span class="sd">          layer [mm]</span>
<span class="sd">        * **snow_water_depth**: liquid water content in the snow pack [mm]</span>
<span class="sd">        * **vegetation_water_depth**: canopy storage [mm]</span>
<span class="sd">        * **river_instantaneous_q**: river discharge [m3/s]</span>
<span class="sd">        * **river_instantaneous_h**: river water level [m]</span>
<span class="sd">        * **subsurface_q**: subsurface flow [m3/d]</span>
<span class="sd">        * **land_instantaneous_h**: land water level [m]</span>
<span class="sd">        * **land_instantaneous_q** or **land_instantaneous_qx**+</span>
<span class="sd">          **land_instantaneous_qy**: overland flow for kinwave [m3/s] or</span>
<span class="sd">          overland flow in x/y directions for local-inertial [m3/s]</span>

<span class="sd">        If lakes, also adds:</span>

<span class="sd">        * **lake_instantaneous_water_level**: lake water level [m]</span>

<span class="sd">        If reservoirs, also adds:</span>

<span class="sd">        * **reservoir_instantaneous_volume**: reservoir volume [m3]</span>

<span class="sd">        If glaciers, also adds:</span>

<span class="sd">        * **glacier_leq_depth**: water within the glacier [mm]</span>

<span class="sd">        If paddy, also adds:</span>

<span class="sd">        * **demand_paddy_h**: water on the paddy fields [mm]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestamp : str, optional</span>
<span class="sd">            Timestamp of the cold states. By default uses the (starttime - timestepsecs)</span>
<span class="sd">            from the config.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">states_config</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">prepare_cold_states</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span>
            <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span>
            <span class="n">mask_name_land</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">],</span>
            <span class="n">mask_name_river</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_states</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>

        <span class="c1"># Update config to read the states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.cold_start__flag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Update states variables names in config</span>
        <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">states_config</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">states_config</span><span class="p">[</span><span class="n">option</span><span class="p">])</span></div>


<div class="viewcode-block" id="WflowModel.upgrade_to_v1_wflow">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.upgrade_to_v1_wflow.html#hydromt_wflow.WflowModel.upgrade_to_v1_wflow">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">upgrade_to_v1_wflow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Upgrade the model to wflow v1 format.</span>

<span class="sd">        The function reads a TOML from wflow v0x and converts it to wflow v1x format.</span>
<span class="sd">        The other components stay the same.</span>
<span class="sd">        This function should be followed by write_config() to write the upgraded file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="n">config_out</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">convert_to_wflow_v1_sbm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">DATADIR</span> <span class="o">/</span> <span class="s2">&quot;default_config_headers.toml&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">tomllib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">config_out</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">config_out</span><span class="p">[</span><span class="n">option</span><span class="p">])</span></div>


    <span class="c1">## I/O</span>
<div class="viewcode-block" id="WflowModel.write">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.write.html#hydromt_wflow.WflowModel.write">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">config_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">grid_fn</span><span class="p">:</span> <span class="n">Path</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;staticmaps.nc&quot;</span><span class="p">,</span>
        <span class="n">geoms_fn</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;staticgeoms&quot;</span><span class="p">),</span>
        <span class="n">forcing_fn</span><span class="p">:</span> <span class="n">Path</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">states_fn</span><span class="p">:</span> <span class="n">Path</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the complete model schematization and configuration to file.</span>

<span class="sd">        From this function, the output filenames/folder of the different components can</span>
<span class="sd">        be set. If not set, the default filenames/folder are used.</span>
<span class="sd">        To change more advanced settings, use the specific write methods directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        config_fn : str, optional</span>
<span class="sd">            Name of the config file, relative to model root. By default None.</span>
<span class="sd">        grid_fn : str, optional</span>
<span class="sd">            Name of the grid file, relative to model root/dir_input. By default</span>
<span class="sd">            &#39;staticmaps.nc&#39;.</span>
<span class="sd">        geoms_fn : str, optional</span>
<span class="sd">            Name of the geoms folder relative to grid_fn (ie model root/dir_input). By</span>
<span class="sd">            default &#39;staticgeoms&#39;.</span>
<span class="sd">        forcing_fn : str, optional</span>
<span class="sd">            Name of the forcing file relative to model root/dir_input. By default None</span>
<span class="sd">            to use the name as defined in the model config file.</span>
<span class="sd">        states_fn : str, optional</span>
<span class="sd">            Name of the states file relative to model root/dir_input. By default None</span>
<span class="sd">            to use the name as defined in the model config file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Write model data to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># if in r, r+ mode, only write updated components</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">is_writing_mode</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot write in read-only mode&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_data_catalog</span><span class="p">()</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">data</span>  <span class="c1"># try to read default if not yet set</span>
        <span class="k">if</span> <span class="s2">&quot;staticmaps&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">grid_fn</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;geoms&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="n">geoms_fn</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">Path</span><span class="p">(</span><span class="n">geoms_fn</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">geoms_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geoms_fn</span><span class="p">,</span> <span class="n">Path</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">geoms_fn</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">dir_out</span><span class="o">=</span><span class="n">geoms_fn</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;forcing&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">forcing_fn</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;tables&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tabeles</span><span class="o">.</span><span class="n">write</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;states&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">states_fn</span><span class="p">)</span>

        <span class="c1"># Write the config last as variables can get set in other write methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">config_fn</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.read">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.read.html#hydromt_wflow.WflowModel.read">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">config_filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">staticmaps_filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">geoms_filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read components from disk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        config_filename : str | None, optional</span>
<span class="sd">            config file name, by default None</span>
<span class="sd">        staticmaps_filename : str | None, optional</span>
<span class="sd">            static maps file name, by default None</span>
<span class="sd">        geoms_filename : str | None, optional</span>
<span class="sd">            geoms file name, by default None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">config_filename</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_config</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_config</span><span class="p">(</span><span class="n">config_filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">staticmaps_filename</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_staticmaps</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_staticmaps</span><span class="p">(</span><span class="n">staticmaps_filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">geoms_filename</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_geoms</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_geoms</span><span class="p">(</span><span class="n">geoms_filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_states</span><span class="p">()</span></div>


<div class="viewcode-block" id="WflowModel.read_config">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.read_config.html#hydromt_wflow.WflowModel.read_config">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_config</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">config_filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read config from &lt;root/config_filename&gt;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        config_filename : str, optional</span>
<span class="sd">            Name of the config file. By default None to use the default name</span>
<span class="sd">            wflow_sbm.toml.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Call the component</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">config_filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.write_config">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.write_config.html#hydromt_wflow.WflowModel.write_config">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_config</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">config_filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">config_root</span><span class="p">:</span> <span class="n">Path</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write config to &lt;root/config_fn&gt;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        config_name : str, optional</span>
<span class="sd">            Name of the config file. By default None to use the default name</span>
<span class="sd">            wflow_sbm.toml.</span>
<span class="sd">        config_root : str, optional</span>
<span class="sd">            Root folder to write the config file if different from model root (default).</span>
<span class="sd">            Can be absolute or relative to model root.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO is a compat method, remove in future</span>
        <span class="c1"># Bridge the diff in api</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">config_filename</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">_filename</span>
        <span class="k">if</span> <span class="n">config_root</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">config_root</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="c1"># Call the component</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.read_staticmaps">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.read_staticmaps.html#hydromt_wflow.WflowModel.read_staticmaps">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_staticmaps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="n">Path</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read staticmaps model data.</span>

<span class="sd">        Checks the path of the file in the config toml using both ``input.path_static``</span>
<span class="sd">        and ``dir_input``. If not found uses the default path ``staticmaps.nc`` in the</span>
<span class="sd">        root folder.</span>
<span class="sd">        Key-word arguments are passed to :py:meth:`~hydromt._io.readers._read_nc`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            Name or path to the staticmaps file to be read.</span>
<span class="sd">            This is the path/name relative to the root folder and if present the</span>
<span class="sd">            ``dir_input`` folder. By default None.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional keyword arguments to be passed to the `read_nc` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sort which path/ filename is actually the one used</span>
        <span class="c1"># Hierarchy is: 1: signature, 2: config, 3: default</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">filename</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;input.path_static&quot;</span><span class="p">)</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">_filename</span>
        <span class="p">)</span>
        <span class="c1"># Check for input dir</span>
        <span class="n">p_input</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="n">p</span><span class="p">)</span>

        <span class="c1"># Call the component method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">p_input</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.write_staticmaps">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.write_staticmaps.html#hydromt_wflow.WflowModel.write_staticmaps">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_staticmaps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="n">Path</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write grid to wflow static data file.</span>

<span class="sd">        Checks the path of the file in the config toml using both ``input.path_static``</span>
<span class="sd">        and ``dir_input``. If not found uses the default path ``staticmaps.nc`` in the</span>
<span class="sd">        root folder.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : Path, str, optional</span>
<span class="sd">            Name or path to the outgoing staticmaps file (including extension).</span>
<span class="sd">            This is the path/name relative to the root folder and if present the</span>
<span class="sd">            ``dir_input`` folder. By default None.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional keyword arguments to be passed to the `write_nc` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Solve pathing same as read</span>
        <span class="c1"># Hierarchy is: 1: signature, 2: config, 3: default</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">filename</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;input.path_static&quot;</span><span class="p">)</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">_filename</span>
        <span class="p">)</span>
        <span class="c1"># Check for input dir</span>
        <span class="n">p_input</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="n">p</span><span class="p">)</span>

        <span class="c1"># Call the component write method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">p_input</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Set the config entry to the correct path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
            <span class="s2">&quot;input.path_static&quot;</span><span class="p">,</span>
            <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">p_input</span><span class="p">)</span><span class="o">.</span><span class="n">as_posix</span><span class="p">(),</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.set_staticmaps">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.set_staticmaps.html#hydromt_wflow.WflowModel.set_staticmaps">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_staticmaps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add data to grid.</span>

<span class="sd">        All layers of grid must have identical spatial coordinates. This is an inherited</span>
<span class="sd">        method from HydroMT-core&#39;s GridModel.set_grid with some fixes. If basin data is</span>
<span class="sd">        available the grid will be masked to that upon setting.</span>

<span class="sd">        The first fix is when data with a time axis is being added. Since Wflow.jl</span>
<span class="sd">        v0.7.3, cyclic data at different lengths (12, 365, 366) is supported, as long as</span>
<span class="sd">        the dimension name starts with &quot;time&quot;. In this function, a check is done if a</span>
<span class="sd">        time axis with that exact shape is already present in the grid object, and will</span>
<span class="sd">        use that dimension (and its name) to set the data. If a time dimension does not</span>
<span class="sd">        yet exist with that shape, it is created following the format</span>
<span class="sd">        &quot;time_{length_data}&quot;.</span>

<span class="sd">        The other fix is that when the model is updated with a different number of</span>
<span class="sd">        layers, this is not automatically updated correctly. With this fix, the old</span>
<span class="sd">        layer dimension is removed (including all associated data), and the new data is</span>
<span class="sd">        added with the correct &quot;layer&quot; dimension.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: xarray.DataArray or xarray.Dataset</span>
<span class="sd">            new map layer to add to grid</span>
<span class="sd">        name: str, optional</span>
<span class="sd">            Name of new map layer, this is used to overwrite the name of a DataArray and</span>
<span class="sd">            ignored if data is a Dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Call the staticmaps set method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">set_geoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">:</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set geometries to the model.</span>

<span class="sd">        This is an inherited method from HydroMT-core&#39;s GeomsModel.set_geoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
            <span class="n">geom</span><span class="o">=</span><span class="n">geometry</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="WflowModel.read_geoms">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.read_geoms.html#hydromt_wflow.WflowModel.read_geoms">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_geoms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">geoms_filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;staticgeoms&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read static geometries and adds to ``geoms``.</span>

<span class="sd">        If ``dir_input`` is set in the config, the path where all static geometries are</span>
<span class="sd">        read, will be constructed as ``&lt;model_root&gt;/&lt;dir_input&gt;/&lt;geoms_fn&gt;``.</span>
<span class="sd">        Where &lt;dir_input&gt; is relative to the model root. Depending on the config value</span>
<span class="sd">        ``dir_input``, the path will be constructed differently.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geoms_filename : str, optional</span>
<span class="sd">            Folder name/path where the static geometries are stored relative to the</span>
<span class="sd">            model root and ``dir_input`` if any. By default &quot;staticgeoms&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">input_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">path</span><span class="p">),</span>
            <span class="n">geoms_filename</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span> <span class="s2">&quot;*.geojson&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">pattern</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.write_geoms">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.write_geoms.html#hydromt_wflow.WflowModel.write_geoms">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_geoms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">geoms_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;staticgeoms&quot;</span><span class="p">,</span>
        <span class="n">precision</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">to_wgs84</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write geoms in GeoJSON format.</span>

<span class="sd">        Checks the path of ``geoms_fn`` using both model root and</span>
<span class="sd">        ``dir_input``. If not found uses the default path ``staticgeoms`` in the root</span>
<span class="sd">        folder.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geoms_fn : str, optional</span>
<span class="sd">            Folder name/path where the static geometries are stored relative to the</span>
<span class="sd">            model root and ``dir_input`` if any. By default &quot;staticgeoms&quot;.</span>
<span class="sd">        precision : int, optional</span>
<span class="sd">            Decimal precision to write the geometries. By default None to use 1 decimal</span>
<span class="sd">            for projected crs and 6 for non-projected crs.</span>
<span class="sd">        to_wgs84 : bool, optional</span>
<span class="sd">            If True, geometries are transformed to WGS84 before writing. By default</span>
<span class="sd">            False, which means geometries are written in their original CRS.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">input_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">path</span><span class="p">),</span>
            <span class="n">geoms_fn</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="n">dir_out</span><span class="o">=</span><span class="n">Path</span><span class="p">(</span><span class="n">input_dir</span><span class="p">)</span><span class="o">.</span><span class="n">resolve</span><span class="p">(),</span>
            <span class="n">to_wgs84</span><span class="o">=</span><span class="n">to_wgs84</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.read_forcing">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.read_forcing.html#hydromt_wflow.WflowModel.read_forcing">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_forcing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read forcing.</span>

<span class="sd">        Checks the path of the file in the config toml using both ``input.path_forcing``</span>
<span class="sd">        and ``dir_input``. If not found uses the default path ``inmaps.nc`` in the</span>
<span class="sd">        root folder.</span>

<span class="sd">        If several files are used using &#39;*&#39; in ``input.path_forcing``, all corresponding</span>
<span class="sd">        files are read and merged into one xarray dataset before being split to one</span>
<span class="sd">        xarray dataaray per forcing variable in the hydromt ``forcing`` dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fn_default</span> <span class="o">=</span> <span class="s2">&quot;inmaps.nc&quot;</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
            <span class="s2">&quot;input.path_forcing&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">fn_default</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">input_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span>
                <span class="n">input_dir</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
                    <span class="s2">&quot;input.path_forcing&quot;</span><span class="p">,</span>
                    <span class="n">fallback</span><span class="o">=</span><span class="n">fn_default</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input directory found </span><span class="si">{</span><span class="n">input_dir</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="c1"># start fresh in read-only mode</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_forcing</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isfile</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read forcing from </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">},</span> <span class="n">decode_coords</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ds</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_forcing</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
        <span class="k">elif</span> <span class="s2">&quot;*&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read multiple forcing files using </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No forcing files found using </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_mfdataset</span><span class="p">(</span><span class="n">fns</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">},</span> <span class="n">decode_coords</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ds</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_forcing</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">])</span></div>


<div class="viewcode-block" id="WflowModel.write_forcing">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.write_forcing.html#hydromt_wflow.WflowModel.write_forcing">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_forcing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fn_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">freq_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">decimals</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">time_units</span><span class="o">=</span><span class="s2">&quot;days since 1900-01-01T00:00:00&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write forcing at ``fn_out`` in model ready format.</span>

<span class="sd">        If no ``fn_out`` path is provided and path_forcing from the  wflow toml exists,</span>
<span class="sd">        the following default filenames are used:</span>

<span class="sd">            * Default name format (with downscaling): \</span>
<span class="sd">inmaps_sourcePd_sourceTd_methodPET_freq_startyear_endyear.nc</span>
<span class="sd">            * Default name format (no downscaling): \</span>
<span class="sd">inmaps_sourceP_sourceT_methodPET_freq_startyear_endyear.nc</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fn_out: str, Path, optional</span>
<span class="sd">            Path to save output netcdf file; if None the name is read from the wflow</span>
<span class="sd">            toml file.</span>
<span class="sd">        freq_out: str (Offset), optional</span>
<span class="sd">            Write several files for the forcing according to fn_freq. For example &#39;Y&#39;</span>
<span class="sd">            for one file per year or &#39;M&#39; for one file per month.</span>
<span class="sd">            By default writes the one file.</span>
<span class="sd">            For more options, \</span>
<span class="sd">see https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases</span>
<span class="sd">        chunksize: int, optional</span>
<span class="sd">            Chunksize on time dimension when saving to disk. By default 1.</span>
<span class="sd">        decimals: int, optional</span>
<span class="sd">            Round the output data to the given number of decimals.</span>
<span class="sd">        time_units: str, optional</span>
<span class="sd">            Common time units when writing several netcdf forcing files.</span>
<span class="sd">            By default &quot;days since 1900-01-01T00:00:00&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Model opened in read-only mode&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Write forcing file&quot;</span><span class="p">)</span>

            <span class="c1"># Get default forcing name from forcing attrs</span>
            <span class="n">yr0</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.starttime&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">year</span>
            <span class="n">yr1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.endtime&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">year</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.timestepsecs&quot;</span><span class="p">)</span>
            <span class="c1"># get output filename</span>
            <span class="k">if</span> <span class="n">fn_out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.path_forcing&quot;</span><span class="p">,</span> <span class="n">fn_out</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fn_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;input.path_forcing&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">fn_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;*&quot;</span> <span class="ow">in</span> <span class="n">basename</span><span class="p">(</span><span class="n">fn_name</span><span class="p">):</span>
                        <span class="c1"># get rid of * in case model had multiple forcing files and</span>
                        <span class="c1"># write to single nc file.</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Writing multiple forcing files to one file&quot;</span><span class="p">)</span>
                        <span class="n">fn_name</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span>
                            <span class="n">dirname</span><span class="p">(</span><span class="n">fn_name</span><span class="p">),</span> <span class="n">basename</span><span class="p">(</span><span class="n">fn_name</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">input_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">fn_out</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span> <span class="n">fn_name</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fn_out</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">fn_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fn_out</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># get default filename if file exists</span>
                <span class="k">if</span> <span class="n">fn_out</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">isfile</span><span class="p">(</span><span class="n">fn_out</span><span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;Netcdf forcing file from input.path_forcing in the TOML  &quot;</span>
                        <span class="s2">&quot;already exists, using default name.&quot;</span>
                    <span class="p">)</span>
                    <span class="n">sourceP</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="n">sourceT</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="n">methodPET</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="k">if</span> <span class="s2">&quot;precip&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">:</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">[</span><span class="s2">&quot;precip&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;precip_clim_fn&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="n">Pdown</span> <span class="o">=</span> <span class="s2">&quot;d&quot;</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">[</span><span class="s2">&quot;precip&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;precip_fn&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">sourceP</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">val</span><span class="si">}{</span><span class="n">Pdown</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="s2">&quot;temp&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">:</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;temp_correction&quot;</span><span class="p">,</span> <span class="s2">&quot;False&quot;</span><span class="p">)</span>
                        <span class="n">Tdown</span> <span class="o">=</span> <span class="s2">&quot;d&quot;</span> <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="s2">&quot;True&quot;</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;temp_fn&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">sourceT</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">val</span><span class="si">}{</span><span class="n">Tdown</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="s2">&quot;pet&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">:</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pet_method&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">methodPET</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">fn_default</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;inmaps</span><span class="si">{</span><span class="n">sourceP</span><span class="si">}{</span><span class="n">sourceT</span><span class="si">}{</span><span class="n">methodPET</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">freq</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">yr0</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">yr1</span><span class="si">}</span><span class="s2">.nc&quot;</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">input_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">fn_default_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span> <span class="n">fn_default</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fn_default_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">fn_default</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">isfile</span><span class="p">(</span><span class="n">fn_default_path</span><span class="p">):</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="s2">&quot;Netcdf default forcing file already exists, </span><span class="se">\</span>
<span class="s2">skipping write_forcing. &quot;</span>
                            <span class="s2">&quot;To overwrite netcdf forcing file: </span><span class="se">\</span>
<span class="s2">change name input.path_forcing &quot;</span>
                            <span class="s2">&quot;in setup_config section of the build inifile.&quot;</span>
                        <span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.path_forcing&quot;</span><span class="p">,</span> <span class="n">fn_default</span><span class="p">)</span>
                        <span class="n">fn_out</span> <span class="o">=</span> <span class="n">fn_default_path</span>

            <span class="c1"># Check if all dates between (starttime, endtime) are in all da forcing</span>
            <span class="c1"># Check if starttime and endtime timestamps are correct</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.starttime&quot;</span><span class="p">))</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;time.endtime&quot;</span><span class="p">))</span>
            <span class="n">correct_times</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">da</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                    <span class="c1"># only correct dates in toml for standard calendars:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="s2">&quot;to_datetimeindex&quot;</span><span class="p">):</span>
                        <span class="n">times</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">values</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">start</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">times</span><span class="p">):</span>
                            <span class="n">start</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">correct_times</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="ow">or</span> <span class="p">(</span><span class="n">end</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">times</span><span class="p">):</span>
                            <span class="n">end</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                            <span class="n">correct_times</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># merge, process and write forcing</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">da</span><span class="o">.</span><span class="n">reset_coords</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">da</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
            <span class="c1"># Send warning, and update config with new start and end time</span>
            <span class="k">if</span> <span class="n">correct_times</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Not all dates found in precip_fn changing starttime to </span><span class="se">\</span>
<span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2"> and endtime to </span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2"> in the toml.&quot;</span>
                <span class="p">)</span>
                <span class="c1"># Set the strings first</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;time.starttime&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">T%H:%M:%S&quot;</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;time.endtime&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">T%H:%M:%S&quot;</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">decimals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span>
            <span class="c1"># clean-up forcing and write CRS according to CF-conventions</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">gdal_compliant</span><span class="p">(</span><span class="n">rename_dims</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_sn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s2">&quot;mask&quot;</span><span class="p">,</span> <span class="s2">&quot;idx_out&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

            <span class="c1"># write with output chunksizes with single timestep and complete</span>
            <span class="c1"># spatial grid to speed up the reading from wflow.jl</span>
            <span class="c1"># dims are always ordered (time, y, x)</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">_check_dimensions</span><span class="p">()</span>
            <span class="n">chunksizes</span> <span class="o">=</span> <span class="p">(</span><span class="n">chunksize</span><span class="p">,</span> <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">ycoords</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">xcoords</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">v</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zlib&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="s2">&quot;chunksizes&quot;</span><span class="p">:</span> <span class="n">chunksizes</span><span class="p">}</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="c1"># make sure no _FillValue is written to the time / x_dim / y_dim dimension</span>
            <span class="c1"># For several forcing files add common units attributes to time</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">x_dim</span><span class="p">,</span> <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">y_dim</span><span class="p">]:</span>
                <span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_FillValue&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">encoding</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_FillValue&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

            <span class="c1"># Check if all sub-folders in fn_out exists and if not create them</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">fn_out</span><span class="p">)):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">fn_out</span><span class="p">))</span>

            <span class="n">forcing_list</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="n">freq_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># with compute=False we get a delayed object which is executed when</span>
                <span class="c1"># calling .compute where we can pass more arguments to</span>
                <span class="c1"># the dask.compute method</span>
                <span class="n">forcing_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">ds</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Writing several forcing with freq </span><span class="si">{</span><span class="n">freq_out</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># For several forcing files add common units attributes to time</span>
                <span class="n">encoding</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_FillValue&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="n">time_units</span><span class="p">}</span>
                <span class="c1"># Updating path forcing in config</span>
                <span class="n">fns_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
                <span class="n">fns_out</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">fns_out</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="s2">_*.nc&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.path_forcing&quot;</span><span class="p">,</span> <span class="n">fns_out</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">ds_gr</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">freq_out</span><span class="p">):</span>
                    <span class="c1"># ds_gr = group[1]</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">ds_gr</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                    <span class="n">fn_out_gr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">fn_out</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">.nc&quot;</span>
                    <span class="n">forcing_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">fn_out_gr</span><span class="p">,</span> <span class="n">ds_gr</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">fn_out_gr</span><span class="p">,</span> <span class="n">ds_gr</span> <span class="ow">in</span> <span class="n">forcing_list</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Process forcing; saving to </span><span class="si">{</span><span class="n">fn_out_gr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">delayed_obj</span> <span class="o">=</span> <span class="n">ds_gr</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span>
                    <span class="n">fn_out_gr</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">compute</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="k">with</span> <span class="n">ProgressBar</span><span class="p">():</span>
                    <span class="n">delayed_obj</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


            <span class="c1"># TO profile uncomment lines below to replace lines above</span>
            <span class="c1"># from dask.diagnostics import Profiler, CacheProfiler, ResourceProfiler</span>
            <span class="c1"># import cachey</span>
            <span class="c1"># with Profiler() as prof, CacheProfiler(metric=cachey.nbytes) as cprof,</span>
            <span class="c1"># ResourceProfiler() as rprof:</span>
            <span class="c1">#     delayed_obj.compute()</span>
            <span class="c1"># visualize([prof, cprof, rprof],</span>
            <span class="c1"># file_path=r&#39;c:\Users\eilan_dk\work\profile2.html&#39;)</span>

<div class="viewcode-block" id="WflowModel.read_states">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.read_states.html#hydromt_wflow.WflowModel.read_states">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read states at &lt;root/dir_input/state.path_input&gt;.</span>

<span class="sd">        Checks the path of the file in the config toml using both ``state.path_input``</span>
<span class="sd">        and ``dir_input``. If not found uses the default path ``instate/instates.nc``</span>
<span class="sd">        in the root folder.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sort which path/ filename is actually the one used</span>
        <span class="c1"># Hierarchy is: 1: signature, 2: config, 3: default</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;state.path_input&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">_filename</span>
        <span class="c1"># Check for input dir</span>
        <span class="n">p_input</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="n">p</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">read</span><span class="p">(</span>
            <span class="n">filename</span><span class="o">=</span><span class="n">p_input</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.write_states">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.write_states.html#hydromt_wflow.WflowModel.write_states">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write states at &lt;root/dir_input/state.path_input&gt; in model ready format.</span>

<span class="sd">        Checks the path of the file in the config toml using both ``state.path_input``</span>
<span class="sd">        and ``dir_input``. If not found uses the default path ``instate/instates.nc``</span>
<span class="sd">        in the root folder.</span>
<span class="sd">        If filename is provided, it will be used and config ``state.path_input``</span>
<span class="sd">        will be updated accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str, Path, optional</span>
<span class="sd">            Name of the states file, relative to model root and ``dir_input`` if any.</span>
<span class="sd">            By default None to use the name as defined in the model config file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sort which path/ filename is actually the one used</span>
        <span class="c1"># Hierarchy is: 1: signature, 2: config, 3: default</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">filename</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;state.path_input&quot;</span><span class="p">)</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">_filename</span>
        <span class="p">)</span>
        <span class="c1"># Check for output dir</span>
        <span class="n">p_output</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="n">p</span><span class="p">)</span>

        <span class="c1"># Update the config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;state.path_input&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="c1"># Write</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">p_output</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.set_states">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.set_states.html#hydromt_wflow.WflowModel.set_states">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_states</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add data to states.</span>

<span class="sd">        All layers of states must have identical spatial coordinates. This is an</span>
<span class="sd">        inherited method from HydroMT-core&#39;s StatesModel.set_states with some fixes.</span>
<span class="sd">        If basin data is available the states will be masked to that upon setting.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: xarray.DataArray or xarray.Dataset</span>
<span class="sd">            new map layer to add to states</span>
<span class="sd">        name: str, optional</span>
<span class="sd">            Name of new map layer, this is used to overwrite the name of a DataArray and</span>
<span class="sd">            ignored if data is a Dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">mask_raster_from_layer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]])</span>
        <span class="c1"># fall back on default set_states behaviour</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.read_results">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.read_results.html#hydromt_wflow.WflowModel.read_results">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read results at &lt;root/?/&gt; and parse to dict of xr.DataArray/xr.Dataset.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="c1"># start fresh in read-only mode</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">output_dir</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_output&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_output&quot;</span><span class="p">)</span>

        <span class="c1"># Read gridded netcdf (output section)</span>
        <span class="n">nc_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;output.netcdf_grid.path&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nc_fn</span> <span class="o">=</span> <span class="n">nc_fn</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="n">output_dir</span> <span class="o">/</span> <span class="n">nc_fn</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">nc_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nc_fn</span>
        <span class="k">if</span> <span class="n">nc_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isfile</span><span class="p">(</span><span class="n">nc_fn</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read results from </span><span class="si">{</span><span class="n">nc_fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">nc_fn</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">},</span> <span class="n">decode_coords</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ds</span><span class="p">:</span>
                <span class="c1"># TODO ? align coords names and values of results nc with grid</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_results</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;netcdf_grid&quot;</span><span class="p">)</span>

        <span class="c1"># Read scalar netcdf (netcdf section)</span>
        <span class="n">ncs_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;output.netcdf_scalar.path&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ncs_fn</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ncs_fn</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="n">output_dir</span> <span class="o">/</span> <span class="n">ncs_fn</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">ncs_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ncs_fn</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ncs_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isfile</span><span class="p">(</span><span class="n">ncs_fn</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read results from </span><span class="si">{</span><span class="n">ncs_fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">ncs_fn</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">})</span> <span class="k">as</span> <span class="n">ds</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_results</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;netcdf_scalar&quot;</span><span class="p">)</span>

        <span class="c1"># Read csv timeseries (csv section)</span>
        <span class="n">csv_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;output.csv.path&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">csv_fn</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">csv_fn</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="n">output_dir</span> <span class="o">/</span> <span class="n">csv_fn</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">csv_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">csv_fn</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">csv_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isfile</span><span class="p">(</span><span class="n">csv_fn</span><span class="p">):</span>
            <span class="n">csv_dict</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">read_csv_results</span><span class="p">(</span>
                <span class="n">csv_fn</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span> <span class="n">maps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">csv_dict</span><span class="p">:</span>
                <span class="c1"># Add to results</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_results</span><span class="p">(</span><span class="n">csv_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span></div>


    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write results at &lt;root/?/&gt; in model ready format.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Model opened in read-only mode&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="WflowModel.read_tables">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.read_tables.html#hydromt_wflow.WflowModel.read_tables">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read table files at &lt;root&gt; and parse to dict of dataframes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># start fresh in read-only mode</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Reading model table files.&quot;</span><span class="p">)</span>
        <span class="n">fns</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;*.csv&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">basename</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">tbl</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">float_precision</span><span class="o">=</span><span class="s2">&quot;round_trip&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_tables</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.write_tables">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.write_tables.html#hydromt_wflow.WflowModel.write_tables">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write tables at &lt;root&gt;.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Model opened in read-only mode&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Writing table files.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">:</span>
                <span class="n">fn_out</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.set_tables">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.set_tables.html#hydromt_wflow.WflowModel.set_tables">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add table &lt;pandas.DataFrame&gt; to model.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;df type not recognized, should be pandas.DataFrame.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot overwrite table </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> in read-only mode&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Overwriting table: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span></div>


<div class="viewcode-block" id="WflowModel.get_config">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.get_config.html#hydromt_wflow.WflowModel.get_config">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_config</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">fallback</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">abs_path</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a config value at key.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : tuple, str</span>
<span class="sd">            keys can given by multiple args: (&#39;key1&#39;, &#39;key2&#39;)</span>
<span class="sd">            or a string with &#39;.&#39; indicating a new level: (&#39;key1.key2&#39;)</span>
<span class="sd">        fallback: Any, optional</span>
<span class="sd">            fallback value if key(s) not found in config, by default None.</span>
<span class="sd">        abs_path: bool, optional</span>
<span class="sd">            If True return the absolute path relative to the model root,</span>
<span class="sd">            by default False.</span>
<span class="sd">            NOTE: this assumes the config is located in model root!</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : Any</span>
<span class="sd">            dictionary value</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt; # self.config = {&#39;a&#39;: 1, &#39;b&#39;: {&#39;c&#39;: {&#39;d&#39;: 2}}}</span>

<span class="sd">        &gt;&gt; get_config(&#39;a&#39;)</span>
<span class="sd">        &gt;&gt; 1</span>

<span class="sd">        &gt;&gt; get_config(&#39;b&#39;, &#39;c&#39;, &#39;d&#39;) # identical to get_config(&#39;b.c.d&#39;)</span>
<span class="sd">        &gt;&gt; 2</span>

<span class="sd">        &gt;&gt; get_config(&#39;b.c&#39;) # # identical to get_config(&#39;b&#39;,&#39;c&#39;)</span>
<span class="sd">        &gt;&gt; {&#39;d&#39;: 2}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">fallback</span><span class="o">=</span><span class="n">fallback</span><span class="p">,</span>
            <span class="n">abs_path</span><span class="o">=</span><span class="n">abs_path</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.set_config">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.set_config.html#hydromt_wflow.WflowModel.set_config">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the config toml at key(s) with values.</span>

<span class="sd">        This function is made to maintain the structure of your toml file.</span>
<span class="sd">        When adding keys it will look for the most specific header present in</span>
<span class="sd">        the toml file and add it under that.</span>

<span class="sd">        meaning that if you have a config toml that is empty and you run</span>
<span class="sd">        ``wflow_model.set_config(&quot;input.forcing.scale&quot;, 1)``</span>

<span class="sd">        it will result in the following file:</span>

<span class="sd">        .. code-block:: toml</span>

<span class="sd">            input.forcing.scale = 1</span>


<span class="sd">        however if your toml file looks like this before:</span>

<span class="sd">        .. code-block:: toml</span>

<span class="sd">            [input.forcing]</span>

<span class="sd">        (i.e. you have a header in there that has no keys)</span>

<span class="sd">        then after the insertion it will look like this:</span>

<span class="sd">        .. code-block:: toml</span>

<span class="sd">            [input.forcing]</span>
<span class="sd">            scale = 1</span>


<span class="sd">        .. warning::</span>

<span class="sd">            Due to limitations of the underlying library it is currently not possible to</span>
<span class="sd">            create new headers (i.e. groups like ``input.forcing`` in the example above)</span>
<span class="sd">            programmatically, and they will need to be added to the default config</span>
<span class="sd">            toml document</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        args : str, tuple, list</span>
<span class="sd">            if tuple or list, minimal length of two</span>
<span class="sd">            keys can given by multiple args: (&#39;key1&#39;, &#39;key2&#39;, &#39;value&#39;)</span>
<span class="sd">            or a string with &#39;.&#39; indicating a new level: (&#39;key1.key2&#39;, &#39;value&#39;)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. code-block:: ipython</span>

<span class="sd">            &gt;&gt; self.config</span>
<span class="sd">            &gt;&gt; {&#39;a&#39;: 1, &#39;b&#39;: {&#39;c&#39;: {&#39;d&#39;: 2}}}</span>

<span class="sd">            &gt;&gt; self.set_config(&#39;a&#39;, 99)</span>
<span class="sd">            &gt;&gt; {&#39;a&#39;: 99, &#39;b&#39;: {&#39;c&#39;: {&#39;d&#39;: 2}}}</span>

<span class="sd">            &gt;&gt; self.set_config(&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, 99) # identical to set_config(&#39;b.d.e&#39;, 99)</span>
<span class="sd">            &gt;&gt; {&#39;a&#39;: 1, &#39;b&#39;: {&#39;c&#39;: {&#39;d&#39;: 99}}}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_update_naming</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rename_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the naming of the model variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rename_dict: dict</span>
<span class="sd">            Dictionary with the wflow variable and new output name in file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_wflow_names_inv</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">_hydromt_names_inv</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">for</span> <span class="n">wflow_var</span><span class="p">,</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="n">rename_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">wflow_var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># Find the previous name in self._WFLOW_NAMES</span>
            <span class="n">old_name</span> <span class="o">=</span> <span class="n">_wflow_names_inv</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">wflow_var</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">old_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Rename the variable in self._WFLOW_NAMES</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">old_name</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">wflow_var</span>
                <span class="c1"># Rename the variable in self._MAPS</span>
                <span class="n">hydromt_name</span> <span class="o">=</span> <span class="n">_hydromt_names_inv</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">old_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">hydromt_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="n">hydromt_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wflow variable </span><span class="si">{</span><span class="n">wflow_var</span><span class="si">}</span><span class="s2"> not found, check spelling.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_config_variable_name</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data_vars</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">data_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="s2">&quot;static&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the variable names in the config file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_vars: list of str</span>
<span class="sd">            List of variable names to update in the config file.</span>
<span class="sd">        data_type: str, optional</span>
<span class="sd">            Type of data (static, forcing, cyclic, None), by default &quot;static&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_vars</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_vars</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">data_vars</span>
        <span class="n">_prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;input.</span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">data_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;input&quot;</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">data_vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="p">:</span>
                <span class="c1"># Get the name from the Wflow variable name</span>
                <span class="n">wflow_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
                <span class="c1"># Update the config variable name</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_prefix</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">wflow_var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
            <span class="c1"># else not a wflow variable</span>
            <span class="c1"># (spelling mistakes should have been checked in _update_naming)</span>

    <span class="c1">## WFLOW specific data and method</span>
    <span class="nd">@property</span>
    <span class="c1"># Move to core Model API ?</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a dictionary of pandas.DataFrames representing wflow csv files.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_tables</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">flwdir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the pyflwdir.FlwdirRaster object parsed from wflow ldd.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flwdir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_flwdir</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flwdir</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_flwdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s2">&quot;infer&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse pyflwdir.FlwdirRaster object parsed from the wflow ldd.&quot;&quot;&quot;</span>
        <span class="n">flwdir_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;flwdir&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flwdir</span> <span class="o">=</span> <span class="n">flw</span><span class="o">.</span><span class="n">flwdir_from_da</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">flwdir_name</span><span class="p">],</span>
            <span class="n">ftype</span><span class="o">=</span><span class="n">ftype</span><span class="p">,</span>
            <span class="n">check_ftype</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="c1">## WFLOW specific modification (clip for now) methods</span>

<div class="viewcode-block" id="WflowModel.clip_staticmaps">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.clip_staticmaps.html#hydromt_wflow.WflowModel.clip_staticmaps">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">clip_staticmaps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="mi">4326</span><span class="p">,</span> <span class="n">inverse_clip</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clip staticmaps to subbasin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        region : dict</span>
<span class="sd">            See :meth:`models.wflow.WflowModel.setup_basemaps`</span>
<span class="sd">        buffer : int, optional</span>
<span class="sd">            Buffer around subbasin in number of pixels, by default 0</span>
<span class="sd">        align : float, optional</span>
<span class="sd">            Align bounds of region to raster with resolution &lt;align&gt;, by default None</span>
<span class="sd">        crs: int, optional</span>
<span class="sd">            Default crs of the grid to clip.</span>
<span class="sd">        inverse_clip: bool, optional</span>
<span class="sd">            Flag to perform &quot;inverse clipping&quot;: removing an upstream part of the model</span>
<span class="sd">            instead of the subbasin itself, by default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataSet</span>
<span class="sd">            Clipped grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">basins_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]</span>
        <span class="n">flwdir_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;flwdir&quot;</span><span class="p">]</span>

        <span class="c1"># translate basin and outlet kinds to geom</span>
        <span class="c1"># get basin geometry and clip data</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">region</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;subbasin&quot;</span><span class="p">]:</span>
            <span class="c1"># parse_region_basin does not return xy, only geom...</span>
            <span class="c1"># should be fixed in core</span>
            <span class="n">region_kwargs</span> <span class="o">=</span> <span class="n">_parse_region_value</span><span class="p">(</span>
                <span class="n">region</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">kind</span><span class="p">),</span>
                <span class="n">data_catalog</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">region_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
            <span class="n">geom</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_basin_geometry</span><span class="p">(</span>
                <span class="n">ds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                <span class="n">basins_name</span><span class="o">=</span><span class="n">basins_name</span><span class="p">,</span>
                <span class="n">flwdir_name</span><span class="o">=</span><span class="n">flwdir_name</span><span class="p">,</span>
                <span class="o">**</span><span class="n">region</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;bbox&quot;</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Kind &#39;bbox&#39; for the region is not recommended as it can lead &quot;</span>
                <span class="s2">&quot;to mistakes in the catchment delineation. Use carefully.&quot;</span>
            <span class="p">)</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">processes</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">parse_region_bbox</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;geom&quot;</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Kind &#39;geom&#39; for the region is not recommended as it can lead &quot;</span>
                <span class="s2">&quot;to mistakes in the catchment delineation. Use carefully.&quot;</span>
            <span class="p">)</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">processes</span><span class="o">.</span><span class="n">region</span><span class="o">.</span><span class="n">parse_region_geom</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;wflow region kind not understood or supported: </span><span class="si">{</span><span class="n">kind</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Use &#39;basin&#39;, &#39;subbasin&#39;, &#39;bbox&#39; or &#39;geom&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Remove upstream part from model</span>
        <span class="k">if</span> <span class="n">inverse_clip</span><span class="p">:</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basins</span><span class="o">.</span><span class="n">overlay</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;difference&quot;</span><span class="p">)</span>
        <span class="c1"># clip based on subbasin args, geom or bbox</span>
        <span class="n">ds_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">clip_geom</span><span class="p">(</span>
            <span class="n">geom</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span>
        <span class="p">)</span>
        <span class="n">ds_grid</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_grid</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">geometry_mask</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
        <span class="n">ds_grid</span><span class="p">[</span><span class="n">basins_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_grid</span><span class="p">[</span><span class="n">basins_name</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">ds_grid</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">basins_name</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">nodata</span>
        <span class="p">)</span>
        <span class="n">ds_grid</span><span class="p">[</span><span class="n">basins_name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">_FillValue</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">basins_name</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">nodata</span>
        <span class="p">)</span>

        <span class="c1"># Update flwdir grid and geoms</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_grid</span><span class="p">)</span>

        <span class="c1"># add pits at edges after clipping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flwdir</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># make sure old flwdir object is removed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;flwdir&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="s2">&quot;ldd&quot;</span><span class="p">)</span>

        <span class="c1"># Reinitiliase geoms and re-create basins/rivers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geoms</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rivers</span>

        <span class="c1"># Update reservoir and lakes</span>
        <span class="n">remove_reservoir</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_area_id&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">reservoir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_area_id&quot;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">reservoir</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">remove_reservoir</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">remove_maps</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_area_id&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_outlet_id&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_area&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_demand&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_target_full_fraction&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_target_min_fraction&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_max_release&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_max_volume&quot;</span><span class="p">],</span>
                <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">remove_maps</span><span class="p">)</span>

        <span class="n">remove_lake</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lake_area_id&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">lake</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lake_area_id&quot;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">lake</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">remove_lake</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">remove_maps</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lake_area_id&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lake_outlet_id&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lake_lower_id&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lake_storage_curve&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lake_rating_curve&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lake_area&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lake_initial_depth&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;meta_lake_mean_outflow&quot;</span><span class="p">,</span>  <span class="c1"># this is a hydromt meta map</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lake_outflow_threshold&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lake_b&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lake_e&quot;</span><span class="p">],</span>
                <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">remove_maps</span><span class="p">)</span>

            <span class="c1"># Update tables</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lake</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">k</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">])</span>
            <span class="p">}</span>

        <span class="c1"># Update config</span>
        <span class="c1"># Remove the absolute path and if needed remove lakes and reservoirs</span>
        <span class="k">if</span> <span class="n">remove_reservoir</span><span class="p">:</span>
            <span class="c1"># change reservoir__flag = true to false</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.reservoir__flag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="c1"># remove states</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;state.variables.reservoir_water__instantaneous_volume&quot;</span><span class="p">)</span>
                <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">][</span><span class="s2">&quot;variables&quot;</span><span class="p">][</span>
                    <span class="s2">&quot;reservoir_water__instantaneous_volume&quot;</span>
                <span class="p">]</span>

        <span class="k">if</span> <span class="n">remove_lake</span><span class="p">:</span>
            <span class="c1"># change lake__flag = true to false</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.lake__flag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="c1"># remove states</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
                    <span class="s2">&quot;state.variables.lake_water_surface__instantaneous_elevation&quot;</span>
                <span class="p">)</span>
                <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">][</span><span class="s2">&quot;variables&quot;</span><span class="p">][</span>
                    <span class="s2">&quot;lake_water_surface__instantaneous_elevation&quot;</span>
                <span class="p">]</span></div>


<div class="viewcode-block" id="WflowModel.clip_forcing">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.clip_forcing.html#hydromt_wflow.WflowModel.clip_forcing">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">clip_forcing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return clippped forcing for subbasin.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataSet</span>
<span class="sd">            Clipped forcing.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Clipping NetCDF forcing..&quot;</span><span class="p">)</span>
            <span class="n">ds_forcing</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">clip_bbox</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">bounds</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_forcing</span><span class="p">(</span><span class="n">ds_forcing</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.clip_states">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.clip_states.html#hydromt_wflow.WflowModel.clip_states">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">clip_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return clippped states for subbasin.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataSet</span>
<span class="sd">            Clipped states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Clipping NetCDF states..&quot;</span><span class="p">)</span>
            <span class="n">ds_states</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">clip_bbox</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">bounds</span>
            <span class="p">)</span>
            <span class="c1"># Check for reservoirs/lakes presence in the clipped model</span>
            <span class="n">remove_maps</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_area_id&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="n">state_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
                    <span class="s2">&quot;state.variables.reservoir_water__instantaneous_volume&quot;</span><span class="p">,</span>
                    <span class="n">fallback</span><span class="o">=</span><span class="s2">&quot;reservoir_instantaneous_volume&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">state_name</span> <span class="ow">in</span> <span class="n">ds_states</span><span class="p">:</span>
                    <span class="n">remove_maps</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">state_name</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lake_area_id&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="n">state_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
                    <span class="s2">&quot;state.variables.lake_water_surface__instantaneous_elevation&quot;</span><span class="p">,</span>
                    <span class="n">fallback</span><span class="o">=</span><span class="s2">&quot;lake_instantaneous_water_level&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">state_name</span> <span class="ow">in</span> <span class="n">ds_states</span><span class="p">:</span>
                    <span class="n">remove_maps</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">state_name</span><span class="p">])</span>
            <span class="n">ds_states</span> <span class="o">=</span> <span class="n">ds_states</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">remove_maps</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_states</span><span class="p">(</span><span class="n">ds_states</span><span class="p">)</span></div>
</div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright Deltares.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>