
<!DOCTYPE html>


<html lang="en" data-content_root="../../" data-theme="light">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hydromt_wflow.wflow &#8212; HydroMT Wflow  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "light";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=3ee479438cf8b5e0d341" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=87e54e7c" />
    <link rel="stylesheet" type="text/css" href="../../_static/theme-deltares.css?v=5ca2d357" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=3ee479438cf8b5e0d341" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=3ee479438cf8b5e0d341" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=3ee479438cf8b5e0d341"></script>

    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/hydromt_wflow/wflow';</script>
    <link rel="icon" href="../../_static/hydromt-icon.svg"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="light">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
    
    <img src="../../_static/hydromt-icon.svg" class="logo__image only-light" alt=""/>
    <script>document.write(`<img src="../../_static/hydromt-icon.svg" class="logo__image only-dark" alt=""/>`);</script>
  
  
    <p class="title logo__title">HydroMT Wflow</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav class="navbar-nav">
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../../getting_started/intro.html">
    Getting started
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../../user_guide/intro.html">
    User guide
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../../api.html">
    API reference
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../../dev_guide/intro.html">
    Developments
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-external" href="https://deltares.github.io/hydromt/latest/index.html">
    HydroMT core
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/Deltares/hydromt_wflow" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fab fa-github fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://deltares.github.io/Wflow.jl/dev/" title="Wflow" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../_static/wflow_logo.png" class="icon-link-image" alt="Wflow"/></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.deltares.nl/en/" title="Deltares" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../_static/deltares-blue.svg" class="icon-link-image" alt="Deltares"/></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav class="navbar-nav">
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../../getting_started/intro.html">
    Getting started
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../../user_guide/intro.html">
    User guide
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../../api.html">
    API reference
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-internal" href="../../dev_guide/intro.html">
    Developments
  </a>
</li>


<li class="nav-item pst-header-nav-item">
  <a class="nav-link nav-external" href="https://deltares.github.io/hydromt/latest/index.html">
    HydroMT core
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/Deltares/hydromt_wflow" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fab fa-github fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://deltares.github.io/Wflow.jl/dev/" title="Wflow" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../_static/wflow_logo.png" class="icon-link-image" alt="Wflow"/></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.deltares.nl/en/" title="Deltares" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../_static/deltares-blue.svg" class="icon-link-image" alt="Deltares"/></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">hydromt_wflow.wflow</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for hydromt_wflow.wflow</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Implement Wflow model class.&quot;&quot;&quot;</span>

<span class="c1"># Implement model class following model API</span>

<span class="kn">import</span> <span class="nn">codecs</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">basename</span><span class="p">,</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">isdir</span><span class="p">,</span> <span class="n">isfile</span><span class="p">,</span> <span class="n">join</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>

<span class="c1"># from dask.distributed import LocalCluster, Client, performance_report</span>
<span class="kn">import</span> <span class="nn">hydromt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pyflwdir</span>
<span class="kn">import</span> <span class="nn">pyproj</span>
<span class="kn">import</span> <span class="nn">shapely</span>
<span class="kn">import</span> <span class="nn">toml</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">from</span> <span class="nn">dask.diagnostics</span> <span class="kn">import</span> <span class="n">ProgressBar</span>
<span class="kn">from</span> <span class="nn">hydromt</span> <span class="kn">import</span> <span class="n">flw</span>
<span class="kn">from</span> <span class="nn">hydromt.models.model_grid</span> <span class="kn">import</span> <span class="n">GridModel</span>
<span class="kn">from</span> <span class="nn">hydromt.nodata</span> <span class="kn">import</span> <span class="n">NoDataStrategy</span>
<span class="kn">from</span> <span class="nn">pyflwdir</span> <span class="kn">import</span> <span class="n">core_conversion</span><span class="p">,</span> <span class="n">core_d8</span><span class="p">,</span> <span class="n">core_ldd</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">box</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">DATADIR</span><span class="p">,</span> <span class="n">utils</span><span class="p">,</span> <span class="n">workflows</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;WflowModel&quot;</span><span class="p">]</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="WflowModel">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.html#hydromt_wflow.WflowModel">[docs]</a>
<span class="k">class</span> <span class="nc">WflowModel</span><span class="p">(</span><span class="n">GridModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wflow model class.&quot;&quot;&quot;</span>

    <span class="n">_NAME</span> <span class="o">=</span> <span class="s2">&quot;wflow&quot;</span>
    <span class="n">_CONF</span> <span class="o">=</span> <span class="s2">&quot;wflow_sbm.toml&quot;</span>
    <span class="n">_CLI_ARGS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;region&quot;</span><span class="p">:</span> <span class="s2">&quot;setup_basemaps&quot;</span><span class="p">,</span> <span class="s2">&quot;res&quot;</span><span class="p">:</span> <span class="s2">&quot;setup_basemaps&quot;</span><span class="p">}</span>
    <span class="n">_DATADIR</span> <span class="o">=</span> <span class="n">DATADIR</span>
    <span class="n">_GEOMS</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_MAPS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;flwdir&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_ldd&quot;</span><span class="p">,</span>
        <span class="s2">&quot;elevtn&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_dem&quot;</span><span class="p">,</span>
        <span class="s2">&quot;subelv&quot;</span><span class="p">:</span> <span class="s2">&quot;dem_subgrid&quot;</span><span class="p">,</span>
        <span class="s2">&quot;uparea&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_uparea&quot;</span><span class="p">,</span>
        <span class="s2">&quot;strord&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_streamorder&quot;</span><span class="p">,</span>
        <span class="s2">&quot;basins&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_subcatch&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rivlen&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_riverlength&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rivmsk&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_river&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rivwth&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_riverwidth&quot;</span><span class="p">,</span>
        <span class="s2">&quot;lndslp&quot;</span><span class="p">:</span> <span class="s2">&quot;Slope&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rivslp&quot;</span><span class="p">:</span> <span class="s2">&quot;RiverSlope&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rivdph&quot;</span><span class="p">:</span> <span class="s2">&quot;RiverDepth&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rivman&quot;</span><span class="p">:</span> <span class="s2">&quot;N_River&quot;</span><span class="p">,</span>
        <span class="s2">&quot;gauges&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_gauges&quot;</span><span class="p">,</span>
        <span class="s2">&quot;landuse&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_landuse&quot;</span><span class="p">,</span>
        <span class="s2">&quot;resareas&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_reservoirareas&quot;</span><span class="p">,</span>
        <span class="s2">&quot;reslocs&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_reservoirlocs&quot;</span><span class="p">,</span>
        <span class="s2">&quot;lakeareas&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_lakeareas&quot;</span><span class="p">,</span>
        <span class="s2">&quot;lakelocs&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_lakelocs&quot;</span><span class="p">,</span>
        <span class="s2">&quot;glacareas&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_glacierareas&quot;</span><span class="p">,</span>
        <span class="s2">&quot;glacfracs&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_glacierfrac&quot;</span><span class="p">,</span>
        <span class="s2">&quot;glacstore&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_glacierstore&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_FOLDERS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;staticgeoms&quot;</span><span class="p">,</span>
        <span class="s2">&quot;instate&quot;</span><span class="p">,</span>
        <span class="s2">&quot;run_default&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">_CATALOGS</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">_DATADIR</span><span class="p">,</span> <span class="s2">&quot;parameters_data.yml&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="WflowModel.__init__">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.html#hydromt_wflow.WflowModel.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="n">config_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data_libs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="o">**</span><span class="n">artifact_keys</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">data_libs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_libs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lib</span><span class="p">,</span> <span class="n">version</span> <span class="ow">in</span> <span class="n">artifact_keys</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Adding a predefined data catalog as key-word argument is deprecated, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;add the catalog as &#39;</span><span class="si">{</span><span class="n">lib</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">version</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                <span class="s2">&quot; to the data_libs list instead.&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">version</span><span class="p">:</span>  <span class="c1"># False or None</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">lib</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;=</span><span class="si">{</span><span class="n">version</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">data_libs</span> <span class="o">=</span> <span class="p">[</span><span class="n">lib</span><span class="p">]</span> <span class="o">+</span> <span class="n">data_libs</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">config_fn</span><span class="o">=</span><span class="n">config_fn</span><span class="p">,</span>
            <span class="n">data_libs</span><span class="o">=</span><span class="n">data_libs</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># wflow specific</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intbl</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flwdir</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">from_yml</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_CATALOGS</span><span class="p">)</span>
        <span class="c1"># To be deprecated from v0.6.0 onwards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_staticmaps</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_staticgeoms</span> <span class="o">=</span> <span class="kc">None</span></div>


    <span class="c1"># COMPONENTS</span>
<div class="viewcode-block" id="WflowModel.setup_basemaps">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_basemaps.html#hydromt_wflow.WflowModel.setup_basemaps">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_basemaps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">region</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">hydrography_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">],</span>
        <span class="n">basin_index_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">res</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">120.0</span><span class="p">,</span>
        <span class="n">upscale_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ihu&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the DEM and flow direction for a Wflow model.</span>

<span class="sd">        Setup basemaps sets the `region` of interest and `res`</span>
<span class="sd">        (resolution in degrees) of the model.</span>
<span class="sd">        All DEM and flow direction related maps are then build.</span>

<span class="sd">        E.g. of `region` argument for a subbasin based on a point and snapped using</span>
<span class="sd">        upstream area threshold in `hydrography_fn`, where the maximum boundary box of</span>
<span class="sd">        the output subbasin is known:</span>
<span class="sd">        region = {&#39;subbasin&#39;: [x,y], &#39;uparea&#39;: 10, &#39;bounds&#39;: [xmin, ymin, xmax, ymax]}</span>

<span class="sd">        (Sub)Basin delination is done using hydromt.workflows.get_basin_geometry method.</span>
<span class="sd">        Because the delineation is computed from the flow direction data in memory, to</span>
<span class="sd">        avoid memory error when using large datasets in `hydrography_fn`, the user can</span>
<span class="sd">        either supply &#39;bounds&#39; in `region` or a basin index dataset in `basin_index_fn`</span>
<span class="sd">        to limit the flow direction data to the region of interest. The basin index</span>
<span class="sd">        dataset is a GeoDataframe containing either basins polygons or bounding boxes of</span>
<span class="sd">        basin boundaries. To select the correct basins, basin ID &#39;basins&#39; in</span>
<span class="sd">        `hydrography_fn` and `basin_index_fn` should match.</span>

<span class="sd">        If the model resolution is larger than the source data resolution,</span>
<span class="sd">        the flow direction is upscaled using the `upscale_method`, by default the</span>
<span class="sd">        Iterative Hydrography Upscaling (IHU).</span>

<span class="sd">        The default `hydrography_fn` is &quot;merit_hydro&quot;</span>
<span class="sd">        (`MERIT hydro &lt;http://hydro.iis.u-tokyo.ac.jp/~yamadai/MERIT_Hydro/index.html&gt;`_</span>
<span class="sd">        at 3 arcsec resolution).</span>
<span class="sd">        Alternative sources include &quot;merit_hydro_1k&quot; at 30 arcsec resolution.</span>
<span class="sd">        Users can also supply their own elevation and flow direction data</span>
<span class="sd">        in any CRS and not only EPSG:4326.</span>

<span class="sd">        Note that in order to define the region, using points or bounding box,</span>
<span class="sd">        the coordinates of the points / bounding box</span>
<span class="sd">        should be in the same CRS than the hydrography data.</span>
<span class="sd">        The wflow model will then also be in the same CRS than the</span>
<span class="sd">        hydrography data in order to avoid assumptions and reprojection errors.</span>
<span class="sd">        If the user wishes to use a different CRS,</span>
<span class="sd">        we recommend first to reproject the hydrography data seperately,</span>
<span class="sd">        before calling hydromt build.</span>
<span class="sd">        You can find examples on how to reproject or prepare hydrography data in the</span>
<span class="sd">        `prepare flow directions example notebok</span>
<span class="sd">        &lt;https://deltares.github.io/hydromt_wflow/latest/_examples/prepare_ldd.html&gt;`_.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **wflow_ldd** map: flow direction in LDD format [-]</span>
<span class="sd">        * **wflow_subcatch** map: basin ID map [-]</span>
<span class="sd">        * **wflow_uparea** map: upstream area [km2]</span>
<span class="sd">        * **wflow_streamorder** map: Strahler stream order [-]</span>
<span class="sd">        * **wflow_dem** map: average elevation [m+REF]</span>
<span class="sd">        * **dem_subgrid** map: subgrid outlet elevation [m+REF]</span>
<span class="sd">        * **Slope** map: average land surface slope [m/m]</span>
<span class="sd">        * **basins** geom: basins boundary vector</span>
<span class="sd">        * **region** geom: region boundary vector</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        region : dict</span>
<span class="sd">            Dictionary describing region of interest.</span>
<span class="sd">            See :py:meth:`hydromt.workflows.basin_mask.parse_region()` for all options</span>
<span class="sd">        hydrography_fn : str, xarray.Dataset</span>
<span class="sd">            Name of RasterDataset source for basemap parameters.</span>

<span class="sd">            * Required variables: &#39;flwdir&#39; [LLD or D8 or NEXTXY], &#39;elevtn&#39; [m+REF]</span>

<span class="sd">            * Required variables if used with `basin_index_fn`: &#39;basins&#39; [-]</span>

<span class="sd">            * Required variables if used for snapping in `region`: &#39;uparea&#39; [km2],</span>
<span class="sd">                &#39;strord&#39; [-]</span>

<span class="sd">            * Optional variables: &#39;lndslp&#39; [m/m], &#39;mask&#39; [bool]</span>
<span class="sd">        basin_index_fn : str, geopandas.GeoDataFrame, optional</span>
<span class="sd">            Name of GeoDataFrame source for basin_index data linked to hydrography_fn.</span>

<span class="sd">            * Required variables: &#39;basid&#39; [-]</span>
<span class="sd">        res : float, optional</span>
<span class="sd">            Output model resolution</span>
<span class="sd">        upscale_method : {&#39;ihu&#39;, &#39;eam&#39;, &#39;dmm&#39;}, optional</span>
<span class="sd">            Upscaling method for flow direction data, by default &#39;ihu&#39;.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hydromt.workflows.parse_region</span>
<span class="sd">        hydromt.workflows.get_basin_geometry</span>
<span class="sd">        workflows.hydrography</span>
<span class="sd">        workflows.topography</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing base hydrography basemaps.&quot;</span><span class="p">)</span>
        <span class="c1"># retrieve global data (lazy!)</span>
        <span class="n">ds_org</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span><span class="n">hydrography_fn</span><span class="p">)</span>

        <span class="c1"># Check on resolution (degree vs meter) depending on ds_org res/crs</span>
        <span class="n">scale_ratio</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">res</span> <span class="o">/</span> <span class="n">ds_org</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">scale_ratio</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The model resolution </span><span class="si">{</span><span class="n">res</span><span class="si">}</span><span class="s2"> should be </span><span class="se">\</span>
<span class="s2">larger than the </span><span class="si">{</span><span class="n">hydrography_fn</span><span class="si">}</span><span class="s2"> resolution </span><span class="si">{</span><span class="n">ds_org</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">ds_org</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">is_geographic</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># 111 km</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The model resolution </span><span class="si">{</span><span class="n">res</span><span class="si">}</span><span class="s2"> should be smaller than 1 degree </span><span class="se">\</span>
<span class="s2">(111km) for geographic coordinate systems. &quot;</span>
                    <span class="s2">&quot;Make sure you provided res in degree rather than in meters.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># get basin geometry and clip data</span>
        <span class="n">kind</span><span class="p">,</span> <span class="n">region</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">workflows</span><span class="o">.</span><span class="n">parse_region</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;subbasin&quot;</span><span class="p">,</span> <span class="s2">&quot;outlet&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">basin_index_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bas_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="p">[</span><span class="n">basin_index_fn</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bas_index</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">geom</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">workflows</span><span class="o">.</span><span class="n">get_basin_geometry</span><span class="p">(</span>
                <span class="n">ds</span><span class="o">=</span><span class="n">ds_org</span><span class="p">,</span>
                <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                <span class="n">basin_index</span><span class="o">=</span><span class="n">bas_index</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                <span class="o">**</span><span class="n">region</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;bbox&quot;</span> <span class="ow">in</span> <span class="n">region</span><span class="p">:</span>
            <span class="n">bbox</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bbox&quot;</span><span class="p">)</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="p">[</span><span class="n">box</span><span class="p">(</span><span class="o">*</span><span class="n">bbox</span><span class="p">)],</span> <span class="n">crs</span><span class="o">=</span><span class="mi">4326</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;geom&quot;</span> <span class="ow">in</span> <span class="n">region</span><span class="p">:</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geom&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;wflow region argument not understood: </span><span class="si">{</span><span class="n">region</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">geom</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;wflow region geometry has no CRS&quot;</span><span class="p">)</span>

        <span class="c1"># Set the basins geometry</span>
        <span class="n">ds_org</span> <span class="o">=</span> <span class="n">ds_org</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">clip_geom</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">res</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">ds_org</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_org</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">geometry_mask</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adding basins vector to geoms.&quot;</span><span class="p">)</span>

        <span class="c1"># Set name based on scale_factor</span>
        <span class="k">if</span> <span class="n">scale_ratio</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;basins_highres&quot;</span><span class="p">)</span>

        <span class="c1"># setup hydrography maps and set staticmap attribute with renamed maps</span>
        <span class="n">ds_base</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">hydrography</span><span class="p">(</span>
            <span class="n">ds</span><span class="o">=</span><span class="n">ds_org</span><span class="p">,</span>
            <span class="n">res</span><span class="o">=</span><span class="n">res</span><span class="p">,</span>
            <span class="n">xy</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span>
            <span class="n">upscale_method</span><span class="o">=</span><span class="n">upscale_method</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Convert flow direction from d8 to ldd format</span>
        <span class="n">flwdir_data</span> <span class="o">=</span> <span class="n">ds_base</span><span class="p">[</span><span class="s2">&quot;flwdir&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>  <span class="c1"># force dtype</span>
        <span class="c1"># if d8 convert to ldd</span>
        <span class="k">if</span> <span class="n">core_d8</span><span class="o">.</span><span class="n">isvalid</span><span class="p">(</span><span class="n">flwdir_data</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">core_conversion</span><span class="o">.</span><span class="n">d8_to_ldd</span><span class="p">(</span><span class="n">flwdir_data</span><span class="p">)</span>
            <span class="n">da_flwdir</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;flwdir&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">coords</span><span class="o">=</span><span class="n">ds_base</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="n">ds_base</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
                <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                    <span class="n">long_name</span><span class="o">=</span><span class="s2">&quot;ldd flow direction&quot;</span><span class="p">,</span>
                    <span class="n">_FillValue</span><span class="o">=</span><span class="n">core_ldd</span><span class="o">.</span><span class="n">_mv</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="n">ds_base</span><span class="p">[</span><span class="s2">&quot;flwdir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">da_flwdir</span>
        <span class="c1"># Rename and add to grid</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_base</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_base</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
        <span class="c1"># Call basins once to set it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basins</span>

        <span class="c1"># setup topography maps</span>
        <span class="n">ds_topo</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">topography</span><span class="p">(</span>
            <span class="n">ds</span><span class="o">=</span><span class="n">ds_org</span><span class="p">,</span> <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;average&quot;</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span>
        <span class="p">)</span>
        <span class="n">ds_topo</span><span class="p">[</span><span class="s2">&quot;lndslp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ds_topo</span><span class="p">[</span><span class="s2">&quot;lndslp&quot;</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_topo</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_topo</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
        <span class="c1"># set basin geometry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adding region vector to geoms.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;region&quot;</span><span class="p">)</span>

        <span class="c1"># update toml for degree/meters if needed</span>
        <span class="k">if</span> <span class="n">ds_base</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">is_projected</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.sizeinmetres&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_rivers">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_rivers.html#hydromt_wflow.WflowModel.setup_rivers">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_rivers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hydrography_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">],</span>
        <span class="n">river_geom_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">river_upa</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">rivdph_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;powlaw&quot;</span><span class="p">,</span>
        <span class="n">slope_len</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2e3</span><span class="p">,</span>
        <span class="n">min_rivlen_ratio</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">min_rivdph</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">min_rivwth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">smooth_len</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5e3</span><span class="p">,</span>
        <span class="n">rivman_mapping_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;roughness_river_mapping_default&quot;</span><span class="p">,</span>
        <span class="n">elevtn_map</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;wflow_dem&quot;</span><span class="p">,</span>
        <span class="n">river_routing</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;kinematic-wave&quot;</span><span class="p">,</span>
        <span class="n">connectivity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set all river parameter maps.</span>

<span class="sd">        The river mask is defined by all cells with a mimimum upstream area threshold</span>
<span class="sd">        ``river_upa`` [km2].</span>

<span class="sd">        The river length is defined as the distance from the subgrid outlet pixel to</span>
<span class="sd">        the next upstream subgrid outlet pixel. The ``min_rivlen_ratio`` is the minimum</span>
<span class="sd">        global river length to avg. cell resolution ratio and is used as a threshold in</span>
<span class="sd">        window based smoothing of river length.</span>

<span class="sd">        The river slope is derived from the subgrid elevation difference between pixels</span>
<span class="sd">        at a half distance ``slope_len`` [m] up-</span>
<span class="sd">        and downstream from the subgrid outlet pixel.</span>

<span class="sd">        The river manning roughness coefficient is derived based on reclassification</span>
<span class="sd">        of the streamorder map using a lookup table ``rivman_mapping_fn``.</span>

<span class="sd">        The river width is derived from the nearest river segment in ``river_geom_fn``.</span>
<span class="sd">        Data gaps are filled by the nearest valid upstream value and averaged along</span>
<span class="sd">        the flow directions over a length ``smooth_len`` [m]</span>

<span class="sd">        The river depth is calculated using the ``rivdph_method``, by default powlaw:</span>
<span class="sd">        h = hc*Qbf**hp, which is based on qbankfull discharge from the nearest river</span>
<span class="sd">        segment in ``river_geom_fn`` and takes optional arguments for the hc</span>
<span class="sd">        (default = 0.27) and hp (default = 0.30) parameters. For other methods see</span>
<span class="sd">        :py:meth:`hydromt.workflows.river_depth`.</span>

<span class="sd">        If ``river_routing`` is set to &quot;local-inertial&quot;, the bankfull elevation map</span>
<span class="sd">        can be conditioned based on the average cell elevation (&quot;wflow_dem&quot;)</span>
<span class="sd">        or subgrid outlet pixel elevation (&quot;dem_subgrid&quot;).</span>
<span class="sd">        The subgrid elevation might provide a better representation</span>
<span class="sd">        of the river elevation profile, however in combination with</span>
<span class="sd">        local-inertial land routing (see :py:meth:`setup_floodplains`)</span>
<span class="sd">        the subgrid elevation will likely overestimate the floodplain storage capacity.</span>
<span class="sd">        Note that the same input elevation map should be used for river bankfull</span>
<span class="sd">        elevation and land elevation when using local-inertial land routing.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **wflow_river** map: river mask [-]</span>
<span class="sd">        * **wflow_riverlength** map: river length [m]</span>
<span class="sd">        * **wflow_riverwidth** map: river width [m]</span>
<span class="sd">        * **RiverDepth** map: bankfull river depth [m]</span>
<span class="sd">        * **RiverSlope** map: river slope [m/m]</span>
<span class="sd">        * **N_River** map: Manning coefficient for river cells [s.m^1/3]</span>
<span class="sd">        * **rivers** geom: river vector based on wflow_river mask</span>
<span class="sd">        * **hydrodem** map: hydrologically conditioned elevation [m+REF]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hydrography_fn : str, Path, xarray.Dataset</span>
<span class="sd">            Name of RasterDataset source for hydrography data.</span>
<span class="sd">            Must be same as setup_basemaps for consistent results.</span>

<span class="sd">            * Required variables: &#39;flwdir&#39; [LLD or D8 or NEXTXY], &#39;uparea&#39; [km2],</span>
<span class="sd">                &#39;elevtn&#39;[m+REF]</span>
<span class="sd">            * Optional variables: &#39;rivwth&#39; [m], &#39;qbankfull&#39; [m3/s]</span>
<span class="sd">        river_geom_fn : str, Path, geopandas.GeoDataFrame, optional</span>
<span class="sd">            Name of GeoDataFrame source for river data.</span>

<span class="sd">            * Required variables: &#39;rivwth&#39; [m], &#39;qbankfull&#39; [m3/s]</span>
<span class="sd">        river_upa : float, optional</span>
<span class="sd">            Minimum upstream area threshold for the river map [km2]. By default 30.0</span>
<span class="sd">        slope_len : float, optional</span>
<span class="sd">            Length over which the river slope is calculated [km]. By default 2.0</span>
<span class="sd">        min_rivlen_ratio: float, optional</span>
<span class="sd">            Ratio of cell resolution used minimum length threshold in a moving</span>
<span class="sd">            window based smoothing of river length, by default 0.0</span>
<span class="sd">            The river length smoothing is skipped if `min_riverlen_ratio` = 0.</span>
<span class="sd">            For details about the river length smoothing,</span>
<span class="sd">            see :py:meth:`pyflwdir.FlwdirRaster.smooth_rivlen`</span>
<span class="sd">        rivdph_method : {&#39;gvf&#39;, &#39;manning&#39;, &#39;powlaw&#39;}</span>
<span class="sd">            see :py:meth:`hydromt.workflows.river_depth` for details, by default \</span>
<span class="sd">                &quot;powlaw&quot;</span>
<span class="sd">        river_routing : {&#39;kinematic-wave&#39;, &#39;local-inertial&#39;}</span>
<span class="sd">            Routing methodology to be used, by default &quot;kinematic-wave&quot;.</span>
<span class="sd">        smooth_len : float, optional</span>
<span class="sd">            Length [m] over which to smooth the output river width and depth,</span>
<span class="sd">            by default 5e3</span>
<span class="sd">        min_rivdph : float, optional</span>
<span class="sd">            Minimum river depth [m], by default 1.0</span>
<span class="sd">        min_rivwth : float, optional</span>
<span class="sd">            Minimum river width [m], by default 30.0</span>
<span class="sd">        elevtn_map : str, optional</span>
<span class="sd">            Name of the elevation map in the current WflowModel.grid.</span>
<span class="sd">            By default &quot;wflow_dem&quot;</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        workflows.river_bathymetry</span>
<span class="sd">        hydromt.workflows.river_depth</span>
<span class="sd">        pyflwdir.FlwdirRaster.river_depth</span>
<span class="sd">        setup_floodplains</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing river maps.&quot;</span><span class="p">)</span>

        <span class="c1"># Check that river_upa threshold is bigger than the maximum uparea in the grid</span>
        <span class="k">if</span> <span class="n">river_upa</span> <span class="o">&gt;</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;uparea&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">max</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;river_upa threshold </span><span class="si">{</span><span class="n">river_upa</span><span class="si">}</span><span class="s2"> should be larger than the maximum </span><span class="se">\</span>
<span class="s2">uparea in the grid </span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s1">&#39;uparea&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span><span class="si">}</span><span class="s2"> in order to create </span><span class="se">\</span>
<span class="s2">river cells.&quot;</span>
            <span class="p">)</span>

        <span class="n">rivdph_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gvf&quot;</span><span class="p">,</span> <span class="s2">&quot;manning&quot;</span><span class="p">,</span> <span class="s2">&quot;powlaw&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rivdph_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rivdph_methods</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">rivdph_method</span><span class="si">}</span><span class="s1">&quot; unknown. Select from </span><span class="si">{</span><span class="n">rivdph_methods</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">routing_options</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;kinematic-wave&quot;</span><span class="p">,</span> <span class="s2">&quot;local-inertial&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">river_routing</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">routing_options</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;river_routing=&quot;</span><span class="si">{</span><span class="n">river_routing</span><span class="si">}</span><span class="s1">&quot; unknown. </span><span class="se">\</span>
<span class="s1">Select from </span><span class="si">{</span><span class="n">routing_options</span><span class="si">}</span><span class="s1">.&#39;</span>
            <span class="p">)</span>

        <span class="c1"># read data</span>
        <span class="n">ds_hydro</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">hydrography_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">10</span>
        <span class="p">)</span>
        <span class="n">ds_hydro</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_hydro</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">geometry_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>

        <span class="c1"># get rivmsk, rivlen, rivslp</span>
        <span class="c1"># read model maps and revert wflow to hydromt map names</span>
        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">}</span>
        <span class="n">ds_riv</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">river</span><span class="p">(</span>
            <span class="n">ds</span><span class="o">=</span><span class="n">ds_hydro</span><span class="p">,</span>
            <span class="n">ds_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">river_upa</span><span class="o">=</span><span class="n">river_upa</span><span class="p">,</span>
            <span class="n">slope_len</span><span class="o">=</span><span class="n">slope_len</span><span class="p">,</span>
            <span class="n">channel_dir</span><span class="o">=</span><span class="s2">&quot;up&quot;</span><span class="p">,</span>
            <span class="n">min_rivlen_ratio</span><span class="o">=</span><span class="n">min_rivlen_ratio</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ds_riv</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_riv</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">assign_attrs</span><span class="p">(</span>
            <span class="n">river_upa</span><span class="o">=</span><span class="n">river_upa</span><span class="p">,</span> <span class="n">slope_len</span><span class="o">=</span><span class="n">slope_len</span><span class="p">,</span> <span class="n">min_rivlen_ratio</span><span class="o">=</span><span class="n">min_rivlen_ratio</span>
        <span class="p">)</span>
        <span class="n">dvars</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">,</span> <span class="s2">&quot;rivlen&quot;</span><span class="p">,</span> <span class="s2">&quot;rivslp&quot;</span><span class="p">]</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dvars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_riv</span><span class="p">[</span><span class="n">dvars</span><span class="p">]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>

        <span class="c1"># TODO make separate workflows.river_manning  method</span>
        <span class="c1"># Make N_River map from csv file with mapping</span>
        <span class="c1"># between streamorder and N_River value</span>
        <span class="n">strord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;strord&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span><span class="n">rivman_mapping_fn</span><span class="p">)</span>
        <span class="c1"># max streamorder value above which values get the same N_River value</span>
        <span class="n">max_str</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">nodata</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># if streamorder value larger than max_str, assign last value</span>
        <span class="n">strord</span> <span class="o">=</span> <span class="n">strord</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">strord</span> <span class="o">&lt;=</span> <span class="n">max_str</span><span class="p">,</span> <span class="n">max_str</span><span class="p">)</span>
        <span class="c1"># handle missing value (last row of csv is mapping of missing values)</span>
        <span class="n">strord</span> <span class="o">=</span> <span class="n">strord</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">strord</span> <span class="o">!=</span> <span class="n">strord</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span> <span class="n">nodata</span><span class="p">)</span>
        <span class="n">strord</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">set_nodata</span><span class="p">(</span><span class="n">nodata</span><span class="p">)</span>
        <span class="n">ds_nriver</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">landuse</span><span class="p">(</span>
            <span class="n">da</span><span class="o">=</span><span class="n">strord</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_nriver</span><span class="p">)</span>

        <span class="c1"># get rivdph, rivwth</span>
        <span class="c1"># while we still have setup_riverwidth one can skip river_bathymetry here</span>
        <span class="c1"># TODO make river_geom_fn required after removing setup_riverwidth</span>
        <span class="k">if</span> <span class="n">river_geom_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gdf_riv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
                <span class="n">river_geom_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span>
            <span class="p">)</span>
            <span class="c1"># reread model data to get river maps</span>
            <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">}</span>
            <span class="n">ds_riv1</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">river_bathymetry</span><span class="p">(</span>
                <span class="n">ds_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
                <span class="n">gdf_riv</span><span class="o">=</span><span class="n">gdf_riv</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">rivdph_method</span><span class="p">,</span>
                <span class="n">smooth_len</span><span class="o">=</span><span class="n">smooth_len</span><span class="p">,</span>
                <span class="n">min_rivdph</span><span class="o">=</span><span class="n">min_rivdph</span><span class="p">,</span>
                <span class="n">min_rivwth</span><span class="o">=</span><span class="n">min_rivwth</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_riv1</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_riv1</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
            <span class="c1"># update config</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.lateral.river.bankfull_depth&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivdph&quot;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adding rivers vector to geoms.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;rivers&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># remove old rivers if in geoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rivers</span>  <span class="c1"># add new rivers to geoms</span>

        <span class="c1"># Add hydrologically conditioned elevation map for the river, if required</span>
        <span class="k">if</span> <span class="n">river_routing</span> <span class="o">==</span> <span class="s2">&quot;local-inertial&quot;</span><span class="p">:</span>
            <span class="n">postfix</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;wflow_dem&quot;</span><span class="p">:</span> <span class="s2">&quot;_avg&quot;</span><span class="p">,</span> <span class="s2">&quot;dem_subgrid&quot;</span><span class="p">:</span> <span class="s2">&quot;_subgrid&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">elevtn_map</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
            <span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;hydrodem</span><span class="si">{</span><span class="n">postfix</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">ds_out</span> <span class="o">=</span> <span class="n">flw</span><span class="o">.</span><span class="n">dem_adjust</span><span class="p">(</span>
                <span class="n">da_flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;flwdir&quot;</span><span class="p">]],</span>
                <span class="n">da_elevtn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">elevtn_map</span><span class="p">],</span>
                <span class="n">da_rivmsk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]],</span>
                <span class="n">flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span>
                <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
                <span class="n">river_d8</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_out</span><span class="p">)</span>

            <span class="c1"># update toml model.river_routing</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Update wflow config model.river_routing=&quot;</span><span class="si">{</span><span class="n">river_routing</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.river_routing&quot;</span><span class="p">,</span> <span class="n">river_routing</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.lateral.river.bankfull_depth&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivdph&quot;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.lateral.river.bankfull_elevation&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.river_routing&quot;</span><span class="p">,</span> <span class="n">river_routing</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_floodplains">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_floodplains.html#hydromt_wflow.WflowModel.setup_floodplains">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_floodplains</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hydrography_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">],</span>
        <span class="n">floodplain_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="c1">### Options for 1D floodplains</span>
        <span class="n">river_upa</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">flood_depths</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">],</span>
        <span class="c1">### Options for 2D floodplains</span>
        <span class="n">elevtn_map</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;wflow_dem&quot;</span><span class="p">,</span>
        <span class="n">connectivity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add floodplain information to the model schematisation.</span>

<span class="sd">        The user can define what type of floodplains are required (1D or 2D),</span>
<span class="sd">        through the ``floodplain_type`` argument.</span>

<span class="sd">        If ``floodplain_type`` is set to &quot;1d&quot;, a floodplain profile is derived for every</span>
<span class="sd">        river cell. It adds a map with floodplain volume per flood depth,</span>
<span class="sd">        which is used in the wflow 1D floodplain schematisation.</span>

<span class="sd">        Note, it is important to use the same river uparea value as used in the</span>
<span class="sd">        :py:meth:`setup_rivers` method.</span>

<span class="sd">        If ``floodplain_type`` is set to &quot;2d&quot;, this component adds</span>
<span class="sd">        a hydrologically conditioned elevation (hydrodem) map for</span>
<span class="sd">        land routing (local-inertial). For this options, landcells need to be</span>
<span class="sd">        conditioned to D4 flow directions otherwise pits may remain in the land cells.</span>

<span class="sd">        The conditioned elevation can be based on the average cell elevation</span>
<span class="sd">        (&quot;wflow_dem&quot;) or subgrid outlet pixel elevation (&quot;dem_subgrid&quot;).</span>
<span class="sd">        Note that the subgrid elevation will likely overestimate</span>
<span class="sd">        the floodplain storage capacity.</span>

<span class="sd">        Additionally, note that the same input elevation map should be used for river</span>
<span class="sd">        bankfull elevation and land elevation when using local-inertial land routing.</span>

<span class="sd">        Requires :py:meth:`setup_rivers` to be executed beforehand</span>
<span class="sd">        (with ``river_routing`` set to &quot;local-inertial&quot;).</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **floodplain_volume** map: map with floodplain volumes, has flood depth as \</span>
<span class="sd">            third dimension [m3] (for 1D floodplains)</span>
<span class="sd">        * **hydrodem** map: hydrologically conditioned elevation [m+REF] (for 2D \</span>
<span class="sd">            floodplains)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        floodplain_type: {&quot;1d&quot;, &quot;2d&quot;}</span>
<span class="sd">            Option defining the type of floodplains, see below what arguments</span>
<span class="sd">            are related to the different floodplain types</span>
<span class="sd">        hydrography_fn : str, Path, xarray.Dataset</span>
<span class="sd">            Name of RasterDataset source for hydrography data. Must be same as</span>
<span class="sd">            setup_basemaps for consistent results.</span>

<span class="sd">            * Required variables: [&#39;flwdir&#39;, &#39;uparea&#39;, &#39;elevtn&#39;]</span>
<span class="sd">        river_upa : float, optional</span>
<span class="sd">            (1D floodplains) minimum upstream area threshold for drain in the HAND.</span>
<span class="sd">            Optional value, as it is inferred from the grid metadata,</span>
<span class="sd">            to be consistent with setup_rivers.</span>
<span class="sd">        flood_depths : tuple of float, optional</span>
<span class="sd">            (1D floodplains) flood depths at which a volume is derived.</span>
<span class="sd">            By default [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0]</span>

<span class="sd">        elevtn_map: {&quot;wflow_dem&quot;, &quot;dem_subgrid&quot;}</span>
<span class="sd">            (2D floodplains) Name of staticmap to hydrologically condition.</span>
<span class="sd">            By default &quot;wflow_dem&quot;</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        workflows.river_floodplain_volume</span>
<span class="sd">        hydromt.flw.dem_adjust</span>
<span class="sd">        pyflwdir.FlwdirRaster.dem_adjust</span>
<span class="sd">        setup_rivers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;model.river_routing&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;local-inertial&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Floodplains (1d or 2d) are currently only supported with </span><span class="se">\</span>
<span class="s2">local intertial river routing&quot;</span>
            <span class="p">)</span>

        <span class="n">r_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;1d&quot;</span><span class="p">,</span> <span class="s2">&quot;2d&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">floodplain_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r_list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;river_routing=&quot;</span><span class="si">{</span><span class="n">floodplain_type</span><span class="si">}</span><span class="s1">&quot; unknown. Select from </span><span class="si">{</span><span class="n">r_list</span><span class="si">}</span><span class="s1">.&#39;</span>
            <span class="p">)</span>

        <span class="c1"># Adjust settings based on floodplain_type selection</span>
        <span class="k">if</span> <span class="n">floodplain_type</span> <span class="o">==</span> <span class="s2">&quot;1d&quot;</span><span class="p">:</span>
            <span class="n">floodplain_1d</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">land_routing</span> <span class="o">=</span> <span class="s2">&quot;kinematic-wave&quot;</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pyflwdir</span><span class="o">.</span><span class="n">FlwdirRaster</span><span class="p">,</span> <span class="s2">&quot;ucat_volume&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;This method requires pyflwdir &gt;= 0.5.6&quot;</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing 1D river floodplain_volume map.&quot;</span><span class="p">)</span>

            <span class="c1"># read data</span>
            <span class="n">ds_hydro</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">hydrography_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">10</span>
            <span class="p">)</span>
            <span class="n">ds_hydro</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_hydro</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">geometry_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>

            <span class="c1"># try to get river uparea from grid, throw error if not specified</span>
            <span class="c1"># or when found but different from specified value</span>
            <span class="n">new_river_upa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;river_upa&quot;</span><span class="p">,</span> <span class="n">river_upa</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">new_river_upa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;No value for `river_upa` specified, and the value cannot </span><span class="se">\</span>
<span class="s2">be inferred from the grid attributes&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">new_river_upa</span> <span class="o">!=</span> <span class="n">river_upa</span> <span class="ow">and</span> <span class="n">river_upa</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Value specified for river_upa (</span><span class="si">{</span><span class="n">river_upa</span><span class="si">}</span><span class="s2">) is different from </span><span class="se">\</span>
<span class="s2">the value found in the grid (</span><span class="si">{</span><span class="n">new_river_upa</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using river_upa value value of: </span><span class="si">{</span><span class="n">new_river_upa</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># get river floodplain volume</span>
            <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">}</span>
            <span class="n">da_fldpln</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">river_floodplain_volume</span><span class="p">(</span>
                <span class="n">ds</span><span class="o">=</span><span class="n">ds_hydro</span><span class="p">,</span>
                <span class="n">ds_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
                <span class="n">river_upa</span><span class="o">=</span><span class="n">new_river_upa</span><span class="p">,</span>
                <span class="n">flood_depths</span><span class="o">=</span><span class="n">flood_depths</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># check if the layer already exists, since overwriting with different</span>
            <span class="c1"># flood_depth values is not working properly if this is the case</span>
            <span class="k">if</span> <span class="s2">&quot;floodplain_volume&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Layer `floodplain_volume` already in grid, removing layer </span><span class="se">\</span>
<span class="s2">and `flood_depth` dimension to ensure correctly </span><span class="se">\</span>
<span class="s2">setting new flood_depth dimensions&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">drop_dims</span><span class="p">(</span><span class="s2">&quot;flood_depth&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_fldpln</span><span class="p">,</span> <span class="s2">&quot;floodplain_volume&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">floodplain_type</span> <span class="o">==</span> <span class="s2">&quot;2d&quot;</span><span class="p">:</span>
            <span class="n">floodplain_1d</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">land_routing</span> <span class="o">=</span> <span class="s2">&quot;local-inertial&quot;</span>

            <span class="k">if</span> <span class="n">elevtn_map</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">elevtn_map</span><span class="si">}</span><span class="s1">&quot; not found in grid&#39;</span><span class="p">)</span>

            <span class="n">postfix</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;wflow_dem&quot;</span><span class="p">:</span> <span class="s2">&quot;_avg&quot;</span><span class="p">,</span> <span class="s2">&quot;dem_subgrid&quot;</span><span class="p">:</span> <span class="s2">&quot;_subgrid&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">elevtn_map</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
            <span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;hydrodem</span><span class="si">{</span><span class="n">postfix</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparing </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> map for land routing.&quot;</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;hydrodem</span><span class="si">{</span><span class="n">postfix</span><span class="si">}</span><span class="s2">_D</span><span class="si">{</span><span class="n">connectivity</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparing </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> map for land routing.&quot;</span><span class="p">)</span>
            <span class="n">ds_out</span> <span class="o">=</span> <span class="n">flw</span><span class="o">.</span><span class="n">dem_adjust</span><span class="p">(</span>
                <span class="n">da_flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;flwdir&quot;</span><span class="p">]],</span>
                <span class="n">da_elevtn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">elevtn_map</span><span class="p">],</span>
                <span class="n">da_rivmsk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]],</span>
                <span class="n">flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span>
                <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
                <span class="n">river_d8</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_out</span><span class="p">)</span>

        <span class="c1"># Update config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Update wflow config model.floodplain_1d=&quot;</span><span class="si">{</span><span class="n">floodplain_1d</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.floodplain_1d&quot;</span><span class="p">,</span> <span class="n">floodplain_1d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Update wflow config model.land_routing=&quot;</span><span class="si">{</span><span class="n">land_routing</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.land_routing&quot;</span><span class="p">,</span> <span class="n">land_routing</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">floodplain_type</span> <span class="o">==</span> <span class="s2">&quot;1d&quot;</span><span class="p">:</span>
            <span class="c1"># include new input data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span>
                <span class="s2">&quot;input.lateral.river.floodplain.volume&quot;</span><span class="p">,</span> <span class="s2">&quot;floodplain_volume&quot;</span>
            <span class="p">)</span>
            <span class="c1"># Add states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;state.lateral.river.floodplain.q&quot;</span><span class="p">,</span> <span class="s2">&quot;q_floodplain&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;state.lateral.river.floodplain.h&quot;</span><span class="p">,</span> <span class="s2">&quot;h_floodplain&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;state.lateral.land.q&quot;</span><span class="p">,</span> <span class="s2">&quot;q_land&quot;</span><span class="p">)</span>
            <span class="c1"># Remove local-inertial land states</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;state.lateral.land.qx&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">][</span><span class="s2">&quot;lateral&quot;</span><span class="p">][</span><span class="s2">&quot;land&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;qx&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;state.lateral.land.qy&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">][</span><span class="s2">&quot;lateral&quot;</span><span class="p">][</span><span class="s2">&quot;land&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;qy&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;output.lateral.land.qx&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">][</span><span class="s2">&quot;lateral&quot;</span><span class="p">][</span><span class="s2">&quot;land&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;qx&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;output.lateral.land.qy&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">][</span><span class="s2">&quot;lateral&quot;</span><span class="p">][</span><span class="s2">&quot;land&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;qy&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># include new input data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.lateral.river.bankfull_elevation&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.lateral.land.elevation&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="c1"># Add local-inertial land routing states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;state.lateral.land.qx&quot;</span><span class="p">,</span> <span class="s2">&quot;qx_land&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;state.lateral.land.qy&quot;</span><span class="p">,</span> <span class="s2">&quot;qy_land&quot;</span><span class="p">)</span>
            <span class="c1"># Remove kinematic-wave and 1d floodplain states</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;state.lateral.land.q&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">][</span><span class="s2">&quot;lateral&quot;</span><span class="p">][</span><span class="s2">&quot;land&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;state.lateral.river.floodplain.q&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">][</span><span class="s2">&quot;lateral&quot;</span><span class="p">][</span><span class="s2">&quot;river&quot;</span><span class="p">][</span><span class="s2">&quot;floodplain&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;state.lateral.river.floodplain.h&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">][</span><span class="s2">&quot;lateral&quot;</span><span class="p">][</span><span class="s2">&quot;river&quot;</span><span class="p">][</span><span class="s2">&quot;floodplain&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;h&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;output.lateral.land.q&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">][</span><span class="s2">&quot;lateral&quot;</span><span class="p">][</span><span class="s2">&quot;land&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">setup_riverwidth</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">predictor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;discharge&quot;</span><span class="p">,</span>
        <span class="n">fill</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">fit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">min_wth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">precip_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;chelsa&quot;</span><span class="p">,</span>
        <span class="n">climate_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;koppen_geiger&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the river width parameter based on power-law relationship with a predictor.</span>

<span class="sd">        By default the riverwidth is estimated based on discharge as ``predictor``</span>
<span class="sd">        and used to set the riverwidth globally based on pre-defined power-law</span>
<span class="sd">        parameters per climate class. With ``fit`` set to True,</span>
<span class="sd">        the power-law relationsship paramters are set on-the-fly.</span>
<span class="sd">        With ``fill`` set to True, the estimated river widths are only used</span>
<span class="sd">        to fill gaps in the observed data. Alternative ``predictor`` values</span>
<span class="sd">        are precip (accumulated precipitation) and uparea (upstream area).</span>
<span class="sd">        For these predictors values ``fit`` default to True.</span>
<span class="sd">        By default the predictor is based on discharge which is estimated through</span>
<span class="sd">        multiple linear regression with precipitation and upstream area</span>
<span class="sd">        per climate zone.</span>

<span class="sd">        * **wflow_riverwidth** map: river width [m]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        predictor : {&quot;discharge&quot;, &quot;precip&quot;, &quot;uparea&quot;}</span>
<span class="sd">            Predictor used in the power-law equation: width = a * predictor ^ b.</span>
<span class="sd">            Discharge is based on multiple linear regression per climate zone.</span>
<span class="sd">            Precip is based on the 10x the daily average</span>
<span class="sd">            accumulated precipitation [m3/s].</span>
<span class="sd">            Uparea is based on the upstream area grid [km2].</span>
<span class="sd">            Other variables, e.g. bankfull discharge, can also be provided if present</span>
<span class="sd">            in the grid</span>
<span class="sd">        fill : bool, optional</span>
<span class="sd">            If True (default), use estimate to fill gaps, outliers and lake/res areas</span>
<span class="sd">            in observed width data (if present);</span>
<span class="sd">            if False, set all riverwidths based on predictor</span>
<span class="sd">            (automatic choice if no observations found)</span>
<span class="sd">        fit : bool, optional</span>
<span class="sd">            If True, the power-law parameters are fitted on the fly</span>
<span class="sd">            By default True for all but &quot;discharge&quot; predictor.</span>
<span class="sd">            A-priori derived parameters will be overwritten if True.</span>
<span class="sd">        a, b : float, optional kwarg</span>
<span class="sd">            Manual power-law parameters</span>
<span class="sd">        min_wth : float, optional</span>
<span class="sd">            Minimum river width, by default 1.0</span>
<span class="sd">        precip_fn : str, xarray.DataArray</span>
<span class="sd">            Source of long term precipitation grid if the predictor</span>
<span class="sd">            is set to &#39;discharge&#39; or &#39;precip&#39;. By default &quot;chelsa&quot;.</span>
<span class="sd">        climate_fn: str, xarray.DataArray</span>
<span class="sd">            Source of long-term climate grid if the predictor is set to &#39;discharge&#39;.</span>
<span class="sd">            By default &quot;koppen_geiger&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s1">&#39;The &quot;setup_riverwidth&quot; method has been deprecated </span><span class="se">\</span>
<span class="s1">and will soon be removed. &#39;</span>
            <span class="s1">&#39;You can now use the &quot;setup_river&quot; method for all river parameters.&#39;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;The &quot;setup_riverwidth&quot; method requires </span><span class="se">\</span>
<span class="s1">to run setup_river method first.&#39;</span>
            <span class="p">)</span>

        <span class="c1"># derive river width</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">predictor</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;discharge&quot;</span><span class="p">,</span> <span class="s2">&quot;precip&quot;</span><span class="p">]:</span>
            <span class="n">da_precip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">precip_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
            <span class="n">da_precip</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">precip_fn</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;da_precip&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">da_precip</span>
        <span class="k">if</span> <span class="n">predictor</span> <span class="o">==</span> <span class="s2">&quot;discharge&quot;</span><span class="p">:</span>
            <span class="n">da_climate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">climate_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
            <span class="n">da_climate</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">climate_fn</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;da_climate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">da_climate</span>

        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">}</span>
        <span class="n">da_rivwth</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">river_width</span><span class="p">(</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">fill</span><span class="o">=</span><span class="n">fill</span><span class="p">,</span>
            <span class="n">fill_outliers</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;fill_outliers&quot;</span><span class="p">,</span> <span class="n">fill</span><span class="p">),</span>
            <span class="n">min_wth</span><span class="o">=</span><span class="n">min_wth</span><span class="p">,</span>
            <span class="n">mask_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lakeareas&quot;</span><span class="p">,</span> <span class="s2">&quot;resareas&quot;</span><span class="p">,</span> <span class="s2">&quot;glacareas&quot;</span><span class="p">],</span>
            <span class="n">predictor</span><span class="o">=</span><span class="n">predictor</span><span class="p">,</span>
            <span class="n">a</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">b</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
            <span class="n">fit</span><span class="o">=</span><span class="n">fit</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_rivwth</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivwth&quot;</span><span class="p">])</span>

<div class="viewcode-block" id="WflowModel.setup_lulcmaps">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_lulcmaps.html#hydromt_wflow.WflowModel.setup_lulcmaps">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_lulcmaps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lulc_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">],</span>
        <span class="n">lulc_mapping_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lulc_vars</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;landuse&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s2">&quot;Kext&quot;</span><span class="p">:</span> <span class="s2">&quot;input.vertical.kext&quot;</span><span class="p">,</span>
            <span class="s2">&quot;N&quot;</span><span class="p">:</span> <span class="s2">&quot;input.lateral.land.n&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PathFrac&quot;</span><span class="p">:</span> <span class="s2">&quot;input.vertical.pathfrac&quot;</span><span class="p">,</span>
            <span class="s2">&quot;RootingDepth&quot;</span><span class="p">:</span> <span class="s2">&quot;input.vertical.rootingdepth&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Sl&quot;</span><span class="p">:</span> <span class="s2">&quot;input.vertical.specific_leaf&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Swood&quot;</span><span class="p">:</span> <span class="s2">&quot;input.vertical.storage_wood&quot;</span><span class="p">,</span>
            <span class="s2">&quot;WaterFrac&quot;</span><span class="p">:</span> <span class="s2">&quot;input.vertical.waterfrac&quot;</span><span class="p">,</span>
            <span class="s2">&quot;alpha_h1&quot;</span><span class="p">:</span> <span class="s2">&quot;input.vertical.alpha_h1&quot;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derive several wflow maps based on landuse-landcover (LULC) data.</span>

<span class="sd">        Lookup table `lulc_mapping_fn` columns are converted to lulc classes model</span>
<span class="sd">        parameters based on literature. The data is remapped at its original resolution</span>
<span class="sd">        and then resampled to the model resolution using the average value, unless noted</span>
<span class="sd">        differently.</span>

<span class="sd">        Currently, if `lulc_fn` is set to the &quot;vito&quot;, &quot;globcover&quot;, &quot;esa_worldcover&quot;</span>
<span class="sd">        &quot;corine&quot; or &quot;glmnco&quot;, default lookup tables are available and will be used if</span>
<span class="sd">        `lulc_mapping_fn` is not provided.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **landuse** map: Landuse class [-]</span>
<span class="sd">        * **Kext** map: Extinction coefficient in the canopy gap fraction equation [-]</span>
<span class="sd">        * **Sl** map: Specific leaf storage [mm]</span>
<span class="sd">        * **Swood** map: Fraction of wood in the vegetation/plant [-]</span>
<span class="sd">        * **RootingDepth** map: Length of vegetation roots [mm]</span>
<span class="sd">        * **PathFrac** map: The fraction of compacted or urban area per grid cell [-]</span>
<span class="sd">        * **WaterFrac** map: The fraction of open water per grid cell [-]</span>
<span class="sd">        * **N** map: Manning Roughness [-]</span>
<span class="sd">        * **alpha_h1** map: Root water uptake reduction at soil water pressure head h1</span>
<span class="sd">          (0 or 1) [-]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lulc_fn : str, xarray.DataArray</span>
<span class="sd">            Name of RasterDataset source in data_sources.yml file.</span>
<span class="sd">        lulc_mapping_fn : str, Path, pd.DataFrame</span>
<span class="sd">            Path to a mapping csv file from landuse in source name to parameter values</span>
<span class="sd">            in lulc_vars. If lulc_fn is one of {&quot;globcover&quot;, &quot;vito&quot;, &quot;corine&quot;,</span>
<span class="sd">            &quot;esa_worldcover&quot;, &quot;glmnco&quot;}, a default mapping is used and this argument</span>
<span class="sd">            becomes optional.</span>
<span class="sd">        lulc_vars : dict</span>
<span class="sd">            Dictionary of landuse parameters in ``lulc_mapping_fn`` columns to prepare</span>
<span class="sd">            and their internal wflow name (or None to skip adding to the toml). By</span>
<span class="sd">            default \</span>
<span class="sd">{&quot;landuse&quot;: None, &quot;Kext&quot;: &quot;input.vertical.kext&quot;, &quot;N&quot;: &quot;input.lateral.land.n&quot;,</span>
<span class="sd">        &quot;PathFrac&quot;: &quot;input.vertical.pathfrac&quot;, &quot;RootingDepth&quot;:</span>
<span class="sd">        &quot;input.vertical.rootingdepth&quot;, &quot;Sl&quot;: &quot;input.vertical.specific_leaf&quot;, &quot;Swood&quot;:</span>
<span class="sd">        &quot;input.vertical.storage_wood&quot;, &quot;WaterFrac&quot;: &quot;input.vertical.waterfrac&quot;,</span>
<span class="sd">        &quot;alpha_h1&quot;: &quot;input.vertical.alpha_h1&quot;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing LULC parameter maps.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lulc_mapping_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fn_map</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lulc_fn</span><span class="si">}</span><span class="s2">_mapping_default&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fn_map</span> <span class="o">=</span> <span class="n">lulc_mapping_fn</span>

        <span class="c1"># read landuse map to DataArray</span>
        <span class="n">da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">lulc_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;landuse&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">df_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span>
            <span class="n">fn_map</span><span class="p">,</span>
            <span class="n">driver_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;index_col&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>  <span class="c1"># only used if fn_map is a file path</span>
        <span class="p">)</span>
        <span class="c1"># process landuse</span>
        <span class="n">ds_lulc_maps</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">landuse</span><span class="p">(</span>
            <span class="n">da</span><span class="o">=</span><span class="n">da</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df_map</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">lulc_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_lulc_maps</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_lulc_maps</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>

        <span class="c1"># Add entries to the config</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">wflow_param</span> <span class="ow">in</span> <span class="n">lulc_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">wflow_param</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="n">wflow_param</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_laimaps">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_laimaps.html#hydromt_wflow.WflowModel.setup_laimaps">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_laimaps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lai_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">],</span>
        <span class="n">lulc_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lulc_sampling_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;any&quot;</span><span class="p">,</span>
        <span class="n">lulc_zero_classes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">buffer</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set leaf area index (LAI) climatology maps per month [1,2,3,...,12].</span>

<span class="sd">        The values are resampled to the model resolution using the average value.</span>
<span class="sd">        Currently only directly cyclic LAI data is supported.</span>

<span class="sd">        If `lulc_fn` is provided, mapping tables from landuse classes to LAI values</span>
<span class="sd">        will be derived from the LULC data. These tables can then be re-used later if</span>
<span class="sd">        you would like to add new LAI maps derived from this mapping table and new</span>
<span class="sd">        landuse scenarios. We advise to use a larger `buffer` to ensure that LAI values</span>
<span class="sd">        can be assigned for all landuse classes and based on a lage enough sample of the</span>
<span class="sd">        LULC data.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **LAI** map: Leaf Area Index climatology [-]</span>
<span class="sd">            Resampled from source data using average. Assuming that missing values</span>
<span class="sd">            correspond to bare soil, these are set to zero before resampling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lai_fn : str, xarray.DataArray</span>
<span class="sd">            Name of RasterDataset source for LAI parameters, see data/data_sources.yml.</span>

<span class="sd">            * Required variables: &#39;LAI&#39; [-]</span>

<span class="sd">            * Required dimensions: &#39;time&#39; = [1,2,3,...,12] (months)</span>
<span class="sd">        lulc_fn : str, xarray.DataArray, optional</span>
<span class="sd">            Name of RasterDataset source for landuse-landcover data.</span>
<span class="sd">            If provided, the LAI values are mapped to landuse classes and will be saved</span>
<span class="sd">            to a csv file.</span>
<span class="sd">        lulc_sampling_method : str, optional</span>
<span class="sd">            Resampling method for the LULC data to the LAI resolution. Two methods are</span>
<span class="sd">            supported:</span>

<span class="sd">            * &#39;any&#39; (default): if any cell of the desired landuse class is present in</span>
<span class="sd">              the resampling window (even just one), it will be used to derive LAI</span>
<span class="sd">              values. This method is less exact but will provide LAI values for all</span>
<span class="sd">              landuse classes for the high resolution landuse map.</span>
<span class="sd">            * &#39;mode&#39;: the most frequent value in the resampling window is</span>
<span class="sd">              used. This method is less precise as for cells with a lot of different</span>
<span class="sd">              landuse classes, the most frequent value might still be only a small</span>
<span class="sd">              fraction of the cell. More landuse classes should however be covered and</span>
<span class="sd">              it can always be used with the landuse map of the wflow model instead of</span>
<span class="sd">              the original high resolution one.</span>
<span class="sd">            * &#39;q3&#39;: only cells with the most frequent value (mode) and that cover 75%</span>
<span class="sd">              (q3) of the resampling window will be used. This method is more exact but</span>
<span class="sd">              for small basins, you may have less or no samples to derive LAI values</span>
<span class="sd">              for some classes.</span>
<span class="sd">        lulc_zero_classes : list, optional</span>
<span class="sd">            List of landuse classes that should have zero for leaf area index values</span>
<span class="sd">            for example waterbodies, open ocean etc. For very high resolution landuse</span>
<span class="sd">            maps, urban surfaces and bare areas can be included here as well.</span>
<span class="sd">            By default empty.</span>
<span class="sd">        buffer : int, optional</span>
<span class="sd">            Buffer around the region to read the data, by default 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># retrieve data for region</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing LAI maps.&quot;</span><span class="p">)</span>
        <span class="n">da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">lai_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">lulc_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing LULC-LAI mapping table.&quot;</span><span class="p">)</span>
            <span class="n">da_lulc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">lulc_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span>
            <span class="p">)</span>
            <span class="c1"># derive mapping</span>
            <span class="n">df_lai_mapping</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">create_lulc_lai_mapping_table</span><span class="p">(</span>
                <span class="n">da_lulc</span><span class="o">=</span><span class="n">da_lulc</span><span class="p">,</span>
                <span class="n">da_lai</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">sampling_method</span><span class="o">=</span><span class="n">lulc_sampling_method</span><span class="p">,</span>
                <span class="n">lulc_zero_classes</span><span class="o">=</span><span class="n">lulc_zero_classes</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Save to csv</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lulc_fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">df_fn</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;lai_per_lulc_</span><span class="si">{</span><span class="n">lulc_fn</span><span class="si">}</span><span class="s2">.csv&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">df_fn</span> <span class="o">=</span> <span class="s2">&quot;lai_per_lulc.csv&quot;</span>
            <span class="n">df_lai_mapping</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">df_fn</span><span class="p">))</span>

        <span class="c1"># Resample LAI data to wflow model resolution</span>
        <span class="n">da_lai</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">lai</span><span class="p">(</span>
            <span class="n">da</span><span class="o">=</span><span class="n">da</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Rename the first dimension to time</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">da_lai</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="s2">&quot;time&quot;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_lai</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;LAI&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_laimaps_from_lulc_mapping">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_laimaps_from_lulc_mapping.html#hydromt_wflow.WflowModel.setup_laimaps_from_lulc_mapping">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_laimaps_from_lulc_mapping</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lulc_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]],</span>
        <span class="n">lai_mapping_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derive cyclic LAI maps from a LULC data source and a LULC-LAI mapping table.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **LAI** map: Leaf Area Index climatology [-]</span>
<span class="sd">            Resampled from source data using average. Assuming that missing values</span>
<span class="sd">            correspond to bare soil, these are set to zero before resampling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lulc_fn : str, xarray.DataArray</span>
<span class="sd">            Name of RasterDataset source for landuse-landcover data.</span>
<span class="sd">        lai_mapping_fn : str, pd.DataFrame</span>
<span class="sd">            Path to a mapping csv file from landuse in source name to</span>
<span class="sd">            LAI values. The csv file should contain rows with landuse classes</span>
<span class="sd">            and LAI values for each month. The columns should be named as the</span>
<span class="sd">            months (1,2,3,...,12).</span>
<span class="sd">            This table can be created using the :py:meth:`setup_laimaps` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Preparing LAI maps from LULC data using LULC-LAI mapping table.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># read landuse map to DataArray</span>
        <span class="n">da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">lulc_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;landuse&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">df_lai_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span>
            <span class="n">lai_mapping_fn</span><span class="p">,</span>
            <span class="n">driver_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;index_col&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>  <span class="c1"># only used if fn_map is a file path</span>
        <span class="p">)</span>
        <span class="c1"># process landuse with LULC-LAI mapping table</span>
        <span class="n">da_lai</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">lai_from_lulc_mapping</span><span class="p">(</span>
            <span class="n">da</span><span class="o">=</span><span class="n">da</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df_lai_mapping</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Add to grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_lai</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;LAI&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_config_output_timeseries">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_config_output_timeseries.html#hydromt_wflow.WflowModel.setup_config_output_timeseries">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_config_output_timeseries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapname</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">toml_output</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;csv&quot;</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">],</span>
        <span class="n">param</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;lateral.river.q_av&quot;</span><span class="p">],</span>
        <span class="n">reducer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the default gauge map based on basin outlets.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **csv.column** config: csv timeseries to save based on mapname locations</span>
<span class="sd">        * **netcdf.variable** config: netcdf timeseries to save based on mapname \</span>
<span class="sd">            locations</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapname : str</span>
<span class="sd">            Name of the gauge map (in staticmaps.nc) to use for scalar output.</span>
<span class="sd">        toml_output : str, optional</span>
<span class="sd">            One of [&#39;csv&#39;, &#39;netcdf&#39;, None] to update [csv] or [netcdf] section of wflow</span>
<span class="sd">            toml file or do nothing. By default, &#39;csv&#39;.</span>
<span class="sd">        header : list, optional</span>
<span class="sd">            Save specific model parameters in csv section. This option defines</span>
<span class="sd">            the header of the csv file.</span>
<span class="sd">            By default saves Q (for lateral.river.q_av).</span>
<span class="sd">        param: list, optional</span>
<span class="sd">            Save specific model parameters in csv section. This option defines</span>
<span class="sd">            the wflow variable corresponding to the</span>
<span class="sd">            names in gauge_toml_header. By default saves lateral.river.q_av (for Q).</span>
<span class="sd">        reducer: list, optional</span>
<span class="sd">            If map is an area rather than a point location, provides the reducer</span>
<span class="sd">            for the parameters to save. By default None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># # Add new outputcsv section in the config</span>
        <span class="k">if</span> <span class="n">toml_output</span> <span class="o">==</span> <span class="s2">&quot;csv&quot;</span> <span class="ow">or</span> <span class="n">toml_output</span> <span class="o">==</span> <span class="s2">&quot;netcdf&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding </span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">toml_output</span><span class="si">}</span><span class="s2"> section of toml.&quot;</span><span class="p">)</span>
            <span class="c1"># Add map to the input section of config</span>
            <span class="n">basename</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">mapname</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">mapname</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;wflow&quot;</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">mapname</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;wflow_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;input.</span><span class="si">{</span><span class="n">basename</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">mapname</span><span class="p">)</span>
            <span class="c1"># Settings and add csv or netcdf sections if not already in config</span>
            <span class="c1"># csv</span>
            <span class="k">if</span> <span class="n">toml_output</span> <span class="o">==</span> <span class="s2">&quot;csv&quot;</span><span class="p">:</span>
                <span class="n">header_name</span> <span class="o">=</span> <span class="s2">&quot;header&quot;</span>
                <span class="n">var_name</span> <span class="o">=</span> <span class="s2">&quot;column&quot;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;csv&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;csv.path&quot;</span><span class="p">,</span> <span class="s2">&quot;output.csv&quot;</span><span class="p">)</span>
            <span class="c1"># netcdf</span>
            <span class="k">if</span> <span class="n">toml_output</span> <span class="o">==</span> <span class="s2">&quot;netcdf&quot;</span><span class="p">:</span>
                <span class="n">header_name</span> <span class="o">=</span> <span class="s2">&quot;name&quot;</span>
                <span class="n">var_name</span> <span class="o">=</span> <span class="s2">&quot;variable&quot;</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;netcdf&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;netcdf.path&quot;</span><span class="p">,</span> <span class="s2">&quot;output_scalar.nc&quot;</span><span class="p">)</span>
            <span class="c1"># initialise column / varibale section</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">toml_output</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">toml_output</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">[])</span>

            <span class="c1"># Add new output column/variable to config</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">)):</span>
                <span class="n">gauge_toml_dict</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">header_name</span><span class="p">:</span> <span class="n">header</span><span class="p">[</span><span class="n">o</span><span class="p">],</span>
                    <span class="s2">&quot;map&quot;</span><span class="p">:</span> <span class="n">basename</span><span class="p">,</span>
                    <span class="s2">&quot;parameter&quot;</span><span class="p">:</span> <span class="n">param</span><span class="p">[</span><span class="n">o</span><span class="p">],</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="n">reducer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">gauge_toml_dict</span><span class="p">[</span><span class="s2">&quot;reducer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reducer</span><span class="p">[</span><span class="n">o</span><span class="p">]</span>
                <span class="c1"># If the gauge column/variable already exists skip writting twice</span>
                <span class="k">if</span> <span class="n">gauge_toml_dict</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="n">toml_output</span><span class="p">][</span><span class="n">var_name</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="n">toml_output</span><span class="p">][</span><span class="n">var_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gauge_toml_dict</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;toml_output set to </span><span class="si">{</span><span class="n">toml_output</span><span class="si">}</span><span class="s2">, </span><span class="se">\</span>
<span class="s2">skipping adding gauge specific outputs to the toml.&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_outlets">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_outlets.html#hydromt_wflow.WflowModel.setup_outlets">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_outlets</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">river_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">toml_output</span><span class="o">=</span><span class="s2">&quot;csv&quot;</span><span class="p">,</span>
        <span class="n">gauge_toml_header</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">],</span>
        <span class="n">gauge_toml_param</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lateral.river.q_av&quot;</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the default gauge map based on basin outlets.</span>

<span class="sd">        If wflow_subcatch is available, the catchment outlets IDs will be matching the</span>
<span class="sd">        wflow_subcatch IDs. If not, then IDs from 1 to number of outlets are used.</span>

<span class="sd">        Can also add csv/netcdf output settings in the TOML.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **wflow_gauges** map: gauge IDs map from catchment outlets [-]</span>
<span class="sd">        * **gauges** geom: polygon of catchment outlets</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        river_only : bool, optional</span>
<span class="sd">            Only derive outlet locations if they are located on a river instead of</span>
<span class="sd">            locations for all catchments, by default True.</span>
<span class="sd">        toml_output : str, optional</span>
<span class="sd">            One of [&#39;csv&#39;, &#39;netcdf&#39;, None] to update [csv] or [netcdf] section of</span>
<span class="sd">            wflow toml file or do nothing. By default, &#39;csv&#39;.</span>
<span class="sd">        gauge_toml_header : list, optional</span>
<span class="sd">            Save specific model parameters in csv section. This option defines</span>
<span class="sd">            the header of the csv file.</span>
<span class="sd">            By default saves Q (for lateral.river.q_av).</span>
<span class="sd">        gauge_toml_param: list, optional</span>
<span class="sd">            Save specific model parameters in csv section. This option defines</span>
<span class="sd">            the wflow variable corresponding to the names in gauge_toml_header.</span>
<span class="sd">            By default saves lateral.river.q_av (for Q).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># read existing geoms; important to get the right basin when updating</span>
        <span class="c1"># fix in set_geoms / set_geoms method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Gauges locations set based on river outlets.&quot;</span><span class="p">)</span>
        <span class="n">idxs_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="o">.</span><span class="n">idxs_pit</span>
        <span class="c1"># Only keep river outlets for gauges</span>
        <span class="k">if</span> <span class="n">river_only</span><span class="p">:</span>
            <span class="n">idxs_out</span> <span class="o">=</span> <span class="n">idxs_out</span><span class="p">[</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">idxs_out</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="c1"># Use the wflow_subcatch ids</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">idxs_out</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">da_out</span><span class="p">,</span> <span class="n">idxs_out</span><span class="p">,</span> <span class="n">ids_out</span> <span class="o">=</span> <span class="n">flw</span><span class="o">.</span><span class="n">gauge_map</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">idxs</span><span class="o">=</span><span class="n">idxs_out</span><span class="p">,</span>
            <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
            <span class="n">flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_out</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;gauges&quot;</span><span class="p">])</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">idx_to_xy</span><span class="p">(</span><span class="n">idxs_out</span><span class="p">))</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">ids_out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">geometry</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span>
        <span class="p">)</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;fid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ids_out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;gauges&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Gauges map based on catchment river outlets added.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setup_config_output_timeseries</span><span class="p">(</span>
            <span class="n">mapname</span><span class="o">=</span><span class="s2">&quot;wflow_gauges&quot;</span><span class="p">,</span>
            <span class="n">toml_output</span><span class="o">=</span><span class="n">toml_output</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="n">gauge_toml_header</span><span class="p">,</span>
            <span class="n">param</span><span class="o">=</span><span class="n">gauge_toml_param</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_gauges">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_gauges.html#hydromt_wflow.WflowModel.setup_gauges">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_gauges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">gauges_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">],</span>
        <span class="n">index_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">snap_to_river</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">snap_uparea</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">max_dist</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10e3</span><span class="p">,</span>
        <span class="n">wdw</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">rel_error</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
        <span class="n">abs_error</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">50.0</span><span class="p">,</span>
        <span class="n">fillna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">derive_subcatch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">basename</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">toml_output</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;csv&quot;</span><span class="p">,</span>
        <span class="n">gauge_toml_header</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">,</span> <span class="s2">&quot;P&quot;</span><span class="p">],</span>
        <span class="n">gauge_toml_param</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;lateral.river.q_av&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vertical.precipitation&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a gauge map based on ``gauges_fn`` data.</span>

<span class="sd">        Supported gauge datasets include data catlog entries, direct GeoDataFrame</span>
<span class="sd">        or &quot;&lt;path_to_source&gt;&quot; for user supplied csv or geometry files</span>
<span class="sd">        with gauge locations. If a csv file is provided, a &quot;x&quot; or &quot;lon&quot; and</span>
<span class="sd">        &quot;y&quot; or &quot;lat&quot; column is required and the first column will be used as</span>
<span class="sd">        IDs in the map.</span>

<span class="sd">        There are four available methods to prepare the gauge map:</span>

<span class="sd">        * no snapping: ``mask=None``, ``snap_to_river=False``, ``snap_uparea=False``.</span>
<span class="sd">          The gauge locations are used as is.</span>
<span class="sd">        * snapping to mask: the gauge locations are snapped to a boolean mask map based</span>
<span class="sd">          on the closest dowsntream cell within the mask:</span>
<span class="sd">          either provide ``mask`` or set ``snap_to_river=True``</span>
<span class="sd">          to snap to the river cells (default).</span>
<span class="sd">          ``max_dist`` can be used to set the maximum distance to snap to the mask.</span>
<span class="sd">        * snapping based on upstream area matching: : ``snap_uparea=True``.</span>
<span class="sd">          The gauge locations are snapped to the closest matching upstream area value.</span>
<span class="sd">          Requires gauges_fn to have an ``uparea`` [km2] column. The closest value will</span>
<span class="sd">          be looked for in a cell window of size ``wdw`` and the absolute and relative</span>
<span class="sd">          differences between the gauge and the closest value should be smaller than</span>
<span class="sd">          ``abs_error`` and ``rel_error``.</span>
<span class="sd">        * snapping based on upstream area matching and mask: ``snap_uparea=True``,</span>
<span class="sd">          ``mask`` or ``snap_to_river=True``. The gauge locations are snapped to the</span>
<span class="sd">            closest matching upstream area value within the mask.</span>

<span class="sd">        If ``derive_subcatch`` is set to True, an additional subcatch map is derived</span>
<span class="sd">        from the gauge locations.</span>

<span class="sd">        Finally the output locations can be added to wflow TOML file sections [csv]</span>
<span class="sd">        or [netcdf] using the ``toml_output`` option. The ``gauge_toml_header`` and</span>
<span class="sd">        ``gauge_toml_param`` options can be used to define the header and corresponding</span>
<span class="sd">        wflow variable names in the TOML file.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **wflow_gauges_source** map: gauge IDs map from source [-] (if gauges_fn)</span>
<span class="sd">        * **wflow_subcatch_source** map: subcatchment based on gauge locations [-] \</span>
<span class="sd">(if derive_subcatch)</span>
<span class="sd">        * **gauges_source** geom: polygon of gauges from source</span>
<span class="sd">        * **subcatch_source** geom: polygon of subcatchment based on \</span>
<span class="sd">gauge locations [-] (if derive_subcatch)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gauges_fn : str, Path, geopandas.GeoDataFrame</span>
<span class="sd">            Catalog source name, path to gauges file geometry file or</span>
<span class="sd">            geopandas.GeoDataFrame.</span>

<span class="sd">            * Required variables if snap_uparea is True: &#39;uparea&#39; [km2]</span>
<span class="sd">        index_col : str, optional</span>
<span class="sd">            Column in gauges_fn to use for ID values, by default None</span>
<span class="sd">            (use the default index column)</span>
<span class="sd">        mask : np.boolean, optional</span>
<span class="sd">            If provided snaps to the mask, else snaps to the river (default).</span>
<span class="sd">        snap_to_river : bool, optional</span>
<span class="sd">            Snap point locations to the closest downstream river cell, by default True</span>
<span class="sd">        snap_uparea: bool, optional</span>
<span class="sd">            Snap gauges based on upstream area. Gauges_fn should have &quot;uparea&quot;</span>
<span class="sd">            in its attributes.</span>
<span class="sd">        max_dist : float, optional</span>
<span class="sd">            Maximum distance [m] between original and snapped point location.</span>
<span class="sd">            A warning is logged if exceeded. By default 10 000m.</span>
<span class="sd">        wdw: int, optional</span>
<span class="sd">            Window size in number of cells around the gauge locations</span>
<span class="sd">            to snap uparea to, only used if ``snap_uparea`` is True. By default 3.</span>
<span class="sd">        rel_error: float, optional</span>
<span class="sd">            Maximum relative error (default 0.05)</span>
<span class="sd">            between the gauge location upstream area and the upstream area of</span>
<span class="sd">            the best fit grid cell, only used if snap_uparea is True.</span>
<span class="sd">        abs_error: float, optional</span>
<span class="sd">            Maximum absolute error (default 50.0)</span>
<span class="sd">            between the gauge location upstream area and the upstream area of</span>
<span class="sd">            the best fit grid cell, only used if snap_uparea is True.</span>
<span class="sd">        fillna: bool, optional</span>
<span class="sd">            Fill missing values in the gauges uparea column with the values from wflow</span>
<span class="sd">            upstream area (ie no snapping). By default False and the gauges with NaN</span>
<span class="sd">            values are skipped.</span>
<span class="sd">        derive_subcatch : bool, optional</span>
<span class="sd">            Derive subcatch map for gauges, by default False</span>
<span class="sd">        basename : str, optional</span>
<span class="sd">            Map name in grid (wflow_gauges_basename)</span>
<span class="sd">            if None use the gauges_fn basename.</span>
<span class="sd">        toml_output : str, optional</span>
<span class="sd">            One of [&#39;csv&#39;, &#39;netcdf&#39;, None] to update [csv] or [netcdf] section of</span>
<span class="sd">            wflow toml file or do nothing. By default, &#39;csv&#39;.</span>
<span class="sd">        gauge_toml_header : list, optional</span>
<span class="sd">            Save specific model parameters in csv section.</span>
<span class="sd">            This option defines the header of the csv file.</span>
<span class="sd">            By default saves Q (for lateral.river.q_av) and</span>
<span class="sd">            P (for vertical.precipitation).</span>
<span class="sd">        gauge_toml_param: list, optional</span>
<span class="sd">            Save specific model parameters in csv section. This option defines</span>
<span class="sd">            the wflow variable corresponding to the names in gauge_toml_header.</span>
<span class="sd">            By default saves lateral.river.q_av (for Q) and</span>
<span class="sd">            vertical.precipitation (for P).</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments to pass to the get_data method ie</span>
<span class="sd">            get_geodataframe or get_geodataset depending  on the data_type of gauges_fn.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Read data</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gauges_fn</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">):</span>
            <span class="n">gdf_gauges</span> <span class="o">=</span> <span class="n">gauges_fn</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">gdf_gauges</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="s2">&quot;Point&quot;</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gauges_fn</span><span class="si">}</span><span class="s2"> contains other geometries than Point&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">isfile</span><span class="p">(</span><span class="n">gauges_fn</span><span class="p">):</span>
            <span class="c1"># try to get epsg number directly, important when writting back data_catalog</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="s2">&quot;to_epsg&quot;</span><span class="p">):</span>
                <span class="n">code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_epsg</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">crs</span><span class="o">=</span><span class="n">code</span><span class="p">)</span>
            <span class="n">gdf_gauges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
                <span class="n">gauges_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins</span><span class="p">,</span>
                <span class="n">assert_gtype</span><span class="o">=</span><span class="s2">&quot;Point&quot;</span><span class="p">,</span>
                <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">gauges_fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="p">[</span><span class="n">gauges_fn</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;GeoDataFrame&quot;</span><span class="p">:</span>
                <span class="n">gdf_gauges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
                    <span class="n">gauges_fn</span><span class="p">,</span>
                    <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins</span><span class="p">,</span>
                    <span class="n">assert_gtype</span><span class="o">=</span><span class="s2">&quot;Point&quot;</span><span class="p">,</span>
                    <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="p">[</span><span class="n">gauges_fn</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span> <span class="o">==</span> <span class="s2">&quot;GeoDataset&quot;</span><span class="p">:</span>
                <span class="n">da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataset</span><span class="p">(</span>
                    <span class="n">gauges_fn</span><span class="p">,</span>
                    <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins</span><span class="p">,</span>
                    <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">gdf_gauges</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">to_gdf</span><span class="p">()</span>
                <span class="c1"># Check for point geometry</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">gdf_gauges</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="s2">&quot;Point&quot;</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gauges_fn</span><span class="si">}</span><span class="s2"> contains other geometries than Point&quot;</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gauges_fn</span><span class="si">}</span><span class="s2"> data source not found or </span><span class="se">\</span>
<span class="s2">incorrect data_type (GeoDataFrame or GeoDataset).&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Create basename</span>
        <span class="k">if</span> <span class="n">basename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">gauges_fn</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">)</span>

        <span class="c1"># Check if there is data found</span>
        <span class="k">if</span> <span class="n">gdf_gauges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skipping method, as no data has been found&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Create the gauges map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">basename</span><span class="si">}</span><span class="s2"> gauge locations found within domain&quot;</span>
        <span class="p">)</span>

        <span class="c1"># read existing geoms; important to get the right basin when updating</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span>
        <span class="c1"># Reproject to model crs</span>
        <span class="n">gdf_gauges</span> <span class="o">=</span> <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Get coords, index and ID</span>
        <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))(</span>
            <span class="n">gdf_gauges</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">xy_to_idx</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">index_col</span> <span class="ow">in</span> <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">gdf_gauges</span> <span class="o">=</span> <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">index_col</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Gauge ID 0 is not allowed, setting to 1&quot;</span><span class="p">)</span>
            <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># if snap_to_river use river map as the mask</span>
        <span class="k">if</span> <span class="n">snap_to_river</span> <span class="ow">and</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="n">snap_uparea</span> <span class="ow">and</span> <span class="s2">&quot;uparea&quot;</span> <span class="ow">in</span> <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># Derive gauge map based on upstream area snapping</span>
            <span class="n">da</span><span class="p">,</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">ids</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">gauge_map_uparea</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
                <span class="n">gdf_gauges</span><span class="p">,</span>
                <span class="n">uparea_name</span><span class="o">=</span><span class="s2">&quot;wflow_uparea&quot;</span><span class="p">,</span>
                <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                <span class="n">wdw</span><span class="o">=</span><span class="n">wdw</span><span class="p">,</span>
                <span class="n">rel_error</span><span class="o">=</span><span class="n">rel_error</span><span class="p">,</span>
                <span class="n">abs_error</span><span class="o">=</span><span class="n">abs_error</span><span class="p">,</span>
                <span class="n">fillna</span><span class="o">=</span><span class="n">fillna</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Derive gauge map</span>
            <span class="n">da</span><span class="p">,</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">ids</span> <span class="o">=</span> <span class="n">flw</span><span class="o">.</span><span class="n">gauge_map</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
                <span class="n">idxs</span><span class="o">=</span><span class="n">idxs</span><span class="p">,</span>
                <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
                <span class="n">stream</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
                <span class="n">flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span>
                <span class="n">max_dist</span><span class="o">=</span><span class="n">max_dist</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Filter gauges that could not be snapped to rivers</span>
            <span class="k">if</span> <span class="n">snap_to_river</span><span class="p">:</span>
                <span class="n">ids_old</span> <span class="o">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">da</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">nodata</span><span class="p">)</span>
                <span class="n">ids_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">da</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">idxs</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">ids_old</span><span class="p">,</span> <span class="n">ids_new</span><span class="p">)]</span>
                <span class="n">ids</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>

        <span class="c1"># Check if there are gauges left</span>
        <span class="k">if</span> <span class="n">ids</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;No gauges found within domain after snapping, skipping method.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Add to grid</span>
        <span class="n">mapname</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;gauges&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">basename</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">mapname</span><span class="p">)</span>

        <span class="c1"># geoms</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">idx_to_xy</span><span class="p">(</span><span class="n">idxs</span><span class="p">))</span>
        <span class="c1"># if csv contains additional columns, these are also written in the geoms</span>
        <span class="n">gdf_snapped</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">ids</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">geometry</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span>
        <span class="p">)</span>
        <span class="c1"># Set the index name of gdf snapped based on original gdf</span>
        <span class="k">if</span> <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gdf_snapped</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gdf_snapped</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;fid&quot;</span>
            <span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;fid&quot;</span>
        <span class="c1"># Add gdf attributes to gdf_snapped (filter on snapped index before merging)</span>
        <span class="n">df_attrs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">gdf_gauges</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">))</span>
        <span class="n">df_attrs</span> <span class="o">=</span> <span class="n">df_attrs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">df_attrs</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">gdf_snapped</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span>
        <span class="n">gdf_snapped</span> <span class="o">=</span> <span class="n">gdf_snapped</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_attrs</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">gdf_gauges</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># Add gdf_snapped to geoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_snapped</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">mapname</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;wflow_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>

        <span class="c1"># Add output timeseries for gauges in the toml</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup_config_output_timeseries</span><span class="p">(</span>
            <span class="n">mapname</span><span class="o">=</span><span class="n">mapname</span><span class="p">,</span>
            <span class="n">toml_output</span><span class="o">=</span><span class="n">toml_output</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="n">gauge_toml_header</span><span class="p">,</span>
            <span class="n">param</span><span class="o">=</span><span class="n">gauge_toml_param</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># add subcatch</span>
        <span class="k">if</span> <span class="n">derive_subcatch</span><span class="p">:</span>
            <span class="n">da_basins</span> <span class="o">=</span> <span class="n">flw</span><span class="o">.</span><span class="n">basin_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span> <span class="n">idxs</span><span class="o">=</span><span class="n">idxs</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mapname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">basename</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_basins</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">mapname</span><span class="p">)</span>
            <span class="n">gdf_basins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">mapname</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">vectorize</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_basins</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">mapname</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;wflow_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span></div>


<div class="viewcode-block" id="WflowModel.setup_areamap">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_areamap.html#hydromt_wflow.WflowModel.setup_areamap">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_areamap</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">area_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">],</span>
        <span class="n">col2raster</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">nodata</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set area map from vector data to save wflow outputs for specific area.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **col2raster** map:  output area data map</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        area_fn : str, geopandas.GeoDataFrame</span>
<span class="sd">            Name of GeoDataFrame data corresponding to wflow output area.</span>
<span class="sd">        col2raster : str</span>
<span class="sd">            Name of the column from `area_fn` to rasterize.</span>
<span class="sd">        nodata : int/float, optional</span>
<span class="sd">            Nodata value to use when rasterizing. Should match the dtype of `col2raster`</span>
<span class="sd">            . By default -1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparing &#39;</span><span class="si">{</span><span class="n">col2raster</span><span class="si">}</span><span class="s2">&#39; map from &#39;</span><span class="si">{</span><span class="n">area_fn</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
        <span class="n">gdf_org</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">area_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins</span><span class="p">,</span> <span class="n">dst_crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No shapes of </span><span class="si">{</span><span class="n">area_fn</span><span class="si">}</span><span class="s2"> found within region, skipping areamap.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">da_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span>
                <span class="n">gdf</span><span class="o">=</span><span class="n">gdf_org</span><span class="p">,</span>
                <span class="n">col_name</span><span class="o">=</span><span class="n">col2raster</span><span class="p">,</span>
                <span class="n">nodata</span><span class="o">=</span><span class="n">nodata</span><span class="p">,</span>
                <span class="n">all_touched</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_area</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">col2raster</span><span class="p">))</span></div>


<div class="viewcode-block" id="WflowModel.setup_lakes">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_lakes.html#hydromt_wflow.WflowModel.setup_lakes">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_lakes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lakes_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">],</span>
        <span class="n">rating_curve_fns</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_area</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
        <span class="n">add_maxstorage</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate maps of lake areas and outlets.</span>

<span class="sd">        Also meant to generate parameters with average lake area,</span>
<span class="sd">        depth and discharge values. The data is generated from features with</span>
<span class="sd">        ``min_area`` [km2] (default 1 km2) from a database with lake geometry, IDs and</span>
<span class="sd">        metadata. Data required are lake ID &#39;waterbody_id&#39;,</span>
<span class="sd">        average area &#39;Area_avg&#39; [m2], average volume &#39;Vol_avg&#39; [m3],</span>
<span class="sd">        average depth &#39;Depth_avg&#39; [m] and average discharge &#39;Dis_avg&#39; [m3/s].</span>

<span class="sd">        If rating curve data is available for storage and discharge they can be prepared</span>
<span class="sd">        via ``rating_curve_fns`` (see below for syntax and requirements).</span>
<span class="sd">        Else the parameters &#39;Lake_b&#39; and &#39;Lake_e&#39; will be used for discharge and</span>
<span class="sd">        for storage a rectangular profile lake is assumed.</span>
<span class="sd">        See Wflow documentation for more information.</span>

<span class="sd">        If ``add_maxstorage`` is True, the maximum storage of the lake is added to the</span>
<span class="sd">        output (controlled lake) based on &#39;Vol_max&#39; [m3] column of lakes_fn.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **wflow_lakeareas** map: lake IDs [-]</span>
<span class="sd">        * **wflow_lakelocs** map: lake IDs at outlet locations [-]</span>
<span class="sd">        * **LakeArea** map: lake area [m2]</span>
<span class="sd">        * **LakeAvgLevel** map: lake average water level [m]</span>
<span class="sd">        * **LakeAvgOut** map: lake average discharge [m3/s]</span>
<span class="sd">        * **Lake_b** map: lake rating curve coefficient [-]</span>
<span class="sd">        * **LakeOutflowFunc** map: option to compute rating curve [-]</span>
<span class="sd">        * **LakeStorFunc** map: option to compute storage curve [-]</span>
<span class="sd">        * **LakeMaxStorage** map: optional, maximum storage of lake [m3]</span>
<span class="sd">        * **lakes** geom: polygon with lakes and wflow lake parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lakes_fn :</span>
<span class="sd">            Name of GeoDataFrame source for lake parameters, see data/data_sources.yml.</span>

<span class="sd">            * Required variables for direct use: \</span>
<span class="sd">&#39;waterbody_id&#39; [-], &#39;Area_avg&#39; [m2], &#39;Depth_avg&#39; [m], &#39;Dis_avg&#39; [m3/s], &#39;Lake_b&#39; [-], \</span>
<span class="sd">&#39;Lake_e&#39; [-], &#39;LakeOutflowFunc&#39; [-], &#39;LakeStorFunc&#39; [-], &#39;LakeThreshold&#39; [m], \</span>
<span class="sd">&#39;LinkedLakeLocs&#39; [-]</span>

<span class="sd">            * Required variables for parameter estimation: \</span>
<span class="sd">&#39;waterbody_id&#39; [-], &#39;Area_avg&#39; [m2], &#39;Vol_avg&#39; [m3], &#39;Depth_avg&#39; [m], &#39;Dis_avg&#39;[m3/s]</span>
<span class="sd">        rating_curve_fns: str, Path, pandas.DataFrame, List, optional</span>
<span class="sd">            Data catalog entry/entries, path(s) or pandas.DataFrame containing rating</span>
<span class="sd">            curve values for lakes. If None then will be derived from properties of</span>
<span class="sd">            `lakes_fn`.</span>
<span class="sd">            Assumes one file per lake (with all variables) and that the lake ID is</span>
<span class="sd">            either in the filename or data catalog entry name (eg using placeholder).</span>
<span class="sd">            The ID should be placed at the end separated by an underscore (eg</span>
<span class="sd">            &#39;rating_curve_12.csv&#39; or &#39;rating_curve_12&#39;)</span>

<span class="sd">            * Required variables for storage curve: &#39;elevtn&#39; [m+REF], &#39;volume&#39; [m3]</span>

<span class="sd">            * Required variables for rating curve: &#39;elevtn&#39; [m+REF], &#39;discharge&#39; [m3/s]</span>
<span class="sd">        min_area : float, optional</span>
<span class="sd">            Minimum lake area threshold [km2], by default 10.0 km2.</span>
<span class="sd">        add_maxstorage : bool, optional</span>
<span class="sd">            If True, maximum storage of the lake is added to the output</span>
<span class="sd">            (controlled lake) based on &#39;Vol_max&#39; [m3] column of lakes_fn.</span>
<span class="sd">            By default False (natural lake).</span>
<span class="sd">        kwargs: optional</span>
<span class="sd">            Keyword arguments passed to the method</span>
<span class="sd">            hydromt.DataCatalog.get_rasterdataset()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Derive lake are and outlet maps</span>
        <span class="n">gdf_org</span><span class="p">,</span> <span class="n">ds_lakes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_waterbodies</span><span class="p">(</span>
            <span class="n">lakes_fn</span><span class="p">,</span> <span class="s2">&quot;lake&quot;</span><span class="p">,</span> <span class="n">min_area</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ds_lakes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skipping method, as no data has been found&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_lakes</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="n">ds_lakes</span> <span class="o">=</span> <span class="n">ds_lakes</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span>

        <span class="c1"># If rating_curve_fn prepare rating curve dict</span>
        <span class="n">rating_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">rating_curve_fns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rating_curve_fns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">rating_curve_fns</span><span class="p">)</span>
            <span class="c1"># Find ids in rating_curve_fns</span>
            <span class="n">fns_ids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">rating_curve_fns</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fns_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Could not parse integer lake index from </span><span class="se">\</span>
<span class="s2">rating curve fn </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s2">. Skipping.&quot;</span>
                    <span class="p">)</span>
            <span class="c1"># assume lake index will be in the path</span>
            <span class="c1"># Assume one rating curve per lake index</span>
            <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">gdf_org</span><span class="p">[</span><span class="s2">&quot;waterbody_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="nb">id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
                <span class="c1"># Find if id is is one of the paths in rating_curve_fns</span>
                <span class="k">if</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">fns_ids</span><span class="p">:</span>
                    <span class="c1"># Update path based on current waterbody_id</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">fns_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
                    <span class="n">rating_fn</span> <span class="o">=</span> <span class="n">rating_curve_fns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="c1"># Read data</span>
                    <span class="k">if</span> <span class="n">isfile</span><span class="p">(</span><span class="n">rating_fn</span><span class="p">)</span> <span class="ow">or</span> <span class="n">rating_fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Preparing lake rating curve data from </span><span class="si">{</span><span class="n">rating_fn</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="n">df_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span><span class="n">rating_fn</span><span class="p">)</span>
                        <span class="c1"># Add to dict</span>
                        <span class="n">rating_dict</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_rate</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Rating curve file not found for lake with id </span><span class="si">{</span><span class="nb">id</span><span class="si">}</span><span class="s2">. </span><span class="se">\</span>
<span class="s2">Using default storage/outflow function parameters.&quot;</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;No rating curve data provided. </span><span class="se">\</span>
<span class="s2">Using default storage/outflow function parameters.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># add waterbody parameters</span>
        <span class="n">ds_lakes</span><span class="p">,</span> <span class="n">gdf_lakes</span><span class="p">,</span> <span class="n">rating_curves</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">waterbodies</span><span class="o">.</span><span class="n">lakeattrs</span><span class="p">(</span>
            <span class="n">ds_lakes</span><span class="p">,</span> <span class="n">gdf_org</span><span class="p">,</span> <span class="n">rating_dict</span><span class="p">,</span> <span class="n">add_maxstorage</span><span class="o">=</span><span class="n">add_maxstorage</span>
        <span class="p">)</span>

        <span class="c1"># add to grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_lakes</span><span class="p">)</span>
        <span class="c1"># write lakes with attr tables to static geoms.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_lakes</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;lakes&quot;</span><span class="p">)</span>
        <span class="c1"># add the tables</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">rating_curves</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_tables</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

        <span class="c1"># if there are lakes, change True in toml</span>
        <span class="c1"># Lake seetings in the toml to update</span>
        <span class="n">lakes_toml</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;model.lakes&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;state.lateral.river.lake.waterlevel&quot;</span><span class="p">:</span> <span class="s2">&quot;waterlevel_lake&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.lake.area&quot;</span><span class="p">:</span> <span class="s2">&quot;LakeArea&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.lake.areas&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_lakeareas&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.lake.b&quot;</span><span class="p">:</span> <span class="s2">&quot;Lake_b&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.lake.e&quot;</span><span class="p">:</span> <span class="s2">&quot;Lake_e&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.lake.locs&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_lakelocs&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.lake.outflowfunc&quot;</span><span class="p">:</span> <span class="s2">&quot;LakeOutflowFunc&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.lake.storfunc&quot;</span><span class="p">:</span> <span class="s2">&quot;LakeStorFunc&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.lake.threshold&quot;</span><span class="p">:</span> <span class="s2">&quot;LakeThreshold&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.lake.linkedlakelocs&quot;</span><span class="p">:</span> <span class="s2">&quot;LinkedLakeLocs&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.lake.waterlevel&quot;</span><span class="p">:</span> <span class="s2">&quot;LakeAvgLevel&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="s2">&quot;LakeMaxStorage&quot;</span> <span class="ow">in</span> <span class="n">ds_lakes</span><span class="p">:</span>
            <span class="n">lakes_toml</span><span class="p">[</span><span class="s2">&quot;input.lateral.river.lake.maxstorage&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;LakeMaxStorage&quot;</span>
        <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">lakes_toml</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">lakes_toml</span><span class="p">[</span><span class="n">option</span><span class="p">])</span></div>


<div class="viewcode-block" id="WflowModel.setup_reservoirs">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_reservoirs.html#hydromt_wflow.WflowModel.setup_reservoirs">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_reservoirs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reservoirs_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">],</span>
        <span class="n">timeseries_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_area</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate maps of reservoir areas and outlets.</span>

<span class="sd">        Also meant to generate parameters with average reservoir area, demand,</span>
<span class="sd">        min and max target storage capacities and discharge capacity values.</span>

<span class="sd">        The data is generated from features with ``min_area`` [km2] (default is 1 km2)</span>
<span class="sd">        from a database with reservoir geometry, IDs and metadata.</span>

<span class="sd">        Data requirements for direct use (i.e. wflow parameters are data already present</span>
<span class="sd">        in reservoirs_fn) are reservoir ID &#39;waterbody_id&#39;, area &#39;ResSimpleArea&#39; [m2],</span>
<span class="sd">        maximum volume &#39;ResMaxVolume&#39; [m3], the targeted minimum and maximum fraction of</span>
<span class="sd">        water volume in the reservoir &#39;ResTargetMinFrac&#39; and &#39;ResTargetMaxFrac&#39; [-],</span>
<span class="sd">        the average water demand ResDemand [m3/s] and the maximum release of</span>
<span class="sd">        the reservoir before spilling &#39;ResMaxRelease&#39; [m3/s].</span>

<span class="sd">        In case the wflow parameters are not directly available they can be computed by</span>
<span class="sd">        HydroMT based on time series of reservoir surface water area.</span>
<span class="sd">        These time series can be retreived from either the hydroengine or the gwwapi,</span>
<span class="sd">        based on the Hylak_id the reservoir, found in the GrandD database.</span>

<span class="sd">        The required variables for computation of the parameters with time series data</span>
<span class="sd">        are reservoir ID &#39;waterbody_id&#39;, reservoir ID in the HydroLAKES database</span>
<span class="sd">        &#39;Hylak_id&#39;, average volume &#39;Vol_avg&#39; [m3], average depth &#39;Depth_avg&#39; [m],</span>
<span class="sd">        average discharge &#39;Dis_avg&#39; [m3/s] and dam height &#39;Dam_height&#39; [m].</span>
<span class="sd">        To compute parameters without using time series data, the required varibales in</span>
<span class="sd">        reservoirs_fn are reservoir ID &#39;waterbody_id&#39;, average area &#39;Area_avg&#39; [m2],</span>
<span class="sd">        average volume &#39;Vol_avg&#39; [m3], average depth &#39;Depth_avg&#39; [m], average discharge</span>
<span class="sd">        &#39;Dis_avg&#39; [m3/s] and dam height &#39;Dam_height&#39; [m]</span>
<span class="sd">        and minimum / normal / maximum storage capacity of the dam &#39;Capacity_min&#39;,</span>
<span class="sd">        &#39;Capacity_norm&#39;, &#39;Capacity_max&#39; [m3].</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **wflow_reservoirareas** map: reservoir IDs [-]</span>
<span class="sd">        * **wflow_reservoirlocs** map: reservoir IDs at outlet locations [-]</span>
<span class="sd">        * **ResSimpleArea** map: reservoir area [m2]</span>
<span class="sd">        * **ResMaxVolume** map: reservoir max volume [m3]</span>
<span class="sd">        * **ResTargetMinFrac** map: reservoir target min frac [m3/m3]</span>
<span class="sd">        * **ResTargetFullFrac** map: reservoir target full frac [m3/m3]</span>
<span class="sd">        * **ResDemand** map: reservoir demand flow [m3/s]</span>
<span class="sd">        * **ResMaxRelease** map: reservoir max release flow [m3/s]</span>
<span class="sd">        * **reservoirs** geom: polygon with reservoirs and wflow reservoir parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reservoirs_fn : str</span>
<span class="sd">            Name of data source for reservoir parameters, see data/data_sources.yml.</span>

<span class="sd">            * Required variables for direct use: \</span>
<span class="sd">&#39;waterbody_id&#39; [-], &#39;ResSimpleArea&#39; [m2], &#39;ResMaxVolume&#39; [m3], &#39;ResTargetMinFrac&#39; \</span>
<span class="sd">[m3/m3], &#39;ResTargetFullFrac&#39; [m3/m3], &#39;ResDemand&#39; [m3/s], &#39;ResMaxRelease&#39; [m3/s]</span>

<span class="sd">            * Required variables for computation with timeseries_fn: \</span>
<span class="sd">&#39;waterbody_id&#39; [-], &#39;Hylak_id&#39; [-], &#39;Vol_avg&#39; [m3], &#39;Depth_avg&#39; [m], &#39;Dis_avg&#39; [m3/s], \</span>
<span class="sd">&#39;Dam_height&#39; [m]</span>

<span class="sd">            * Required variables for computation without timeseries_fn: \</span>
<span class="sd">&#39;waterbody_id&#39; [-], &#39;Area_avg&#39; [m2], &#39;Vol_avg&#39; [m3], &#39;Depth_avg&#39; [m], &#39;Dis_avg&#39; \</span>
<span class="sd">[m3/s], &#39;Capacity_max&#39; [m3], &#39;Capacity_norm&#39; [m3], &#39;Capacity_min&#39; [m3], &#39;Dam_height&#39; [m]</span>
<span class="sd">        timeseries_fn : {&#39;gww&#39;, &#39;hydroengine&#39;, None}, optional</span>
<span class="sd">            Download and use time series of reservoir surface water area to calculate</span>
<span class="sd">            and overwrite the reservoir volume/areas of the data source. Timeseries are</span>
<span class="sd">            either downloaded from Global Water Watch &#39;gww&#39; (using gwwapi package) or</span>
<span class="sd">            JRC &#39;jrc&#39; (using hydroengine package). By default None.</span>
<span class="sd">        min_area : float, optional</span>
<span class="sd">            Minimum reservoir area threshold [km2], by default 1.0 km2.</span>
<span class="sd">        kwargs: optional</span>
<span class="sd">            Keyword arguments passed to the method</span>
<span class="sd">            hydromt.DataCatalog.get_rasterdataset()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># rename to wflow naming convention</span>
        <span class="n">tbls</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;resarea&quot;</span><span class="p">:</span> <span class="s2">&quot;ResSimpleArea&quot;</span><span class="p">,</span>
            <span class="s2">&quot;resdemand&quot;</span><span class="p">:</span> <span class="s2">&quot;ResDemand&quot;</span><span class="p">,</span>
            <span class="s2">&quot;resfullfrac&quot;</span><span class="p">:</span> <span class="s2">&quot;ResTargetFullFrac&quot;</span><span class="p">,</span>
            <span class="s2">&quot;resminfrac&quot;</span><span class="p">:</span> <span class="s2">&quot;ResTargetMinFrac&quot;</span><span class="p">,</span>
            <span class="s2">&quot;resmaxrelease&quot;</span><span class="p">:</span> <span class="s2">&quot;ResMaxRelease&quot;</span><span class="p">,</span>
            <span class="s2">&quot;resmaxvolume&quot;</span><span class="p">:</span> <span class="s2">&quot;ResMaxVolume&quot;</span><span class="p">,</span>
            <span class="s2">&quot;resid&quot;</span><span class="p">:</span> <span class="s2">&quot;expr1&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">res_toml</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;model.reservoirs&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;state.lateral.river.reservoir.volume&quot;</span><span class="p">:</span> <span class="s2">&quot;volume_reservoir&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.reservoir.area&quot;</span><span class="p">:</span> <span class="s2">&quot;ResSimpleArea&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.reservoir.areas&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_reservoirareas&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.reservoir.demand&quot;</span><span class="p">:</span> <span class="s2">&quot;ResDemand&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.reservoir.locs&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_reservoirlocs&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.reservoir.maxrelease&quot;</span><span class="p">:</span> <span class="s2">&quot;ResMaxRelease&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.reservoir.maxvolume&quot;</span><span class="p">:</span> <span class="s2">&quot;ResMaxVolume&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.reservoir.targetfullfrac&quot;</span><span class="p">:</span> <span class="s2">&quot;ResTargetFullFrac&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.lateral.river.reservoir.targetminfrac&quot;</span><span class="p">:</span> <span class="s2">&quot;ResTargetMinFrac&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">gdf_org</span><span class="p">,</span> <span class="n">ds_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_waterbodies</span><span class="p">(</span>
            <span class="n">reservoirs_fn</span><span class="p">,</span> <span class="s2">&quot;reservoir&quot;</span><span class="p">,</span> <span class="n">min_area</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="c1"># TODO: check if there are missing values in the above columns of</span>
        <span class="c1"># the parameters tbls =</span>
        <span class="c1"># if everything is present, skip calculate reservoirattrs() and</span>
        <span class="c1"># directly make the maps</span>

        <span class="c1"># Skip method if no data is returned</span>
        <span class="k">if</span> <span class="n">ds_res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skipping method, as no data has been found&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Continue method if data has been found</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_res</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_res</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>

        <span class="c1"># add attributes</span>
        <span class="c1"># if present use directly</span>
        <span class="n">resattributes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;waterbody_id&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ResSimpleArea&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ResMaxVolume&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ResTargetMinFrac&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ResTargetFullFrac&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ResDemand&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ResMaxRelease&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">resattributes</span><span class="p">,</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
            <span class="n">intbl_reservoirs</span> <span class="o">=</span> <span class="n">gdf_org</span><span class="p">[</span><span class="n">resattributes</span><span class="p">]</span>
            <span class="n">reservoir_accuracy</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">reservoir_timeseries</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># else compute</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span>
                <span class="n">intbl_reservoirs</span><span class="p">,</span>
                <span class="n">reservoir_accuracy</span><span class="p">,</span>
                <span class="n">reservoir_timeseries</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">reservoirattrs</span><span class="p">(</span>
                <span class="n">gdf</span><span class="o">=</span><span class="n">gdf_org</span><span class="p">,</span> <span class="n">timeseries_fn</span><span class="o">=</span><span class="n">timeseries_fn</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span>
            <span class="p">)</span>
            <span class="n">intbl_reservoirs</span> <span class="o">=</span> <span class="n">intbl_reservoirs</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">tbls</span><span class="p">)</span>

        <span class="c1"># create a geodf with id of reservoir and gemoetry at outflow location</span>
        <span class="n">gdf_org_points</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="n">gdf_org</span><span class="p">[</span><span class="s2">&quot;waterbody_id&quot;</span><span class="p">],</span>
            <span class="n">geometry</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">gdf_org</span><span class="o">.</span><span class="n">xout</span><span class="p">,</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">yout</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">intbl_reservoirs</span> <span class="o">=</span> <span class="n">intbl_reservoirs</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;expr1&quot;</span><span class="p">:</span> <span class="s2">&quot;waterbody_id&quot;</span><span class="p">})</span>
        <span class="n">gdf_org_points</span> <span class="o">=</span> <span class="n">gdf_org_points</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">intbl_reservoirs</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;waterbody_id&quot;</span>
        <span class="p">)</span>  <span class="c1"># merge</span>
        <span class="c1"># add parameter attributes to polygone gdf:</span>
        <span class="n">gdf_org</span> <span class="o">=</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">intbl_reservoirs</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;waterbody_id&quot;</span><span class="p">)</span>

        <span class="c1"># write reservoirs with param values to geoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_org</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;reservoirs&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">gdf_org_points</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
            <span class="n">gdf_org_points</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_org_points</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
            <span class="n">da_res</span> <span class="o">=</span> <span class="n">ds_res</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span>
                <span class="n">gdf_org_points</span><span class="p">,</span> <span class="n">col_name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="n">nodata</span><span class="o">=-</span><span class="mi">999</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_res</span><span class="p">)</span>

        <span class="c1"># Save accuracy information on reservoir parameters</span>
        <span class="k">if</span> <span class="n">reservoir_accuracy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reservoir_accuracy</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;reservoir_accuracy.csv&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">reservoir_timeseries</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reservoir_timeseries</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span>
                <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;reservoir_timeseries_</span><span class="si">{</span><span class="n">timeseries_fn</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">res_toml</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">res_toml</span><span class="p">[</span><span class="n">option</span><span class="p">])</span></div>


    <span class="k">def</span> <span class="nf">_setup_waterbodies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">waterbodies_fn</span><span class="p">,</span> <span class="n">wb_type</span><span class="p">,</span> <span class="n">min_area</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Help with common workflow of setup_lakes and setup_reservoir.</span>

<span class="sd">        See specific methods for more info about the arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># retrieve data for basin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparing </span><span class="si">{</span><span class="n">wb_type</span><span class="si">}</span><span class="s2"> maps.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;predicate&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;contains&quot;</span><span class="p">)</span>
        <span class="n">gdf_org</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">waterbodies_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins_highres</span><span class="p">,</span>
            <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">gdf_org</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Return two times None (similair to main function output), if there is no</span>
            <span class="c1"># data found</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># skip small size waterbodies</span>
        <span class="k">if</span> <span class="s2">&quot;Area_avg&quot;</span> <span class="ow">in</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">min_area_m2</span> <span class="o">=</span> <span class="n">min_area</span> <span class="o">*</span> <span class="mf">1e6</span>
            <span class="n">gdf_org</span> <span class="o">=</span> <span class="n">gdf_org</span><span class="p">[</span><span class="n">gdf_org</span><span class="o">.</span><span class="n">Area_avg</span> <span class="o">&gt;=</span> <span class="n">min_area_m2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">wb_type</span><span class="si">}</span><span class="s2">&#39;s database has no area attribute. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;All </span><span class="si">{</span><span class="n">wb_type</span><span class="si">}</span><span class="s2">s will be considered.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># get waterbodies maps and parameters</span>
        <span class="n">nb_wb</span> <span class="o">=</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">size</span>
        <span class="n">ds_waterbody</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">nb_wb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nb_wb</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">wb_type</span><span class="si">}</span><span class="s2">(s) of sufficient size found within region.&quot;</span>
            <span class="p">)</span>
            <span class="c1"># add waterbody maps</span>
            <span class="n">uparea_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;uparea&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">uparea_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Upstream area map for </span><span class="si">{</span><span class="n">wb_type</span><span class="si">}</span><span class="s2"> outlet setup not found. &quot;</span>
                    <span class="s2">&quot;Database coordinates used instead&quot;</span>
                <span class="p">)</span>
                <span class="n">uparea_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ds_waterbody</span><span class="p">,</span> <span class="n">gdf_wateroutlet</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">waterbodymaps</span><span class="p">(</span>
                <span class="n">gdf</span><span class="o">=</span><span class="n">gdf_org</span><span class="p">,</span>
                <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
                <span class="n">wb_type</span><span class="o">=</span><span class="n">wb_type</span><span class="p">,</span>
                <span class="n">uparea_name</span><span class="o">=</span><span class="n">uparea_name</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># update/replace xout and yout in gdf_org from gdf_wateroutlet:</span>
            <span class="n">gdf_org</span><span class="p">[</span><span class="s2">&quot;xout&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_wateroutlet</span><span class="p">[</span><span class="s2">&quot;xout&quot;</span><span class="p">]</span>
            <span class="n">gdf_org</span><span class="p">[</span><span class="s2">&quot;yout&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_wateroutlet</span><span class="p">[</span><span class="s2">&quot;yout&quot;</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No </span><span class="si">{</span><span class="n">wb_type</span><span class="si">}</span><span class="s2">s of sufficient size found within region! &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Skipping </span><span class="si">{</span><span class="n">wb_type</span><span class="si">}</span><span class="s2"> procedures!&quot;</span>
            <span class="p">)</span>

        <span class="c1"># rasterize points polygons in raster.rasterize --</span>
        <span class="c1"># you need grid to know the grid</span>
        <span class="k">return</span> <span class="n">gdf_org</span><span class="p">,</span> <span class="n">ds_waterbody</span>

<div class="viewcode-block" id="WflowModel.setup_soilmaps">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_soilmaps.html#hydromt_wflow.WflowModel.setup_soilmaps">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_soilmaps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">soil_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;soilgrids&quot;</span><span class="p">,</span>
        <span class="n">ptf_ksatver</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;brakensiek&quot;</span><span class="p">,</span>
        <span class="n">wflow_thicknesslayers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">800</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derive several (layered) soil parameters.</span>

<span class="sd">        Based on a database with physical soil properties using available point-scale</span>
<span class="sd">        (pedo)transfer functions (PTFs) from literature with upscaling rules to</span>
<span class="sd">        ensure flux matching across scales.</span>

<span class="sd">        Currently, supported ``soil_fn`` is &quot;soilgrids&quot; and &quot;soilgrids_2020&quot;.</span>
<span class="sd">        ``ptf_ksatver`` (PTF for the vertical hydraulic conductivity) options are</span>
<span class="sd">        &quot;brakensiek&quot; and &quot;cosby&quot;. &quot;soilgrids&quot; provides data at 7 specific depths,</span>
<span class="sd">        while &quot;soilgrids_2020&quot; provides data averaged over 6 depth intervals.</span>
<span class="sd">        This leads to small changes in the workflow:</span>
<span class="sd">        (1) M parameter uses midpoint depths in soilgrids_2020 versus \</span>
<span class="sd">specific depths in soilgrids,</span>
<span class="sd">        (2) weighted average of soil properties over soil thickness is done with \</span>
<span class="sd">the trapezoidal rule in soilgrids versus simple block weighted average in \</span>
<span class="sd">soilgrids_2020,</span>
<span class="sd">        (3) the c parameter is computed as weighted average over wflow_sbm soil layers \</span>
<span class="sd">defined in ``wflow_thicknesslayers``.</span>

<span class="sd">        The required data from soilgrids are soil bulk density &#39;bd_sl*&#39; [g/cm3], \</span>
<span class="sd">clay content &#39;clyppt_sl*&#39; [%], silt content &#39;sltppt_sl*&#39; [%], organic carbon content \</span>
<span class="sd">&#39;oc_sl*&#39; [%], pH &#39;ph_sl*&#39; [-], sand content &#39;sndppt_sl*&#39; [%] and soil thickness \</span>
<span class="sd">&#39;soilthickness&#39; [cm].</span>

<span class="sd">        The following maps are added to grid:</span>

<span class="sd">        * **thetaS** map: average saturated soil water content [m3/m3]</span>
<span class="sd">        * **thetaR** map: average residual water content [m3/m3]</span>
<span class="sd">        * **KsatVer** map: vertical saturated hydraulic conductivity at \</span>
<span class="sd">soil surface [mm/day]</span>
<span class="sd">        * **SoilThickness** map: soil thickness [mm]</span>
<span class="sd">        * **SoilMinThickness** map: minimum soil thickness [mm] (equal to SoilThickness)</span>
<span class="sd">        * **M** map: model parameter [mm] that controls exponential decline of \</span>
<span class="sd">KsatVer with soil depth (fitted with curve_fit (scipy.optimize)), bounds of M are \</span>
<span class="sd">    checked</span>
<span class="sd">        * **M_** map: model parameter [mm] that controls exponential decline of \</span>
<span class="sd">KsatVer with soil depth (fitted with numpy linalg regression), bounds of `M_` are \</span>
<span class="sd">    checked</span>
<span class="sd">        * **M_original** map: M without checking bounds</span>
<span class="sd">        * **M_original_** map: `M_` without checking bounds</span>
<span class="sd">        * **f** map: scaling parameter controlling the decline of KsatVer [mm-1] \</span>
<span class="sd">(fitted with curve_fit (scipy.optimize)), bounds are checked</span>
<span class="sd">        * **f_** map: scaling parameter controlling the decline of KsatVer [mm-1] \</span>
<span class="sd">(fitted with numpy linalg regression), bounds are checked</span>
<span class="sd">        * **c_n** map: Brooks Corey coefficients [-] based on pore size distribution, \</span>
<span class="sd">a map for each of the wflow_sbm soil layers (n in total)</span>
<span class="sd">        * **KsatVer_[z]cm** map: KsatVer [mm/day] at soil depths [z] of SoilGrids data \</span>
<span class="sd">[0.0, 5.0, 15.0, 30.0, 60.0, 100.0, 200.0]</span>
<span class="sd">        * **wflow_soil** map: soil texture based on USDA soil texture triangle \</span>
<span class="sd">(mapping: [1:Clay, 2:Silty Clay, 3:Silty Clay-Loam, 4:Sandy Clay, 5:Sandy Clay-Loam, \</span>
<span class="sd">6:Clay-Loam, 7:Silt, 8:Silt-Loam, 9:Loam, 10:Sand, 11: Loamy Sand, 12:Sandy Loam])</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        soil_fn : {&#39;soilgrids&#39;, &#39;soilgrids_2020&#39;}</span>
<span class="sd">            Name of RasterDataset source for soil parameter maps, see</span>
<span class="sd">            data/data_sources.yml.</span>
<span class="sd">            Should contain info for the 7 soil depths of soilgrids</span>
<span class="sd">            (or 6 depths intervals for soilgrids_2020).</span>
<span class="sd">            * Required variables: \</span>
<span class="sd">&#39;bd_sl*&#39; [g/cm3], &#39;clyppt_sl*&#39; [%], &#39;sltppt_sl*&#39; [%], &#39;oc_sl*&#39; [%], &#39;ph_sl*&#39; [-], \</span>
<span class="sd">&#39;sndppt_sl*&#39; [%], &#39;soilthickness&#39; [cm]</span>
<span class="sd">        ptf_ksatver : {&#39;brakensiek&#39;, &#39;cosby&#39;}</span>
<span class="sd">            Pedotransfer function (PTF) to use for calculation KsatVer</span>
<span class="sd">            (vertical saturated hydraulic conductivity [mm/day]).</span>
<span class="sd">            By default &#39;brakensiek&#39;.</span>
<span class="sd">        wflow_thicknesslayers : list of int, optional</span>
<span class="sd">            Thickness of soil layers [mm] for wflow_sbm soil model.</span>
<span class="sd">            By default [100, 300, 800] for layers at depths 100, 400, 1200 and &gt;1200 mm.</span>
<span class="sd">            Used only for Brooks Corey coefficients.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing soil parameter maps.&quot;</span><span class="p">)</span>
        <span class="c1"># TODO add variables list with required variable names</span>
        <span class="n">dsin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span><span class="n">soil_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">dsout</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">soilgrids</span><span class="p">(</span>
            <span class="n">ds</span><span class="o">=</span><span class="n">dsin</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">ptfKsatVer</span><span class="o">=</span><span class="n">ptf_ksatver</span><span class="p">,</span>
            <span class="n">soil_fn</span><span class="o">=</span><span class="n">soil_fn</span><span class="p">,</span>
            <span class="n">wflow_layers</span><span class="o">=</span><span class="n">wflow_thicknesslayers</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reset_coords</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">dsout</span><span class="p">)</span>

        <span class="c1"># Update the toml file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.thicknesslayers&quot;</span><span class="p">,</span> <span class="n">wflow_thicknesslayers</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_ksathorfrac">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_ksathorfrac.html#hydromt_wflow.WflowModel.setup_ksathorfrac">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_ksathorfrac</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ksat_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">],</span>
        <span class="n">variable</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">resampling_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;average&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set KsatHorFrac parameter values from a predetermined map.</span>

<span class="sd">        This predetermined map contains (preferably) &#39;calibrated&#39; values of \</span>
<span class="sd">the KsatHorFrac parameter. This map is either selected from the wflow Deltares data \</span>
<span class="sd">or created by a third party/ individual.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ksat_fn : str, optional</span>
<span class="sd">            The identifier of the KsatHorFrac dataset in the data catalog.</span>
<span class="sd">        variable : str | None, optional</span>
<span class="sd">            The variable name for the ksathorfrac map to use in ``ksat_fn`` in case \</span>
<span class="sd">``ksat_fn`` contains several variables. By default None.</span>
<span class="sd">        resampling_method : str, optional</span>
<span class="sd">            The resampling method when up- or downscaled, by default &quot;average&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing KsatHorFrac parameter map.&quot;</span><span class="p">)</span>

        <span class="n">dain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">ksat_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">variable</span><span class="p">,</span>
            <span class="n">single_var_as_array</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Ensure its a DataArray</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dain</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The ksathorfrac data contains several variables. </span><span class="se">\</span>
<span class="s2">Select the variable to use for ksathorfrac using &#39;variable&#39; argument.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Create scaled ksathorfrac map</span>
        <span class="n">daout</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">ksathorfrac</span><span class="p">(</span>
            <span class="n">dain</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">resampling_method</span><span class="o">=</span><span class="n">resampling_method</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Set the output variable name</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ksat_fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">bname</span> <span class="o">=</span> <span class="n">ksat_fn</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">ksat_fn</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;KsatHorFrac&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bname</span> <span class="o">=</span> <span class="n">ksat_fn</span>  <span class="c1"># base name of the outgoing layer name</span>

        <span class="n">lname</span> <span class="o">=</span> <span class="n">bname</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lname</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Set the grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">daout</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">lname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.lateral.subsurface.ksathorfrac&quot;</span><span class="p">,</span> <span class="n">lname</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_glaciers">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_glaciers.html#hydromt_wflow.WflowModel.setup_glaciers">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_glaciers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">glaciers_fn</span><span class="o">=</span><span class="s2">&quot;rgi&quot;</span><span class="p">,</span> <span class="n">min_area</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate maps of glacier areas, area fraction and volume fraction.</span>

<span class="sd">        Also generates tables with temperature threshold, melting factor and snow-to-ice</span>
<span class="sd">        convertion fraction.</span>

<span class="sd">        The data is generated from features with ``min_area`` [km2] (default is 1 km2)</span>
<span class="sd">        from a database with glacier geometry, IDs and metadata.</span>

<span class="sd">        The required variables from glaciers_fn dataset are glacier ID &#39;simple_id&#39;.</span>
<span class="sd">        Optionnally glacier area &#39;AREA&#39; [km2] can be present to filter the glaciers</span>
<span class="sd">        by size. If not present it will be computed on the fly.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **wflow_glacierareas** map: glacier IDs [-]</span>
<span class="sd">        * **wflow_glacierfrac** map: area fraction of glacier per cell [-]</span>
<span class="sd">        * **wflow_glacierstore** map: storage (volume) of glacier per cell [mm]</span>
<span class="sd">        * **G_TT** map: temperature threshold for glacier melt/buildup [°C]</span>
<span class="sd">        * **G_Cfmax** map: glacier melting factor [mm/°C*day]</span>
<span class="sd">        * **G_SIfrac** map: fraction of snowpack on top of glacier converted to ice, \</span>
<span class="sd">added to glacierstore [-]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        glaciers_fn : {&#39;rgi&#39;}</span>
<span class="sd">            Name of data source for glaciers, see data/data_sources.yml.</span>

<span class="sd">            * Required variables: [&#39;simple_id&#39;]</span>
<span class="sd">        min_area : float, optional</span>
<span class="sd">            Minimum glacier area threshold [km2], by default 0 (all included)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">glac_toml</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;model.glacier&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;state.vertical.glacierstore&quot;</span><span class="p">:</span> <span class="s2">&quot;glacierstore&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.vertical.glacierstore&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_glacierstore&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.vertical.glacierfrac&quot;</span><span class="p">:</span> <span class="s2">&quot;wflow_glacierfrac&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.vertical.g_cfmax&quot;</span><span class="p">:</span> <span class="s2">&quot;G_Cfmax&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.vertical.g_tt&quot;</span><span class="p">:</span> <span class="s2">&quot;G_TT&quot;</span><span class="p">,</span>
            <span class="s2">&quot;input.vertical.g_sifrac&quot;</span><span class="p">:</span> <span class="s2">&quot;G_SIfrac&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="c1"># retrieve data for basin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing glacier maps.&quot;</span><span class="p">)</span>
        <span class="n">gdf_org</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">glaciers_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins_highres</span><span class="p">,</span>
            <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;intersects&quot;</span><span class="p">,</span>
            <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Check if there are glaciers found</span>
        <span class="k">if</span> <span class="n">gdf_org</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skipping method, as no data has been found&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># skip small size glacier</span>
        <span class="k">if</span> <span class="s2">&quot;AREA&quot;</span> <span class="ow">in</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gdf_org</span> <span class="o">=</span> <span class="n">gdf_org</span><span class="p">[</span><span class="n">gdf_org</span><span class="p">[</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_area</span><span class="p">]</span>
        <span class="c1"># get glacier maps and parameters</span>
        <span class="n">nb_glac</span> <span class="o">=</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">size</span>
        <span class="n">ds_glac</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">nb_glac</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nb_glac</span><span class="si">}</span><span class="s2"> glaciers of sufficient size found within region.&quot;</span>
            <span class="p">)</span>
            <span class="c1"># add glacier maps</span>
            <span class="n">ds_glac</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">glaciermaps</span><span class="p">(</span>
                <span class="n">gdf</span><span class="o">=</span><span class="n">gdf_org</span><span class="p">,</span>
                <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
                <span class="n">id_column</span><span class="o">=</span><span class="s2">&quot;simple_id&quot;</span><span class="p">,</span>
                <span class="n">elevtn_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">],</span>
                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_glac</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_glac</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_org</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;glaciers&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">glac_toml</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">glac_toml</span><span class="p">[</span><span class="n">option</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;No glaciers of sufficient size found within region!&quot;</span>
                <span class="s2">&quot;Skipping glacier procedures!&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_constant_pars">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_constant_pars.html#hydromt_wflow.WflowModel.setup_constant_pars">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_constant_pars</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="n">nodata</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">999</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate constant parameter maps for all active model cells.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **param_name** map: constant parameter map.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype: str</span>
<span class="sd">            data type</span>
<span class="sd">        nodata: int or float</span>
<span class="sd">            nodata value</span>
<span class="sd">        kwargs</span>
<span class="sd">            &quot;param_name: value&quot; pairs for constant grid.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">nodata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">nodata</span><span class="p">)</span>
            <span class="n">da_param</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]],</span> <span class="n">value</span><span class="p">,</span> <span class="n">nodata</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">dtype</span>
            <span class="p">)</span>
            <span class="n">da_param</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">set_nodata</span><span class="p">(</span><span class="n">nodata</span><span class="p">)</span>

            <span class="n">da_param</span> <span class="o">=</span> <span class="n">da_param</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">da_param</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_grid_from_raster">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_grid_from_raster.html#hydromt_wflow.WflowModel.setup_grid_from_raster">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_grid_from_raster</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">raster_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">],</span>
        <span class="n">reproject_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">wflow_variables</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add data variable(s) from ``raster_fn`` to grid object.</span>

<span class="sd">        If raster is a dataset, all variables will be added unless ``variables``</span>
<span class="sd">        list is specified. The config toml can also be updated to include</span>
<span class="sd">        the new maps using ``wflow_variables``.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **raster.name** or **variables** grid: data from raster_fn</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        raster_fn: str</span>
<span class="sd">            Source name of RasterDataset in data_catalog.</span>
<span class="sd">        reproject_method: str</span>
<span class="sd">            Reprojection method from rasterio.enums.Resampling.</span>
<span class="sd">            Available methods: [&#39;nearest&#39;, &#39;bilinear&#39;, &#39;cubic&#39;, &#39;cubic_spline&#39;, \</span>
<span class="sd">&#39;lanczos&#39;, &#39;average&#39;, &#39;mode&#39;, &#39;gauss&#39;, &#39;max&#39;, &#39;min&#39;, &#39;med&#39;, &#39;q1&#39;, &#39;q3&#39;, \</span>
<span class="sd">&#39;sum&#39;, &#39;rms&#39;]</span>
<span class="sd">        variables: list, optional</span>
<span class="sd">            List of variables to add to grid from raster_fn. By default all.</span>
<span class="sd">        wflow_variables: list, optional</span>
<span class="sd">            List of corresponding wflow variables to update the config toml</span>
<span class="sd">            (e.g: [&quot;input.vertical.altitude&quot;]).</span>
<span class="sd">            Should match the variables list. variables list should be provided unless</span>
<span class="sd">            raster_fn contains a single variable (len 1).</span>
<span class="sd">        fill_method : str, optional</span>
<span class="sd">            If specified, fills nodata values using fill_nodata method.</span>
<span class="sd">            Available methods are {&#39;linear&#39;, &#39;nearest&#39;, &#39;cubic&#39;, &#39;rio_idw&#39;}.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Names of added model staticmap layers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparing grid data from raster source </span><span class="si">{</span><span class="n">raster_fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Read raster data and select variables</span>
        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">raster_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">single_var_as_array</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Fill nodata</span>
        <span class="k">if</span> <span class="n">fill_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">interpolate_na</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">fill_method</span><span class="p">)</span>
        <span class="c1"># Reprojection</span>
        <span class="n">ds_out</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">reproject_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">reproject_method</span><span class="p">)</span>
        <span class="c1"># Add to grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_out</span><span class="p">)</span>

        <span class="c1"># Update config</span>
        <span class="k">if</span> <span class="n">wflow_variables</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Updating the config for wflow_variables: </span><span class="si">{</span><span class="n">wflow_variables</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds_out</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">variables</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ds_out</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot update the toml if raster_fn has more than </span><span class="se">\</span>
<span class="s2">one variable and variables list is not provided.&quot;</span>
                    <span class="p">)</span>

            <span class="c1"># Check on len</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wflow_variables</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Length of variables </span><span class="si">{</span><span class="n">variables</span><span class="si">}</span><span class="s2"> do not match wflow_variables </span><span class="se">\</span>
<span class="si">{</span><span class="n">wflow_variables</span><span class="si">}</span><span class="s2">. Cannot update the toml.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="n">wflow_variables</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></div>


<div class="viewcode-block" id="WflowModel.setup_precip_forcing">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_precip_forcing.html#hydromt_wflow.WflowModel.setup_precip_forcing">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_precip_forcing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">precip_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">],</span>
        <span class="n">precip_clim_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate gridded precipitation forcing at model resolution.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **precip**: precipitation [mm]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        precip_fn : str, xarray.DataArray</span>
<span class="sd">            Precipitation RasterDataset source, see data/forcing_sources.yml.</span>

<span class="sd">            * Required variable: &#39;precip&#39; [mm]</span>

<span class="sd">            * Required dimension: &#39;time&#39;  [timestamp]</span>
<span class="sd">        precip_clim_fn : str, xarray.DataArray, optional</span>
<span class="sd">            High resolution climatology precipitation RasterDataset source to correct</span>
<span class="sd">            precipitation, see data/forcing_sources.yml.</span>

<span class="sd">            * Required variable: &#39;precip&#39; [mm]</span>

<span class="sd">            * Required dimension: &#39;time&#39;  [cyclic month]</span>
<span class="sd">        chunksize: int, optional</span>
<span class="sd">            Chunksize on time dimension for processing data (not for saving to disk!).</span>
<span class="sd">            If None the data chunksize is used, this can however be optimized for</span>
<span class="sd">            large/small catchments. By default None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;starttime&quot;</span><span class="p">)</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;endtime&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;timestepsecs&quot;</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="n">precip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">precip_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">time_tuple</span><span class="o">=</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">),</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;precip&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">precip</span> <span class="o">=</span> <span class="n">precip</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">chunksize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">precip</span> <span class="o">=</span> <span class="n">precip</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">chunksize</span><span class="p">})</span>

        <span class="n">clim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">precip_clim_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">clim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">precip_clim_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="n">precip</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">box</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;precip&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">clim</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="n">precip_out</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">workflows</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">precip</span><span class="p">(</span>
            <span class="n">precip</span><span class="o">=</span><span class="n">precip</span><span class="p">,</span>
            <span class="n">da_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
            <span class="n">clim</span><span class="o">=</span><span class="n">clim</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">resample_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">),</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Update meta attributes (used for default output filename later)</span>
        <span class="n">precip_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;precip_fn&quot;</span><span class="p">:</span> <span class="n">precip_fn</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">precip_clim_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">precip_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;precip_clim_fn&quot;</span><span class="p">:</span> <span class="n">precip_clim_fn</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_forcing</span><span class="p">(</span><span class="n">precip_out</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;precip&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_temp_pet_forcing">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_temp_pet_forcing.html#hydromt_wflow.WflowModel.setup_temp_pet_forcing">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_temp_pet_forcing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">temp_pet_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">],</span>
        <span class="n">pet_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;debruin&quot;</span><span class="p">,</span>
        <span class="n">press_correction</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">temp_correction</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wind_correction</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wind_altitude</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">reproj_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nearest_index&quot;</span><span class="p">,</span>
        <span class="n">dem_forcing_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skip_pet</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate gridded temperature and reference evapotranspiration forcing.</span>

<span class="sd">        If `temp_correction` is True, the temperature will be reprojected and then</span>
<span class="sd">        downscaled to model resolution using the elevation lapse rate. For better</span>
<span class="sd">        accuracy, you can provide the elevation grid of the climate data in</span>
<span class="sd">        `dem_forcing_fn`. If not present, the upscaled elevation grid of the wflow model</span>
<span class="sd">        is used (&#39;wflow_dem&#39;).</span>

<span class="sd">        To compute PET (`skip_pet` is False), several methods are available. Before</span>
<span class="sd">        computation, both the temperature and pressure can be downscaled. Wind speed</span>
<span class="sd">        should be given at 2m altitude and can be corrected if `wind_correction` is True</span>
<span class="sd">        and the wind data altitude is provided in `wind_altitude` [m].</span>
<span class="sd">        Several methods to compute pet are available: {&#39;debruin&#39;, &#39;makkink&#39;,</span>
<span class="sd">        &#39;penman-monteith_rh_simple&#39;, &#39;penman-monteith_tdew&#39;}.</span>

<span class="sd">        Depending on the methods, `temp_pet_fn` should contain temperature &#39;temp&#39; [°C],</span>
<span class="sd">        pressure &#39;press_msl&#39; [hPa], incoming shortwave radiation &#39;kin&#39; [W/m2], outgoing</span>
<span class="sd">        shortwave radiation &#39;kout&#39; [W/m2], wind speed &#39;wind&#39; [m/s], relative humidity</span>
<span class="sd">        &#39;rh&#39; [%], dew point temperature &#39;temp_dew&#39; [°C], wind speed either total &#39;wind&#39;</span>
<span class="sd">        or the U- &#39;wind10_u&#39; [m/s] and V- &#39;wind10_v&#39; components [m/s].</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **pet**: reference evapotranspiration [mm]</span>
<span class="sd">        * **temp**: temperature [°C]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        temp_pet_fn : str, xarray.Dataset</span>
<span class="sd">            Name or path of RasterDataset source with variables to calculate temperature</span>
<span class="sd">            and reference evapotranspiration, see data/forcing_sources.yml.</span>

<span class="sd">            * Required variable for temperature: &#39;temp&#39; [°C]</span>

<span class="sd">            * Required variables for De Bruin reference evapotranspiration: \</span>
<span class="sd">&#39;temp&#39; [°C], &#39;press_msl&#39; [hPa], &#39;kin&#39; [W/m2], &#39;kout&#39; [W/m2]</span>

<span class="sd">            * Required variables for Makkink reference evapotranspiration: \</span>
<span class="sd">&#39;temp&#39; [°C], &#39;press_msl&#39; [hPa], &#39;kin&#39;[W/m2]</span>

<span class="sd">            * Required variables for daily Penman-Monteith \</span>
<span class="sd">reference evapotranspiration: \</span>
<span class="sd">either {&#39;temp&#39; [°C], &#39;temp_min&#39; [°C], &#39;temp_max&#39; [°C], &#39;wind&#39; [m/s], &#39;rh&#39; [%], &#39;kin&#39; \</span>
<span class="sd">[W/m2]} for &#39;penman-monteith_rh_simple&#39; or {&#39;temp&#39; [°C], &#39;temp_min&#39; [°C], &#39;temp_max&#39; \</span>
<span class="sd">[°C], &#39;temp_dew&#39; [°C], &#39;wind&#39; [m/s], &#39;kin&#39; [W/m2], &#39;press_msl&#39; [hPa], &#39;wind10_u&#39; [m/s],\</span>
<span class="sd">&quot;wind10_v&quot; [m/s]} for &#39;penman-monteith_tdew&#39; (these are the variables available in ERA5)</span>
<span class="sd">        pet_method : {&#39;debruin&#39;, &#39;makkink&#39;, &#39;penman-monteith_rh_simple&#39;, \</span>
<span class="sd">&#39;penman-monteith_tdew&#39;}, optional</span>
<span class="sd">            Reference evapotranspiration method, by default &#39;debruin&#39;.</span>
<span class="sd">            If penman-monteith is used, requires the installation of the pyet package.</span>
<span class="sd">        press_correction, temp_correction : bool, optional</span>
<span class="sd">            If True pressure, temperature are corrected using elevation lapse rate,</span>
<span class="sd">            by default False.</span>
<span class="sd">        dem_forcing_fn : str, default None</span>
<span class="sd">            Elevation data source with coverage of entire meteorological forcing domain.</span>
<span class="sd">            If temp_correction is True and dem_forcing_fn is provided this is used in</span>
<span class="sd">            combination with elevation at model resolution to correct the temperature.</span>

<span class="sd">            * Required variable: &#39;elevtn&#39; [m+REF]</span>
<span class="sd">        wind_correction : bool, optional</span>
<span class="sd">            If True wind speed is corrected to wind at 2m altitude using</span>
<span class="sd">            ``wind_altitude``. By default True.</span>
<span class="sd">        wind_altitude : int, optional</span>
<span class="sd">            Altitude of wind speed [m] variable, by default 10. Only used if</span>
<span class="sd">            ``wind_correction`` is True.</span>
<span class="sd">        skip_pet : bool, optional</span>
<span class="sd">            If True calculate temp only.</span>
<span class="sd">        reproj_method : str, optional</span>
<span class="sd">            Reprojection method from rasterio.enums.Resampling. to reproject the climate</span>
<span class="sd">            data to the model resolution. By default &#39;nearest_index&#39;.</span>
<span class="sd">        chunksize: int, optional</span>
<span class="sd">            Chunksize on time dimension for processing data (not for saving to disk!).</span>
<span class="sd">            If None the data chunksize is used, this can however be optimized for</span>
<span class="sd">            large/small catchments. By default None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;starttime&quot;</span><span class="p">)</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;endtime&quot;</span><span class="p">)</span>
        <span class="n">timestep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;timestepsecs&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_pet</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pet_method</span> <span class="o">==</span> <span class="s2">&quot;debruin&quot;</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;press_msl&quot;</span><span class="p">,</span> <span class="s2">&quot;kin&quot;</span><span class="p">,</span> <span class="s2">&quot;kout&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">pet_method</span> <span class="o">==</span> <span class="s2">&quot;makkink&quot;</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;press_msl&quot;</span><span class="p">,</span> <span class="s2">&quot;kin&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">pet_method</span> <span class="o">==</span> <span class="s2">&quot;penman-monteith_rh_simple&quot;</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;temp_min&quot;</span><span class="p">,</span> <span class="s2">&quot;temp_max&quot;</span><span class="p">,</span> <span class="s2">&quot;wind&quot;</span><span class="p">,</span> <span class="s2">&quot;rh&quot;</span><span class="p">,</span> <span class="s2">&quot;kin&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">pet_method</span> <span class="o">==</span> <span class="s2">&quot;penman-monteith_tdew&quot;</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="s2">&quot;temp_min&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;temp_max&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;wind10_u&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;wind10_v&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;temp_dew&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;kin&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;press_msl&quot;</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s2">&quot;debruin&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;makkink&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;penman-monteith_rh_simple&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;penman-monteith_tdew&quot;</span><span class="p">,</span>
                <span class="p">]</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unknown pet method </span><span class="si">{</span><span class="n">pet_method</span><span class="si">}</span><span class="s2">, select from </span><span class="si">{</span><span class="n">methods</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">temp_pet_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">time_tuple</span><span class="o">=</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">),</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">single_var_as_array</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># always return dataset</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">chunksize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">chunksize</span><span class="p">})</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="n">dem_forcing</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">dem_forcing_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dem_forcing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">dem_forcing_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">box</span><span class="p">,</span>  <span class="c1"># clip dem with forcing bbox for full coverage</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">],</span>
            <span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">dem_forcing</span> <span class="o">=</span> <span class="n">dem_forcing</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="n">temp_in</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">workflows</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">temp</span><span class="p">(</span>
            <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">],</span>
            <span class="n">dem_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
            <span class="n">dem_forcing</span><span class="o">=</span><span class="n">dem_forcing</span><span class="p">,</span>
            <span class="n">lapse_correction</span><span class="o">=</span><span class="n">temp_correction</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># resample time after pet workflow</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="s2">&quot;penman-monteith&quot;</span> <span class="ow">in</span> <span class="n">pet_method</span>
        <span class="p">):</span>  <span class="c1"># also downscaled temp_min and temp_max for Penman needed</span>
            <span class="n">temp_max_in</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">workflows</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">temp</span><span class="p">(</span>
                <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;temp_max&quot;</span><span class="p">],</span>
                <span class="n">dem_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
                <span class="n">dem_forcing</span><span class="o">=</span><span class="n">dem_forcing</span><span class="p">,</span>
                <span class="n">lapse_correction</span><span class="o">=</span><span class="n">temp_correction</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># resample time after pet workflow</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">temp_max_in</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;temp_max&quot;</span>

            <span class="n">temp_min_in</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">workflows</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">temp</span><span class="p">(</span>
                <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;temp_min&quot;</span><span class="p">],</span>
                <span class="n">dem_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
                <span class="n">dem_forcing</span><span class="o">=</span><span class="n">dem_forcing</span><span class="p">,</span>
                <span class="n">lapse_correction</span><span class="o">=</span><span class="n">temp_correction</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># resample time after pet workflow</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">temp_min_in</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;temp_min&quot;</span>

            <span class="n">temp_in</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">temp_in</span><span class="p">,</span> <span class="n">temp_max_in</span><span class="p">,</span> <span class="n">temp_min_in</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_pet</span><span class="p">:</span>
            <span class="n">pet_out</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">workflows</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">pet</span><span class="p">(</span>
                <span class="n">ds</span><span class="p">[</span><span class="n">variables</span><span class="p">[</span><span class="mi">1</span><span class="p">:]],</span>
                <span class="n">temp</span><span class="o">=</span><span class="n">temp_in</span><span class="p">,</span>
                <span class="n">dem_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
                <span class="n">method</span><span class="o">=</span><span class="n">pet_method</span><span class="p">,</span>
                <span class="n">press_correction</span><span class="o">=</span><span class="n">press_correction</span><span class="p">,</span>
                <span class="n">wind_correction</span><span class="o">=</span><span class="n">wind_correction</span><span class="p">,</span>
                <span class="n">wind_altitude</span><span class="o">=</span><span class="n">wind_altitude</span><span class="p">,</span>
                <span class="n">reproj_method</span><span class="o">=</span><span class="n">reproj_method</span><span class="p">,</span>
                <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                <span class="n">resample_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">),</span>
                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Update meta attributes with setup opt</span>
            <span class="n">opt_attr</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;pet_fn&quot;</span><span class="p">:</span> <span class="n">temp_pet_fn</span><span class="p">,</span>
                <span class="s2">&quot;pet_method&quot;</span><span class="p">:</span> <span class="n">pet_method</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">pet_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">opt_attr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_forcing</span><span class="p">(</span><span class="n">pet_out</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;pet&quot;</span><span class="p">)</span>

        <span class="c1"># make sure only temp is written to netcdf</span>
        <span class="k">if</span> <span class="s2">&quot;penman-monteith&quot;</span> <span class="ow">in</span> <span class="n">pet_method</span><span class="p">:</span>
            <span class="n">temp_in</span> <span class="o">=</span> <span class="n">temp_in</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">]</span>
        <span class="c1"># resample temp after pet workflow</span>
        <span class="n">temp_out</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">workflows</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">resample_time</span><span class="p">(</span>
            <span class="n">temp_in</span><span class="p">,</span>
            <span class="n">freq</span><span class="p">,</span>
            <span class="n">upsampling</span><span class="o">=</span><span class="s2">&quot;bfill&quot;</span><span class="p">,</span>  <span class="c1"># we assume right labeled original data</span>
            <span class="n">downsampling</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span>
            <span class="n">closed</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span>
            <span class="n">conserve_mass</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Update meta attributes with setup opt (used for default naming later)</span>
        <span class="n">opt_attr</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;temp_fn&quot;</span><span class="p">:</span> <span class="n">temp_pet_fn</span><span class="p">,</span>
            <span class="s2">&quot;temp_correction&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">temp_correction</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="n">temp_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">opt_attr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_forcing</span><span class="p">(</span><span class="n">temp_out</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_pet_forcing">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_pet_forcing.html#hydromt_wflow.WflowModel.setup_pet_forcing">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_pet_forcing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pet_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">],</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare PET forcing from existig PET data.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **pet**: reference evapotranspiration [mm]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pet_fn: str, xr.DataArray</span>
<span class="sd">            RasterDataset source or data for PET to be resampled.</span>

<span class="sd">            * Required variable: &#39;pet&#39; [mm]</span>

<span class="sd">        chunksize: int, optional</span>
<span class="sd">            Chunksize on time dimension for processing data (not for saving to disk!).</span>
<span class="sd">            If None the data chunksize is used, this can however be optimized for</span>
<span class="sd">            large/small catchments. By default None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing potential evapotranspiration forcing maps.&quot;</span><span class="p">)</span>

        <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;starttime&quot;</span><span class="p">)</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;endtime&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;timestepsecs&quot;</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>

        <span class="n">pet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">pet_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">],</span>
            <span class="n">time_tuple</span><span class="o">=</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">pet</span> <span class="o">=</span> <span class="n">pet</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="n">pet_out</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">pet</span><span class="p">(</span>
            <span class="n">pet</span><span class="o">=</span><span class="n">pet</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">mask_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">],</span>
            <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Update meta attributes (used for default output filename later)</span>
        <span class="n">pet_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;pet_fn&quot;</span><span class="p">:</span> <span class="n">pet_fn</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_forcing</span><span class="p">(</span><span class="n">pet_out</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;pet&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_rootzoneclim">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_rootzoneclim.html#hydromt_wflow.WflowModel.setup_rootzoneclim">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_rootzoneclim</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">run_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">],</span>
        <span class="n">forcing_obs_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">],</span>
        <span class="n">forcing_cc_hist_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">forcing_cc_fut_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">return_period</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
        <span class="n">Imax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">start_hydro_year</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Sep&quot;</span><span class="p">,</span>
        <span class="n">start_field_capacity</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Apr&quot;</span><span class="p">,</span>
        <span class="n">LAI</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">rootzone_storage</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">correct_cc_deficit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">time_tuple</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">time_tuple_fut</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">missing_days_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">330</span><span class="p">,</span>
        <span class="n">update_toml_rootingdepth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;RootingDepth_obs_20&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the RootingDepth.</span>

<span class="sd">        Done by estimating the catchment-scale root-zone storage capacity from observed</span>
<span class="sd">        hydroclimatic data (and optionally also for climate change historical and</span>
<span class="sd">        future periods).</span>

<span class="sd">        This presents an alternative approach to determine the RootingDepth</span>
<span class="sd">        based on hydroclimatic data instead of through a look-up table relating</span>
<span class="sd">        land use to rooting depth (as usually done for the wflow_sbm model).</span>
<span class="sd">        The method is based on the estimation of maximum annual storage deficits</span>
<span class="sd">        based on precipitation and estimated actual evaporation time series,</span>
<span class="sd">        which in turn are estimated from observed streamflow data and</span>
<span class="sd">        long-term precipitation and potential evap. data, as explained in</span>
<span class="sd">        Bouaziz et al. (2022).</span>

<span class="sd">        The main assumption is that vegetation adapts its rootzone storage capacity</span>
<span class="sd">        to overcome dry spells with a certain return period (typically 20 years for</span>
<span class="sd">        forest ecosystems). In response to a changing climtate,</span>
<span class="sd">        it is likely that vegetation also adapts its rootzone storage capacity,</span>
<span class="sd">        thereby changing model parameters for future conditions.</span>
<span class="sd">        This method also allows to estimate the change in rootzone storage capacity</span>
<span class="sd">        in response to a changing climate.</span>

<span class="sd">        As the method requires precipitation and potential evaporation timeseries,</span>
<span class="sd">        it may be useful to run this method as an update step in the setting-up of</span>
<span class="sd">        the hydrological model, once the forcing files have already been derived.</span>
<span class="sd">        In addition the setup_soilmaps method is also required to calculate</span>
<span class="sd">        the RootingDepth (rootzone_storage / (thetaS-thetaR)).</span>
<span class="sd">        The setup_laimaps method is also required if LAI is set to True</span>
<span class="sd">        (interception capacity estimated from LAI maps, instead of providing</span>
<span class="sd">        a default maximum interception capacity).</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Bouaziz, L. J. E., Aalbers, E. E., Weerts, A. H., Hegnauer, M., Buiteveld,</span>
<span class="sd">        H., Lammersen, R., Stam, J., Sprokkereef, E., Savenije, H. H. G. and</span>
<span class="sd">        Hrachowitz, M. (2022). Ecosystem adaptation to climate change: the</span>
<span class="sd">        sensitivity of hydrological predictions to time-dynamic model parameters,</span>
<span class="sd">        Hydrology and Earth System Sciences, 26(5), 1295-1318. DOI:</span>
<span class="sd">        10.5194/hess-26-1295-2022.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **RootingDepth_{forcing}_{RP}** map: rooting depth [mm of the soil column] \</span>
<span class="sd">estimated from hydroclimatic data {forcing: obs, cc_hist or cc_fut} for different \</span>
<span class="sd">return periods RP. The translation to RootingDepth is done by dividing \</span>
<span class="sd">the rootzone_storage by (thetaS - thetaR).</span>
<span class="sd">        * **rootzone_storage_{forcing}_{RP}** geom: polygons of rootzone \</span>
<span class="sd">storage capacity [mm of water] for each catchment estimated before filling \</span>
<span class="sd">the missings with data from downstream catchments.</span>
<span class="sd">        * **rootzone_storage_{forcing}_{RP}** map: rootzone storage capacity \</span>
<span class="sd">[mm of water] estimated from hydroclimatic data {forcing: obs, cc_hist or cc_fut} for \</span>
<span class="sd">different return periods RP. Only if rootzone_storage is set to True!</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_fn : str, Path, xr.Dataset</span>
<span class="sd">            Geodataset with streamflow timeseries (m3/s) per x,y location.</span>
<span class="sd">            The geodataset expects the coordinate names &quot;index&quot; (for each station id)</span>
<span class="sd">            and the variable name &quot;discharge&quot;.</span>
<span class="sd">        forcing_obs_fn : str, Path, xr.Dataset</span>
<span class="sd">            Gridded timeseries with the observed forcing [mm/timestep].</span>
<span class="sd">            Expects to have variables &quot;precip&quot; and &quot;pet&quot;.</span>
<span class="sd">        forcing_cc_hist_fn : str, Path, xr.Dataset, optional</span>
<span class="sd">            Gridded timeseries with the simulated historical forcing [mm/timestep],</span>
<span class="sd">            based on a climate model. Expects to have variables &quot;precip&quot; and &quot;pet&quot;.</span>
<span class="sd">            The default is None.</span>
<span class="sd">        forcing_cc_fut_fn : str, optional</span>
<span class="sd">            Gridded timeseries with the simulated climate forcing [mm/timestep],</span>
<span class="sd">            based on a climate model. Expects to have variables &quot;precip&quot; and &quot;pet&quot;.</span>
<span class="sd">            The default is None.</span>
<span class="sd">        chunksize : int, optional</span>
<span class="sd">            Chunksize on time dimension for processing data (not for saving to</span>
<span class="sd">            disk!). The default is 100.</span>
<span class="sd">        return_period : list, optional</span>
<span class="sd">            List with one or more values indiciating the return period(s) (in</span>
<span class="sd">            years) for wich the rootzone storage depth should be calculated. The</span>
<span class="sd">            default is [2,3,5,10,15,20,25,50,60,100] years.</span>
<span class="sd">        Imax : float, optional</span>
<span class="sd">            The maximum interception storage capacity [mm]. The default is 2.0 mm.</span>
<span class="sd">        start_hydro_year : str, optional</span>
<span class="sd">            The start month (abreviated to the first three letters of the month,</span>
<span class="sd">            starting with a capital letter) of the hydrological year. The</span>
<span class="sd">            default is &#39;Sep&#39;.</span>
<span class="sd">        start_field_capacity : str, optional</span>
<span class="sd">            The end of the wet season / commencement of dry season. This is the</span>
<span class="sd">            moment when the soil is at field capacity, i.e. there is no storage</span>
<span class="sd">            deficit yet. The default is &#39;Apr&#39;.</span>
<span class="sd">        LAI : bool, optional</span>
<span class="sd">            Determine whether the LAI will be used to determine Imax. The</span>
<span class="sd">            default is False.</span>
<span class="sd">            If set to True, requires to have run setup_laimaps.</span>
<span class="sd">        rootzone_storage : bool, optional</span>
<span class="sd">            Determines whether the rootzone storage maps</span>
<span class="sd">            should be stored in the grid or not. The default is False.</span>
<span class="sd">        correct_cc_deficit : bool, optional</span>
<span class="sd">            Determines whether a bias-correction of the future deficit should be</span>
<span class="sd">            applied using the cc_hist deficit. Only works if the time periods of</span>
<span class="sd">            cc_hist and cc_fut are the same. If the climate change scenario and</span>
<span class="sd">            hist period are bias-corrected, this should probably set to False.</span>
<span class="sd">            The default is False.</span>
<span class="sd">        time_tuple: tuple, optional</span>
<span class="sd">            Select which time period to read from all the forcing files.</span>
<span class="sd">            There should be some overlap between the time period available in the</span>
<span class="sd">            forcing files for the historical period and in the observed streamflow data.</span>
<span class="sd">        missing_days_threshold: int, optional</span>
<span class="sd">            Minimum number of days within a year for that year to be counted in</span>
<span class="sd">            the long-term Budyko analysis.</span>
<span class="sd">        update_toml_rootingdepth: str, optional</span>
<span class="sd">            Update the wflow_sbm model config of the RootingDepth variable with</span>
<span class="sd">            the estimated RootingDepth.</span>
<span class="sd">            The default is RootingDepth_obs_20,</span>
<span class="sd">            which requires to have RP 20 in the list provided for \</span>
<span class="sd">the return_period argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing climate based root zone storage parameter maps.&quot;</span><span class="p">)</span>
        <span class="c1"># Open the data sets</span>
        <span class="n">ds_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">forcing_obs_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">,</span> <span class="s2">&quot;precip&quot;</span><span class="p">],</span>
            <span class="n">time_tuple</span><span class="o">=</span><span class="n">time_tuple</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ds_cc_hist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">forcing_cc_hist_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ds_cc_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">forcing_cc_hist_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">,</span> <span class="s2">&quot;precip&quot;</span><span class="p">],</span>
                <span class="n">time_tuple</span><span class="o">=</span><span class="n">time_tuple</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">ds_cc_fut</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">forcing_cc_fut_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ds_cc_fut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">forcing_cc_fut_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">,</span> <span class="s2">&quot;precip&quot;</span><span class="p">],</span>
                <span class="n">time_tuple</span><span class="o">=</span><span class="n">time_tuple_fut</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># observed streamflow data</span>
        <span class="n">dsrun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataset</span><span class="p">(</span>
            <span class="n">run_fn</span><span class="p">,</span> <span class="n">single_var_as_array</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">time_tuple</span><span class="o">=</span><span class="n">time_tuple</span>
        <span class="p">)</span>

        <span class="c1"># make sure dsrun overlaps with ds_obs, otherwise give error</span>
        <span class="k">if</span> <span class="n">dsrun</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ds_obs</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">dsrun</span> <span class="o">=</span> <span class="n">dsrun</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">ds_obs</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dsrun</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ds_obs</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">dsrun</span> <span class="o">=</span> <span class="n">dsrun</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">ds_obs</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dsrun</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;No overlapping period between the meteo and observed streamflow data&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check if setup_soilmaps and setup_laimaps were run if LAI =True and</span>
        <span class="c1"># if rooting_depth = True&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">LAI</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;LAI&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;LAI variable not found in grid. </span><span class="se">\</span>
<span class="s2">Set LAI to False or run setup_laimaps first&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;thetaR&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;thetaS&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;thetaS or thetaR variables not found in grid. </span><span class="se">\</span>
<span class="s2">Run setup_soilmaps first&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Run the rootzone clim workflow</span>
        <span class="n">dsout</span><span class="p">,</span> <span class="n">gdf</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">rootzoneclim</span><span class="p">(</span>
            <span class="n">dsrun</span><span class="o">=</span><span class="n">dsrun</span><span class="p">,</span>
            <span class="n">ds_obs</span><span class="o">=</span><span class="n">ds_obs</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span>
            <span class="n">ds_cc_hist</span><span class="o">=</span><span class="n">ds_cc_hist</span><span class="p">,</span>
            <span class="n">ds_cc_fut</span><span class="o">=</span><span class="n">ds_cc_fut</span><span class="p">,</span>
            <span class="n">return_period</span><span class="o">=</span><span class="n">return_period</span><span class="p">,</span>
            <span class="n">Imax</span><span class="o">=</span><span class="n">Imax</span><span class="p">,</span>
            <span class="n">start_hydro_year</span><span class="o">=</span><span class="n">start_hydro_year</span><span class="p">,</span>
            <span class="n">start_field_capacity</span><span class="o">=</span><span class="n">start_field_capacity</span><span class="p">,</span>
            <span class="n">LAI</span><span class="o">=</span><span class="n">LAI</span><span class="p">,</span>
            <span class="n">rootzone_storage</span><span class="o">=</span><span class="n">rootzone_storage</span><span class="p">,</span>
            <span class="n">correct_cc_deficit</span><span class="o">=</span><span class="n">correct_cc_deficit</span><span class="p">,</span>
            <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
            <span class="n">missing_days_threshold</span><span class="o">=</span><span class="n">missing_days_threshold</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># set nodata value outside basin</span>
        <span class="n">dsout</span> <span class="o">=</span> <span class="n">dsout</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">999</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">dsout</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="n">dsout</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">set_nodata</span><span class="p">(</span><span class="o">-</span><span class="mi">999</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">dsout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;rootzone_storage&quot;</span><span class="p">)</span>

        <span class="c1"># update config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.vertical.rootingdepth&quot;</span><span class="p">,</span> <span class="n">update_toml_rootingdepth</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_1dmodel_connection">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_1dmodel_connection.html#hydromt_wflow.WflowModel.setup_1dmodel_connection">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_1dmodel_connection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">river1d_fn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">],</span>
        <span class="n">connection_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;subbasin_area&quot;</span><span class="p">,</span>
        <span class="n">area_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">30.0</span><span class="p">,</span>
        <span class="n">add_tributaries</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">include_river_boundaries</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mapname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;1dmodel&quot;</span><span class="p">,</span>
        <span class="n">update_toml</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">toml_output</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;netcdf&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Connect wflow to a 1D model by deriving linked subcatch (and tributaries).</span>

<span class="sd">        There are two methods to connect models:</span>

<span class="sd">        - `subbasin_area`:</span>
<span class="sd">            creates subcatchments linked to the 1d river based</span>
<span class="sd">            on an area threshold (area_max) for the subbasin size. With this method,</span>
<span class="sd">            if a tributary is larger than the `area_max`, it will be connected to</span>
<span class="sd">            the 1d river directly.</span>
<span class="sd">        - `nodes`:</span>
<span class="sd">            subcatchments are derived based on the 1driver nodes (used as</span>
<span class="sd">            gauges locations). With this method, large tributaries can also be derived</span>
<span class="sd">            separately using the `add_tributaries` option and adding a `area_max`</span>
<span class="sd">            threshold for the tributaries.</span>

<span class="sd">        If `add_tributary` option is on, you can decide to include or exclude the</span>
<span class="sd">        upstream boundary of the 1d river as an additional tributary using the</span>
<span class="sd">        `include_river_boundaries` option.</span>

<span class="sd">        River edges or river nodes are snapped to the closest downstream wflow river</span>
<span class="sd">        cell using the :py:meth:`hydromt.flw.gauge_map` method.</span>

<span class="sd">        Optionally, the toml file can also be updated to save lateral.river.inwater to</span>
<span class="sd">        save all river inflows for the subcatchments and lateral.river.q_av for the</span>
<span class="sd">        tributaries using :py:meth:`hydromt_wflow.wflow.setup_config_output_timeseries`.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **wflow_subcatch_{mapname}** map/geom:  connection subbasins between</span>
<span class="sd">          wflow and the 1D model.</span>
<span class="sd">        * **wflow_subcatch_riv_{mapname}** map/geom:  connection subbasins between</span>
<span class="sd">          wflow and the 1D model for river cells only.</span>
<span class="sd">        * **wflow_gauges_{mapname}** map/geom, optional: outlets of the tributaries</span>
<span class="sd">          flowing into the 1D model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        river1d_fn : str, Path, gpd.GeoDataFrame</span>
<span class="sd">            GeodataFrame with the 1D model river network and nodes where to derive</span>
<span class="sd">            subbasins for connection_method **nodes**.</span>
<span class="sd">        connection_method : str, default subbasin_area</span>
<span class="sd">            Method to connect wflow to the 1D model. Available methods are {</span>
<span class="sd">                &#39;subbasin_area&#39;, &#39;nodes&#39;}.</span>
<span class="sd">        area_max : float, default 10.0</span>
<span class="sd">            Maximum area [km2] of the subbasins to connect to the 1D model in km2 with</span>
<span class="sd">            connection_method **subbasin_area** or **nodes** with add_tributaries</span>
<span class="sd">            set to True.</span>
<span class="sd">        add_tributaries : bool, default True</span>
<span class="sd">            If True, derive tributaries for the subbasins larger than area_max. Always</span>
<span class="sd">            True for **subbasin_area** method.</span>
<span class="sd">        include_river_boundaries : bool, default True</span>
<span class="sd">            If True, include the upstream boundary(ies) of the 1d river as an</span>
<span class="sd">            additional tributary(ies).</span>
<span class="sd">        mapname : str, default 1dmodel</span>
<span class="sd">            Name of the map to save the subcatchments and tributaries in the wflow model</span>
<span class="sd">            staticmaps and geoms (wflow_subcatch_{mapname}).</span>
<span class="sd">        update_toml : bool, default True</span>
<span class="sd">            If True, updates the wflow configuration file to save the required outputs</span>
<span class="sd">            for the 1D model.</span>
<span class="sd">        toml_output : str, optional</span>
<span class="sd">            One of [&#39;csv&#39;, &#39;netcdf&#39;, None] to update [csv] or [netcdf] section of wflow</span>
<span class="sd">            toml file or do nothing. By default, &#39;netcdf&#39;.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments passed to the snapping method</span>
<span class="sd">            hydromt.flw.gauge_map. See its documentation for more information.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hydromt.flw.gauge_map</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check connection method values</span>
        <span class="k">if</span> <span class="n">connection_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;subbasin_area&quot;</span><span class="p">,</span> <span class="s2">&quot;nodes&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown connection method </span><span class="si">{</span><span class="n">connection_method</span><span class="si">}</span><span class="s2">,&quot;</span>
                <span class="s2">&quot;select from [&#39;subbasin_area&#39;, &#39;nodes&#39;]&quot;</span>
            <span class="p">)</span>
        <span class="c1"># read 1d model river network</span>
        <span class="n">gdf_riv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">river1d_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># derive subcatchments and tributaries</span>
        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">}</span>
        <span class="n">ds_out</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">wflow_1dmodel_connection</span><span class="p">(</span>
            <span class="n">gdf_riv</span><span class="p">,</span>
            <span class="n">ds_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">connection_method</span><span class="o">=</span><span class="n">connection_method</span><span class="p">,</span>
            <span class="n">area_max</span><span class="o">=</span><span class="n">area_max</span><span class="p">,</span>
            <span class="n">add_tributaries</span><span class="o">=</span><span class="n">add_tributaries</span><span class="p">,</span>
            <span class="n">include_river_boundaries</span><span class="o">=</span><span class="n">include_river_boundaries</span><span class="p">,</span>
            <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Derive tributary gauge map</span>
        <span class="k">if</span> <span class="s2">&quot;gauges&quot;</span> <span class="ow">in</span> <span class="n">ds_out</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;gauges&quot;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;wflow_gauges_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Derive the gauges staticgeoms</span>
            <span class="n">gdf_tributary</span> <span class="o">=</span> <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;gauges&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">vectorize</span><span class="p">()</span>
            <span class="n">gdf_tributary</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_tributary</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>
            <span class="n">gdf_tributary</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_tributary</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;gauges&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_tributary</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;gauges_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Add a check that all gauges are on the river</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">gdf_tributary</span><span class="p">)</span>
                <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">nodata</span>
            <span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">river_upa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;river_upa&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Not all tributary gauges are on the river network and river &quot;</span>
                    <span class="s2">&quot;discharge canot be saved. You should use a higher threshold &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for the subbasin area than </span><span class="si">{</span><span class="n">area_max</span><span class="si">}</span><span class="s2"> to match better the &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;wflow river in your model </span><span class="si">{</span><span class="n">river_upa</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="n">all_gauges_on_river</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_gauges_on_river</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Update toml</span>
            <span class="k">if</span> <span class="n">update_toml</span> <span class="ow">and</span> <span class="n">all_gauges_on_river</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setup_config_output_timeseries</span><span class="p">(</span>
                    <span class="n">mapname</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;wflow_gauges_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">toml_output</span><span class="o">=</span><span class="n">toml_output</span><span class="p">,</span>
                    <span class="n">header</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">],</span>
                    <span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lateral.river.q_av&quot;</span><span class="p">],</span>
                    <span class="n">reducer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># Derive subcatchment map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch&quot;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;wflow_subcatch_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">gdf_subcatch</span> <span class="o">=</span> <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">vectorize</span><span class="p">()</span>
        <span class="n">gdf_subcatch</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_subcatch</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_subcatch</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;subcatch_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Subcatchment map for river cells only (to be able to save river outputs</span>
        <span class="c1"># in wflow)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch_riv&quot;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;wflow_subcatch_riv_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">gdf_subcatch_riv</span> <span class="o">=</span> <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch_riv&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">vectorize</span><span class="p">()</span>
        <span class="n">gdf_subcatch_riv</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_subcatch_riv</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf_subcatch_riv</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;subcatch_riv_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Update toml</span>
        <span class="k">if</span> <span class="n">update_toml</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setup_config_output_timeseries</span><span class="p">(</span>
                <span class="n">mapname</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;wflow_subcatch_riv_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">toml_output</span><span class="o">=</span><span class="n">toml_output</span><span class="p">,</span>
                <span class="n">header</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Qlat&quot;</span><span class="p">],</span>
                <span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lateral.river.inwater&quot;</span><span class="p">],</span>
                <span class="n">reducer</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sum&quot;</span><span class="p">],</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.setup_cold_states">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.setup_cold_states.html#hydromt_wflow.WflowModel.setup_cold_states">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_cold_states</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">timestamp</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare cold states for Wflow.</span>

<span class="sd">        To be run last as this requires some soil parameters or constant_pars to be</span>
<span class="sd">        computed already.</span>

<span class="sd">        To be run after setup_lakes, setup_reservoirs and setup_glaciers to also create</span>
<span class="sd">        cold states for them if they are present in the basin.</span>

<span class="sd">        This function is mainly useful in case the wflow model is read into Delft-FEWS.</span>

<span class="sd">        Adds model layer:</span>
<span class="sd">        * **satwaterdepth**: saturated store [mm]</span>
<span class="sd">        * **snow**: snow storage [mm]</span>
<span class="sd">        * **tsoil**: top soil temperature [°C]</span>
<span class="sd">        * **ustorelayerdepth**: amount of water in the unsaturated store, per layer [mm]</span>
<span class="sd">        * **snowwater**: liquid water content in the snow pack [mm]</span>
<span class="sd">        * **canopystorage**: canopy storage [mm]</span>
<span class="sd">        * **q_river**: river discharge [m3/s]</span>
<span class="sd">        * **h_river**: river water level [m]</span>
<span class="sd">        * **h_av_river**: river average water level [m]</span>
<span class="sd">        * **ssf**: subsurface flow [m3/d]</span>
<span class="sd">        * **h_land**: land water level [m]</span>
<span class="sd">        * **h_av_land**: land average water level[m]</span>
<span class="sd">        * **q_land** or **qx_land**+**qy_land**: overland flow for kinwave [m3/s] or</span>
<span class="sd">            overland flow in x/y directions for local-inertial [m3/s]</span>

<span class="sd">        If lakes, also adds:</span>
<span class="sd">        * **waterlevel_lake**: lake water level [m]</span>

<span class="sd">        If reservoirs, also adds:</span>
<span class="sd">        * **volume_reservoir**: reservoir volume [m3]</span>

<span class="sd">        If glaciers, also adds:</span>
<span class="sd">        * **glacierstore**: water within the glacier [mm]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestamp : str, optional</span>
<span class="sd">            Timestamp of the cold states. By default uses the (starttime - timestepsecs)</span>
<span class="sd">            from the config.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">states_config</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">prepare_cold_states</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span>
            <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_states</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>

        <span class="c1"># Update config to read the states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.reinit&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Update states variables names in config</span>
        <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">states_config</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">states_config</span><span class="p">[</span><span class="n">option</span><span class="p">])</span></div>


    <span class="c1"># I/O</span>
<div class="viewcode-block" id="WflowModel.read">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.read.html#hydromt_wflow.WflowModel.read">[docs]</a>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the complete model schematization and configuration from file.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_config</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_grid</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_intbl</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_tables</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_geoms</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_states</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_forcing</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Model read&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.write">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.write.html#hydromt_wflow.WflowModel.write">[docs]</a>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write the complete model schematization and configuration to file.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Write model data to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># if in r, r+ mode, only write updated components</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot write in read-only mode&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_data_catalog</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">:</span>  <span class="c1"># try to read default if not yet set</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_config</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_grid</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_tables</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geoms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_geoms</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_states</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_states</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_forcing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_forcing</span><span class="p">()</span></div>


<div class="viewcode-block" id="WflowModel.read_grid">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.read_grid.html#hydromt_wflow.WflowModel.read_grid">[docs]</a>
    <span class="k">def</span> <span class="nf">read_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read wflow static input and add to ``grid``.</span>

<span class="sd">        Checks the path of the file in the config toml using both ``input.path_static``</span>
<span class="sd">        and ``dir_input``. If not found uses the default path ``staticmaps.nc`` in the</span>
<span class="sd">        root folder.</span>

<span class="sd">        If the file is not found, will try to read from the old PCRaster format if map</span>
<span class="sd">        files are found in the ``staticmaps`` folder in the root folder using</span>
<span class="sd">        read_staticmaps_pcr.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read_staticmaps_pcr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fn_default</span> <span class="o">=</span> <span class="s2">&quot;staticmaps.nc&quot;</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
            <span class="s2">&quot;input.path_static&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">fn_default</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">input_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span>
                <span class="n">input_dir</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;input.path_static&quot;</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="n">fn_default</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input directory found </span><span class="si">{</span><span class="n">input_dir</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="c1"># start fresh in read-only mode</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isfile</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read grid from </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># FIXME: we need a smarter (lazy) solution for big models which also</span>
            <span class="c1"># works when overwriting / appending data in the same source!</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span>
                <span class="n">fn</span><span class="p">,</span> <span class="n">mask_and_scale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">decode_coords</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="c1"># make sure internally maps are always North -&gt; South oriented</span>
            <span class="k">if</span> <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">flipud</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;staticmaps&quot;</span><span class="p">,</span> <span class="s2">&quot;*.map&quot;</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_staticmaps_pcr</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">read_staticmaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read staticmaps. DEPRECATED for read_grid.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;read_staticmaps is deprecated. Use &#39;read_grid&#39; instead. &quot;</span>
            <span class="s2">&quot;Will be removed in hydromt_wflow v0.6.0&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_grid</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="WflowModel.write_grid">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.write_grid.html#hydromt_wflow.WflowModel.write_grid">[docs]</a>
    <span class="k">def</span> <span class="nf">write_grid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fn_out</span><span class="p">:</span> <span class="n">Path</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write grid to wflow static data file.</span>

<span class="sd">        Checks the path of the file in the config toml using both ``input.path_static``</span>
<span class="sd">        and ``dir_input``. If not found uses the default path ``staticmaps.nc`` in the</span>
<span class="sd">        root folder.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fn_out : Path | str, optional</span>
<span class="sd">            Name or path to the outgoing grid file (including extension).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Model opened in read-only mode&quot;</span><span class="p">)</span>
        <span class="c1"># clean-up grid and write CRS according to CF-conventions</span>
        <span class="c1"># TODO replace later with hydromt.raster.gdal_compliant method</span>
        <span class="c1"># after core release</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">crs</span>
        <span class="n">ds_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">reset_coords</span><span class="p">()</span>
        <span class="c1"># TODO?!</span>
        <span class="c1"># if ds_out.raster.res[1] &lt; 0: # write data with South -&gt; North orientation</span>
        <span class="c1">#     ds_out = ds_out.raster.flipud()</span>
        <span class="n">x_dim</span><span class="p">,</span> <span class="n">y_dim</span><span class="p">,</span> <span class="n">x_attrs</span><span class="p">,</span> <span class="n">y_attrs</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">gis_utils</span><span class="o">.</span><span class="n">axes_attrs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
        <span class="n">ds_out</span> <span class="o">=</span> <span class="n">ds_out</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="n">ds_out</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">x_dim</span><span class="p">:</span> <span class="n">x_dim</span><span class="p">,</span> <span class="n">ds_out</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">y_dim</span><span class="p">:</span> <span class="n">y_dim</span><span class="p">})</span>
        <span class="n">ds_out</span><span class="p">[</span><span class="n">x_dim</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">x_attrs</span><span class="p">)</span>
        <span class="n">ds_out</span><span class="p">[</span><span class="n">y_dim</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">y_attrs</span><span class="p">)</span>
        <span class="n">ds_out</span> <span class="o">=</span> <span class="n">ds_out</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s2">&quot;mask&quot;</span><span class="p">,</span> <span class="s2">&quot;spatial_ref&quot;</span><span class="p">,</span> <span class="s2">&quot;ls&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
        <span class="n">ds_out</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">write_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ds_out</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">write_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">transform</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ds_out</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">set_spatial_dims</span><span class="p">()</span>

        <span class="c1"># Remove FillValue Nan for x_dim, y_dim</span>
        <span class="n">encoding</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ds_out</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">x_dim</span><span class="p">,</span> <span class="n">ds_out</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">y_dim</span><span class="p">]:</span>
            <span class="n">ds_out</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_FillValue&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">encoding</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_FillValue&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

        <span class="c1"># filename</span>
        <span class="k">if</span> <span class="n">fn_out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">fn_out</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.path_static&quot;</span><span class="p">,</span> <span class="n">fn_out</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fn_out</span> <span class="o">=</span> <span class="s2">&quot;staticmaps.nc&quot;</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
                <span class="s2">&quot;input.path_static&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">fn_out</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># Append inputdir if required</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">input_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span>
                <span class="n">input_dir</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;input.path_static&quot;</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="n">fn_out</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="c1"># Check if all sub-folders in fn exists and if not create them</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">fn</span><span class="p">)):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">fn</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Write grid to </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ds_out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds_out</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="c1"># nodata is required for all but boolean fields</span>
            <span class="k">if</span> <span class="n">ds_out</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
                <span class="n">ds_out</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_out</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">ds_out</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">nodata</span><span class="p">)</span>
        <span class="n">ds_out</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">write_staticmaps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write staticmaps: DEPRECATED for write_grid.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;write_staticmaps is deprecated. Use &#39;write_grid&#39; instead. &quot;</span>
            <span class="s2">&quot;Will be removed in hydromt_wflow v0.6.0&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_grid</span><span class="p">()</span>

<div class="viewcode-block" id="WflowModel.read_geoms">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.read_geoms.html#hydromt_wflow.WflowModel.read_geoms">[docs]</a>
    <span class="k">def</span> <span class="nf">read_geoms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">geom_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;staticgeoms&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read static geometries and adds to ``geoms``.</span>

<span class="sd">        Assumes that the `geom_fn` folder is located in the same folder as the static</span>
<span class="sd">        input data (``input.path_static``). If not found uses assumes they are in</span>
<span class="sd">        &lt;root/geom_fm&gt;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_geoms</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># fresh start in read-only mode</span>
        <span class="n">dir_default</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;staticmaps.nc&quot;</span><span class="p">)</span>
        <span class="n">dir_mod</span> <span class="o">=</span> <span class="n">dirname</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;input.path_static&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="n">dir_default</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">fns</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">dir_mod</span><span class="p">,</span> <span class="n">geom_fn</span><span class="p">,</span> <span class="s2">&quot;*.geojson&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Reading model staticgeom files.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">basename</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;region&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">fn</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">read_staticgeoms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">geom_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;staticgeoms&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read static geometries: DEPRECATED for read_geoms.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;read_staticgeoms is deprecated. Use &#39;read_geoms&#39; instead. &quot;</span>
            <span class="s2">&quot;Will be removed in hydromt_wflow v0.6.0&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_geoms</span><span class="p">(</span><span class="n">geom_fn</span><span class="p">)</span>

<div class="viewcode-block" id="WflowModel.write_geoms">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.write_geoms.html#hydromt_wflow.WflowModel.write_geoms">[docs]</a>
    <span class="k">def</span> <span class="nf">write_geoms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">geom_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;staticgeoms&quot;</span><span class="p">,</span>
        <span class="n">precision</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write geoms in &lt;root/geom_fn&gt; in GeoJSON format.&quot;&quot;&quot;</span>
        <span class="c1"># to write use self.geoms[var].to_file()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Model opened in read-only mode&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Writing model staticgeom to file.&quot;</span><span class="p">)</span>
            <span class="c1"># Set projection to 1 decimal if projected crs</span>
            <span class="n">_precision</span> <span class="o">=</span> <span class="n">precision</span>
            <span class="k">if</span> <span class="n">precision</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">is_projected</span><span class="p">:</span>
                    <span class="n">_precision</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_precision</span> <span class="o">=</span> <span class="mi">6</span>
            <span class="n">grid_size</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">_precision</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># TODO change to geopandas functionality once geopandas 1.0.0 comes</span>
                <span class="c1"># See https://github.com/geopandas/geopandas/releases/tag/v1.0.0-alpha1</span>
                <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">set_precision</span><span class="p">(</span>
                    <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span>
                    <span class="n">grid_size</span><span class="o">=</span><span class="n">grid_size</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">fn_out</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">geom_fn</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.geojson&quot;</span><span class="p">)</span>
                <span class="n">gdf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GeoJSON&quot;</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">write_staticgeoms</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">geom_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;staticgeoms&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write static geometries: DEPRECATED for write_geoms.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;write_staticgeoms is deprecated. Use &#39;write_geoms&#39; instead. &quot;</span>
            <span class="s2">&quot;Will be removed in hydromt_wflow v0.6.0&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_geoms</span><span class="p">(</span><span class="n">geom_fn</span><span class="p">)</span>

<div class="viewcode-block" id="WflowModel.read_forcing">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.read_forcing.html#hydromt_wflow.WflowModel.read_forcing">[docs]</a>
    <span class="k">def</span> <span class="nf">read_forcing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read forcing.</span>

<span class="sd">        Checks the path of the file in the config toml using both ``input.path_forcing``</span>
<span class="sd">        and ``dir_input``. If not found uses the default path ``inmaps.nc`` in the</span>
<span class="sd">        root folder.</span>

<span class="sd">        If several files are used using &#39;*&#39; in ``input.path_forcing``, all corresponding</span>
<span class="sd">        files are read and merged into one xarray dataset before being splitted to one</span>
<span class="sd">        xarray dataaray per forcing variable in the hydromt ``forcing`` dictionnary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fn_default</span> <span class="o">=</span> <span class="s2">&quot;inmaps.nc&quot;</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
            <span class="s2">&quot;input.path_forcing&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">fn_default</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">input_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span>
                <span class="n">input_dir</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
                    <span class="s2">&quot;input.path_forcing&quot;</span><span class="p">,</span>
                    <span class="n">fallback</span><span class="o">=</span><span class="n">fn_default</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input directory found </span><span class="si">{</span><span class="n">input_dir</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="c1"># start fresh in read-only mode</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_forcing</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isfile</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read forcing from </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">},</span> <span class="n">decode_coords</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_forcing</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
        <span class="k">elif</span> <span class="s2">&quot;*&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read multiple forcing files using </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">fns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No forcing files found using </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_mfdataset</span><span class="p">(</span><span class="n">fns</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">},</span> <span class="n">decode_coords</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_forcing</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">])</span></div>


<div class="viewcode-block" id="WflowModel.write_forcing">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.write_forcing.html#hydromt_wflow.WflowModel.write_forcing">[docs]</a>
    <span class="k">def</span> <span class="nf">write_forcing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fn_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">freq_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">decimals</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">time_units</span><span class="o">=</span><span class="s2">&quot;days since 1900-01-01T00:00:00&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write forcing at ``fn_out`` in model ready format.</span>

<span class="sd">        If no ``fn_out`` path is provided and path_forcing from the  wflow toml exists,</span>
<span class="sd">        the following default filenames are used:</span>

<span class="sd">            * Default name format (with downscaling): \</span>
<span class="sd">inmaps_sourcePd_sourceTd_methodPET_freq_startyear_endyear.nc</span>
<span class="sd">            * Default name format (no downscaling): \</span>
<span class="sd">inmaps_sourceP_sourceT_methodPET_freq_startyear_endyear.nc</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fn_out: str, Path, optional</span>
<span class="sd">            Path to save output netcdf file; if None the name is read from the wflow</span>
<span class="sd">            toml file.</span>
<span class="sd">        freq_out: str (Offset), optional</span>
<span class="sd">            Write several files for the forcing according to fn_freq. For example &#39;Y&#39;</span>
<span class="sd">            for one file per year or &#39;M&#39; for one file per month.</span>
<span class="sd">            By default writes the one file.</span>
<span class="sd">            For more options, \</span>
<span class="sd">see https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases</span>
<span class="sd">        chunksize: int, optional</span>
<span class="sd">            Chunksize on time dimension when saving to disk. By default 1.</span>
<span class="sd">        decimals: int, optional</span>
<span class="sd">            Round the ouput data to the given number of decimals.</span>
<span class="sd">        time_units: str, optional</span>
<span class="sd">            Common time units when writting several netcdf forcing files.</span>
<span class="sd">            By default &quot;days since 1900-01-01T00:00:00&quot;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Model opened in read-only mode&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Write forcing file&quot;</span><span class="p">)</span>

            <span class="c1"># Get default forcing name from forcing attrs</span>
            <span class="n">yr0</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;starttime&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">year</span>
            <span class="n">yr1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;endtime&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">year</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;timestepsecs&quot;</span><span class="p">)</span>
            <span class="c1"># get output filename</span>
            <span class="k">if</span> <span class="n">fn_out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.path_forcing&quot;</span><span class="p">,</span> <span class="n">fn_out</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write_config</span><span class="p">()</span>  <span class="c1"># re-write config</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fn_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;input.path_forcing&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">fn_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;*&quot;</span> <span class="ow">in</span> <span class="n">basename</span><span class="p">(</span><span class="n">fn_name</span><span class="p">):</span>
                        <span class="c1"># get rid of * in case model had multiple forcing files and</span>
                        <span class="c1"># write to single nc file.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="s2">&quot;Writing multiple forcing files to one file&quot;</span>
                        <span class="p">)</span>
                        <span class="n">fn_name</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span>
                            <span class="n">dirname</span><span class="p">(</span><span class="n">fn_name</span><span class="p">),</span> <span class="n">basename</span><span class="p">(</span><span class="n">fn_name</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">input_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">fn_out</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span> <span class="n">fn_name</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fn_out</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">fn_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fn_out</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># get deafult filename if file exists</span>
                <span class="k">if</span> <span class="n">fn_out</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">isfile</span><span class="p">(</span><span class="n">fn_out</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;Netcdf forcing file from input.path_forcing in the TOML  &quot;</span>
                        <span class="s2">&quot;already exists, using default name.&quot;</span>
                    <span class="p">)</span>
                    <span class="n">sourceP</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="n">sourceT</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="n">methodPET</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="k">if</span> <span class="s2">&quot;precip&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">:</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">[</span><span class="s2">&quot;precip&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;precip_clim_fn&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="n">Pdown</span> <span class="o">=</span> <span class="s2">&quot;d&quot;</span> <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">[</span><span class="s2">&quot;precip&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;precip_fn&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">sourceP</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">val</span><span class="si">}{</span><span class="n">Pdown</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="s2">&quot;temp&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">:</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;temp_correction&quot;</span><span class="p">,</span> <span class="s2">&quot;False&quot;</span><span class="p">)</span>
                        <span class="n">Tdown</span> <span class="o">=</span> <span class="s2">&quot;d&quot;</span> <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="s2">&quot;True&quot;</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;temp_fn&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">sourceT</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">val</span><span class="si">}{</span><span class="n">Tdown</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="s2">&quot;pet&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">:</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pet_method&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">methodPET</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">fn_default</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;inmaps</span><span class="si">{</span><span class="n">sourceP</span><span class="si">}{</span><span class="n">sourceT</span><span class="si">}{</span><span class="n">methodPET</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">freq</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">yr0</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">yr1</span><span class="si">}</span><span class="s2">.nc&quot;</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">input_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">fn_default_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span> <span class="n">fn_default</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fn_default_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">fn_default</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">isfile</span><span class="p">(</span><span class="n">fn_default_path</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="s2">&quot;Netcdf default forcing file already exists, </span><span class="se">\</span>
<span class="s2">skipping write_forcing. &quot;</span>
                            <span class="s2">&quot;To overwrite netcdf forcing file: </span><span class="se">\</span>
<span class="s2">change name input.path_forcing &quot;</span>
                            <span class="s2">&quot;in setup_config section of the build inifile.&quot;</span>
                        <span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.path_forcing&quot;</span><span class="p">,</span> <span class="n">fn_default</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">write_config</span><span class="p">()</span>  <span class="c1"># re-write config</span>
                        <span class="n">fn_out</span> <span class="o">=</span> <span class="n">fn_default_path</span>

            <span class="c1"># Check if all dates between (starttime, endtime) are in all da forcing</span>
            <span class="c1"># Check if starttime and endtime timestamps are correct</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;starttime&quot;</span><span class="p">))</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;endtime&quot;</span><span class="p">))</span>
            <span class="n">correct_times</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">da</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                    <span class="c1"># only correct dates in toml for standard calendars:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span> <span class="s2">&quot;to_datetimeindex&quot;</span><span class="p">):</span>
                        <span class="n">times</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">values</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">|</span> <span class="p">(</span><span class="n">start</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">times</span><span class="p">):</span>
                            <span class="n">start</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">correct_times</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">|</span> <span class="p">(</span><span class="n">end</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">times</span><span class="p">):</span>
                            <span class="n">end</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                            <span class="n">correct_times</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># merge, process and write forcing</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">da</span><span class="o">.</span><span class="n">reset_coords</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">da</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
            <span class="c1"># Send warning, and update config with new start and end time</span>
            <span class="k">if</span> <span class="n">correct_times</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Not all dates found in precip_fn changing starttime to </span><span class="se">\</span>
<span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2"> and endtime to </span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2"> in the toml.&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;starttime&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">.</span><span class="n">to_pydatetime</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;endtime&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">.</span><span class="n">to_pydatetime</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write_config</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">decimals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span>
            <span class="c1"># clean-up forcing and write CRS according to CF-conventions</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">gdal_compliant</span><span class="p">(</span><span class="n">rename_dims</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_sn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">([</span><span class="s2">&quot;mask&quot;</span><span class="p">,</span> <span class="s2">&quot;idx_out&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

            <span class="c1"># write with output chunksizes with single timestep and complete</span>
            <span class="c1"># spatial grid to speed up the reading from wflow.jl</span>
            <span class="c1"># dims are always ordered (time, y, x)</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">_check_dimensions</span><span class="p">()</span>
            <span class="n">chunksizes</span> <span class="o">=</span> <span class="p">(</span><span class="n">chunksize</span><span class="p">,</span> <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">ycoords</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">xcoords</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">v</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;zlib&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="s2">&quot;chunksizes&quot;</span><span class="p">:</span> <span class="n">chunksizes</span><span class="p">}</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="c1"># make sure no _FillValue is written to the time / x_dim / y_dim dimension</span>
            <span class="c1"># For several forcing files add common units attributes to time</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">x_dim</span><span class="p">,</span> <span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">y_dim</span><span class="p">]:</span>
                <span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_FillValue&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">encoding</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_FillValue&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

            <span class="c1"># Check if all sub-folders in fn_out exists and if not create them</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">fn_out</span><span class="p">)):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">fn_out</span><span class="p">))</span>

            <span class="n">forcing_list</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="n">freq_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># with compute=False we get a delayed object which is executed when</span>
                <span class="c1"># calling .compute where we can pass more arguments to</span>
                <span class="c1"># the dask.compute method</span>
                <span class="n">forcing_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">ds</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Writting several forcing with freq </span><span class="si">{</span><span class="n">freq_out</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># For several forcing files add common units attributes to time</span>
                <span class="n">encoding</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_FillValue&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;units&quot;</span><span class="p">:</span> <span class="n">time_units</span><span class="p">}</span>
                <span class="c1"># Updating path forcing in config</span>
                <span class="n">fns_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
                <span class="n">fns_out</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">fns_out</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="s2">_*.nc&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;input.path_forcing&quot;</span><span class="p">,</span> <span class="n">fns_out</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write_config</span><span class="p">()</span>  <span class="c1"># re-write config</span>
                <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">ds_gr</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">freq_out</span><span class="p">):</span>
                    <span class="c1"># ds_gr = group[1]</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">ds_gr</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                    <span class="n">fn_out_gr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">fn_out</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">.nc&quot;</span>
                    <span class="n">forcing_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">fn_out_gr</span><span class="p">,</span> <span class="n">ds_gr</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">fn_out_gr</span><span class="p">,</span> <span class="n">ds_gr</span> <span class="ow">in</span> <span class="n">forcing_list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Process forcing; saving to </span><span class="si">{</span><span class="n">fn_out_gr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">delayed_obj</span> <span class="o">=</span> <span class="n">ds_gr</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span>
                    <span class="n">fn_out_gr</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">compute</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="k">with</span> <span class="n">ProgressBar</span><span class="p">():</span>
                    <span class="n">delayed_obj</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


            <span class="c1"># TO profile uncomment lines below to replace lines above</span>
            <span class="c1"># from dask.diagnostics import Profiler, CacheProfiler, ResourceProfiler</span>
            <span class="c1"># import cachey</span>
            <span class="c1"># with Profiler() as prof, CacheProfiler(metric=cachey.nbytes) as cprof,</span>
            <span class="c1"># ResourceProfiler() as rprof:</span>
            <span class="c1">#     delayed_obj.compute()</span>
            <span class="c1"># visualize([prof, cprof, rprof],</span>
            <span class="c1"># file_path=r&#39;c:\Users\eilan_dk\work\profile2.html&#39;)</span>

<div class="viewcode-block" id="WflowModel.read_states">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.read_states.html#hydromt_wflow.WflowModel.read_states">[docs]</a>
    <span class="k">def</span> <span class="nf">read_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read states at &lt;root/instate/&gt; and parse to dict of xr.DataArray.&quot;&quot;&quot;</span>
        <span class="n">fn_default</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;instate&quot;</span><span class="p">,</span> <span class="s2">&quot;instates.nc&quot;</span><span class="p">)</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
            <span class="s2">&quot;state.path_input&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">fn_default</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">input_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span>
                <span class="n">input_dir</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;state.path_input&quot;</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="n">fn_default</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input directory found </span><span class="si">{</span><span class="n">input_dir</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="c1"># start fresh in read-only mode</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_states</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isfile</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read states from </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">mask_and_scale</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_states</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">])</span></div>


<div class="viewcode-block" id="WflowModel.write_states">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.write_states.html#hydromt_wflow.WflowModel.write_states">[docs]</a>
    <span class="k">def</span> <span class="nf">write_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn_out</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write states at &lt;root/instate/&gt; in model ready format.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Model opened in read-only mode&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Writting states file&quot;</span><span class="p">)</span>

            <span class="c1"># get output filename and if needed update and re-write the config</span>
            <span class="k">if</span> <span class="n">fn_out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;state.path_input&quot;</span><span class="p">,</span> <span class="n">fn_out</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write_config</span><span class="p">()</span>  <span class="c1"># re-write config</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fn_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span>
                    <span class="s2">&quot;state.path_input&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fallback</span><span class="o">=</span><span class="kc">None</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">fn_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">fn_name</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;instate&quot;</span><span class="p">,</span> <span class="s2">&quot;instates.nc&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;state.path_input&quot;</span><span class="p">,</span> <span class="n">fn_name</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">write_config</span><span class="p">()</span>  <span class="c1"># re-write config</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">input_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_input&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">fn_out</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">input_dir</span><span class="p">,</span> <span class="n">fn_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fn_out</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">fn_name</span><span class="p">)</span>

            <span class="c1"># merge, process and write forcing</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

            <span class="c1"># make sure no _FillValue is written to the time dimension</span>
            <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_FillValue&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="c1"># Check if all sub-folders in fn_out exists and if not create them</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">fn_out</span><span class="p">)):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">fn_out</span><span class="p">))</span>

            <span class="c1"># write states</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.read_results">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.read_results.html#hydromt_wflow.WflowModel.read_results">[docs]</a>
    <span class="k">def</span> <span class="nf">read_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read results at &lt;root/?/&gt; and parse to dict of xr.DataArray/xr.Dataset.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="c1"># start fresh in read-only mode</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_results</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">output_dir</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_output&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;dir_output&quot;</span><span class="p">)</span>

        <span class="c1"># Read gridded netcdf (output section)</span>
        <span class="n">nc_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;output.path&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nc_fn</span> <span class="o">=</span> <span class="n">nc_fn</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="n">output_dir</span> <span class="o">/</span> <span class="n">nc_fn</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">nc_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nc_fn</span>
        <span class="k">if</span> <span class="n">nc_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isfile</span><span class="p">(</span><span class="n">nc_fn</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read results from </span><span class="si">{</span><span class="n">nc_fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">nc_fn</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">},</span> <span class="n">decode_coords</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
            <span class="c1"># TODO ? align coords names and values of results nc with grid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_results</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;output&quot;</span><span class="p">)</span>

        <span class="c1"># Read scalar netcdf (netcdf section)</span>
        <span class="n">ncs_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;netcdf.path&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ncs_fn</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ncs_fn</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="n">output_dir</span> <span class="o">/</span> <span class="n">ncs_fn</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">ncs_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ncs_fn</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ncs_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isfile</span><span class="p">(</span><span class="n">ncs_fn</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Read results from </span><span class="si">{</span><span class="n">ncs_fn</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">ncs_fn</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_results</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;netcdf&quot;</span><span class="p">)</span>

        <span class="c1"># Read csv timeseries (csv section)</span>
        <span class="n">csv_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;csv.path&quot;</span><span class="p">,</span> <span class="n">abs_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">csv_fn</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">csv_fn</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="n">output_dir</span> <span class="o">/</span> <span class="n">csv_fn</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">csv_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">csv_fn</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">csv_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isfile</span><span class="p">(</span><span class="n">csv_fn</span><span class="p">):</span>
            <span class="n">csv_dict</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">read_csv_results</span><span class="p">(</span>
                <span class="n">csv_fn</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span> <span class="n">maps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">csv_dict</span><span class="p">:</span>
                <span class="c1"># Add to results</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_results</span><span class="p">(</span><span class="n">csv_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span></div>


    <span class="k">def</span> <span class="nf">write_results</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write results at &lt;root/?/&gt; in model ready format.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Model opened in read-only mode&quot;</span><span class="p">)</span>
        <span class="c1"># raise NotImplementedError()</span>

    <span class="k">def</span> <span class="nf">read_intbl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read and intbl files at &lt;root/intbl&gt; and parse to xarray.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_intbl</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># start fresh in read-only mode</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Reading default intbl files.&quot;</span><span class="p">)</span>
            <span class="n">fns</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">DATADIR</span><span class="p">,</span> <span class="s2">&quot;wflow&quot;</span><span class="p">,</span> <span class="s2">&quot;intbl&quot;</span><span class="p">,</span> <span class="s2">&quot;*.tbl&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Reading model intbl files.&quot;</span><span class="p">)</span>
            <span class="n">fns</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;intbl&quot;</span><span class="p">,</span> <span class="s2">&quot;*.tbl&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">basename</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">tbl</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">delim_whitespace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">tbl</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="sa">f</span><span class="s2">&quot;expr</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tbl</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;value&quot;</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tbl</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
                <span class="p">]</span>  <span class="c1"># rename columns</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_intbl</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_intbl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write intbl at &lt;root/intbl&gt; in PCRaster table format.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Model opened in read-only mode&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">intbl</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Writing intbl files.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">intbl</span><span class="p">:</span>
                <span class="n">fn_out</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;intbl&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.tbl&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intbl</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_intbl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add intbl &lt;pandas.DataFrame&gt; to model.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;df type not recognized, should be pandas.DataFrame.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intbl</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot overwrite intbl </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> in read-only mode&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Overwriting intbl: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intbl</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>

<div class="viewcode-block" id="WflowModel.read_tables">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.read_tables.html#hydromt_wflow.WflowModel.read_tables">[docs]</a>
    <span class="k">def</span> <span class="nf">read_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read table files at &lt;root&gt; and parse to dict of dataframes.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># start fresh in read-only mode</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Reading model table files.&quot;</span><span class="p">)</span>
        <span class="n">fns</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="s2">&quot;*.csv&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">basename</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">tbl</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">float_precision</span><span class="o">=</span><span class="s2">&quot;round_trip&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_tables</span><span class="p">(</span><span class="n">tbl</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.write_tables">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.write_tables.html#hydromt_wflow.WflowModel.write_tables">[docs]</a>
    <span class="k">def</span> <span class="nf">write_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write tables at &lt;root&gt;.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Model opened in read-only mode&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Writing table files.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">:</span>
                <span class="n">fn_out</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.csv&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fn_out</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.set_tables">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.set_tables.html#hydromt_wflow.WflowModel.set_tables">[docs]</a>
    <span class="k">def</span> <span class="nf">set_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add table &lt;pandas.DataFrame&gt; to model.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;df type not recognized, should be pandas.DataFrame.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot overwrite table </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> in read-only mode&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Overwriting table: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span></div>


    <span class="k">def</span> <span class="nf">_configread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">codecs</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">fdict</span> <span class="o">=</span> <span class="n">toml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fdict</span>

    <span class="k">def</span> <span class="nf">_configwrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">codecs</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">toml</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

    <span class="c1">## WFLOW specific data and methods</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intbl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a dictionary of pandas.DataFrames representing wflow intbl files.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intbl</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_intbl</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intbl</span>

    <span class="nd">@property</span>
    <span class="c1"># Move to core Model API ?</span>
    <span class="k">def</span> <span class="nf">tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a dictionary of pandas.DataFrames representing wflow intbl files.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_tables</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flwdir</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the pyflwdir.FlwdirRaster object parsed from wflow ldd.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flwdir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_flwdir</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flwdir</span>

<div class="viewcode-block" id="WflowModel.set_flwdir">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.set_flwdir.html#hydromt_wflow.WflowModel.set_flwdir">[docs]</a>
    <span class="k">def</span> <span class="nf">set_flwdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s2">&quot;infer&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse pyflwdir.FlwdirRaster object parsed from the wflow ldd.&quot;&quot;&quot;</span>
        <span class="n">flwdir_name</span> <span class="o">=</span> <span class="n">flwdir_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;flwdir&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flwdir</span> <span class="o">=</span> <span class="n">flw</span><span class="o">.</span><span class="n">flwdir_from_da</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">flwdir_name</span><span class="p">],</span>
            <span class="n">ftype</span><span class="o">=</span><span class="n">ftype</span><span class="p">,</span>
            <span class="n">check_ftype</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span>
        <span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">basins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a basin(s) geometry as a geopandas.GeoDataFrame.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;basins&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span>
                <span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">vectorize</span><span class="p">()</span>
                <span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;basins&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Basin map </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s1">&#39;basins&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> not found in grid.&quot;</span><span class="p">)</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">gdf</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">basins_highres</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a high resolution basin(s) geometry.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;basins_highres&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="p">[</span><span class="s2">&quot;basins_highres&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basins</span>
        <span class="k">return</span> <span class="n">gdf</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rivers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a river geometry as a geopandas.GeoDataFrame.</span>

<span class="sd">        If available, the stream order and upstream area values are added to</span>
<span class="sd">        the geometry properties.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;rivers&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="p">[</span><span class="s2">&quot;rivers&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="n">rivmsk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="c1"># Check if there are river cells in the model before continuing</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rivmsk</span><span class="p">):</span>
                <span class="c1"># add stream order &#39;strord&#39; column</span>
                <span class="n">strord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="o">.</span><span class="n">stream_order</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">rivmsk</span><span class="p">)</span>
                <span class="n">feats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="o">.</span><span class="n">streams</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">rivmsk</span><span class="p">,</span> <span class="n">strord</span><span class="o">=</span><span class="n">strord</span><span class="p">)</span>
                <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="o">.</span><span class="n">from_features</span><span class="p">(</span><span class="n">feats</span><span class="p">)</span>
                <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">CRS</span><span class="o">.</span><span class="n">from_user_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;rivers&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No river cells detected in the selected basin.&quot;</span><span class="p">)</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">gdf</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">staticgeoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return static geometries.</span>

<span class="sd">        Note: deprecated and will be removed in hydromt_wflow v0.6.0. Use</span>
<span class="sd">        :py:attr:`geoms` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;staticgeoms is deprecated. Call &#39;geoms&#39; instead. &quot;</span>
            <span class="s2">&quot;Will be removed in hydromt_wflow v0.6.0&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">staticmaps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return staticmaps.</span>

<span class="sd">        Note: deprecated and will be removed in hydromt_wflow v0.6.0. Use</span>
<span class="sd">        :py:attr:`grid` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;staticmaps is deprecated. Call &#39;grid&#39; instead. &quot;</span>
            <span class="s2">&quot;Will be removed in hydromt_wflow v0.6.0&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>

    <span class="c1">## WFLOW specific modification (clip for now) methods</span>

<div class="viewcode-block" id="WflowModel.clip_grid">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.clip_grid.html#hydromt_wflow.WflowModel.clip_grid">[docs]</a>
    <span class="k">def</span> <span class="nf">clip_grid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">region</span><span class="p">,</span>
        <span class="n">buffer</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">crs</span><span class="o">=</span><span class="mi">4326</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clip grid to subbasin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        region : dict</span>
<span class="sd">            See :meth:`models.wflow.WflowModel.setup_basemaps`</span>
<span class="sd">        buffer : int, optional</span>
<span class="sd">            Buffer around subbasin in number of pixels, by default 0</span>
<span class="sd">        align : float, optional</span>
<span class="sd">            Align bounds of region to raster with resolution &lt;align&gt;, by default None</span>
<span class="sd">        crs: int, optional</span>
<span class="sd">            Default crs of the grid to clip.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataSet</span>
<span class="sd">            Clipped grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">basins_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]</span>
        <span class="n">flwdir_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;flwdir&quot;</span><span class="p">]</span>

        <span class="n">kind</span><span class="p">,</span> <span class="n">region</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">workflows</span><span class="o">.</span><span class="n">parse_region</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>
        <span class="c1"># translate basin and outlet kinds to geom</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geom&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bbox&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;basin&quot;</span><span class="p">,</span> <span class="s2">&quot;outlet&quot;</span><span class="p">,</span> <span class="s2">&quot;subbasin&quot;</span><span class="p">]:</span>
            <span class="c1"># supply bbox to avoid getting basin bounds first when clipping subbasins</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;subbasin&quot;</span> <span class="ow">and</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">region</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">bbox</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
            <span class="n">geom</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">workflows</span><span class="o">.</span><span class="n">get_basin_geometry</span><span class="p">(</span>
                <span class="n">ds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                <span class="n">basins_name</span><span class="o">=</span><span class="n">basins_name</span><span class="p">,</span>
                <span class="n">flwdir_name</span><span class="o">=</span><span class="n">flwdir_name</span><span class="p">,</span>
                <span class="o">**</span><span class="n">region</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># clip based on subbasin args, geom or bbox</span>
        <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ds_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">clip_geom</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">)</span>
            <span class="n">ds_grid</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_grid</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">geometry_mask</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
            <span class="n">ds_grid</span><span class="p">[</span><span class="n">basins_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_grid</span><span class="p">[</span><span class="n">basins_name</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">ds_grid</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">basins_name</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">nodata</span>
            <span class="p">)</span>
            <span class="n">ds_grid</span><span class="p">[</span><span class="n">basins_name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">_FillValue</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">basins_name</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">nodata</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">bbox</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ds_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">clip_bbox</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">)</span>

        <span class="c1"># Update flwdir grid and geoms</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">crs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">ds_grid</span><span class="p">)</span>

        <span class="c1"># add pits at edges after clipping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flwdir</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># make sure old flwdir object is removed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;flwdir&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="s2">&quot;ldd&quot;</span><span class="p">)</span>

        <span class="c1"># Reinitiliase geoms and re-create basins/rivers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geoms</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># self.basins</span>
        <span class="c1"># self.rivers</span>
        <span class="c1"># now geoms links to geoms which does not exist in every hydromt version</span>
        <span class="c1"># remove when updating wflow to new objects</span>
        <span class="c1"># Basin shape</span>
        <span class="n">basins</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">basins_name</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">vectorize</span><span class="p">()</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">basins</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">basins_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">basins</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;basins&quot;</span><span class="p">)</span>

        <span class="n">rivmsk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="c1"># Check if there are river cells in the model before continuing</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rivmsk</span><span class="p">):</span>
            <span class="c1"># add stream order &#39;strord&#39; column</span>
            <span class="n">strord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="o">.</span><span class="n">stream_order</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">rivmsk</span><span class="p">)</span>
            <span class="n">feats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="o">.</span><span class="n">streams</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">rivmsk</span><span class="p">,</span> <span class="n">strord</span><span class="o">=</span><span class="n">strord</span><span class="p">)</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="o">.</span><span class="n">from_features</span><span class="p">(</span><span class="n">feats</span><span class="p">)</span>
            <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">CRS</span><span class="o">.</span><span class="n">from_user_input</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_geoms</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;rivers&quot;</span><span class="p">)</span>

        <span class="c1"># Update reservoir and lakes</span>
        <span class="n">remove_reservoir</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;resareas&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="n">reservoir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;resareas&quot;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">reservoir</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">remove_reservoir</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">remove_maps</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;resareas&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reslocs&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;ResSimpleArea&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;ResDemand&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;ResTargetFullFrac&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;ResTargetMinFrac&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;ResMaxRelease&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;ResMaxVolume&quot;</span><span class="p">,</span>
                <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">remove_maps</span><span class="p">)</span>

        <span class="n">remove_lake</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lakeareas&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="n">lake</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lakeareas&quot;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">lake</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">remove_lake</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">remove_maps</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lakeareas&quot;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lakelocs&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;LinkedLakeLocs&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;LakeStorFunc&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;LakeOutflowFunc&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;LakeArea&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;LakeAvgLevel&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;LakeAvgOut&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;LakeThreshold&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;Lake_b&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;Lake_e&quot;</span><span class="p">,</span>
                <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">remove_maps</span><span class="p">)</span>

            <span class="c1"># Update tables</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">lake</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tables</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">k</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">])</span>
            <span class="p">}</span>

        <span class="c1"># Update config</span>
        <span class="c1"># Remove the absolute path and if needed remove lakes and reservoirs</span>
        <span class="k">if</span> <span class="n">remove_reservoir</span><span class="p">:</span>
            <span class="c1"># change reservoirs = true to false</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.reservoirs&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="c1"># remove states</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;state.lateral.river.reservoir&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">][</span><span class="s2">&quot;lateral&quot;</span><span class="p">][</span><span class="s2">&quot;river&quot;</span><span class="p">][</span><span class="s2">&quot;reservoir&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">remove_lake</span><span class="p">:</span>
            <span class="c1"># change lakes = true to false</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_config</span><span class="p">(</span><span class="s2">&quot;model.lakes&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="c1"># remove states</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;state.lateral.river.lake&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">][</span><span class="s2">&quot;lateral&quot;</span><span class="p">][</span><span class="s2">&quot;river&quot;</span><span class="p">][</span><span class="s2">&quot;lake&quot;</span><span class="p">]</span></div>


    <span class="k">def</span> <span class="nf">clip_staticmaps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">region</span><span class="p">,</span>
        <span class="n">buffer</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">align</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">crs</span><span class="o">=</span><span class="mi">4326</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clip staticmaps to subbasin.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;clip_staticmaps is deprecated. Use &#39;clip_grid&#39; instead. &quot;</span>
            <span class="s2">&quot;Will be removed in hydromt_wflow v0.6.0&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clip_grid</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">align</span><span class="p">,</span> <span class="n">crs</span><span class="p">)</span>

<div class="viewcode-block" id="WflowModel.clip_forcing">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.clip_forcing.html#hydromt_wflow.WflowModel.clip_forcing">[docs]</a>
    <span class="k">def</span> <span class="nf">clip_forcing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="mi">4326</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return clippped forcing for subbasin.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataSet</span>
<span class="sd">            Clipped forcing.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Clipping NetCDF forcing..&quot;</span><span class="p">)</span>
            <span class="n">ds_forcing</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">clip_bbox</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">bounds</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_forcing</span><span class="p">(</span><span class="n">ds_forcing</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowModel.clip_states">
<a class="viewcode-back" href="../../_generated/hydromt_wflow.WflowModel.clip_states.html#hydromt_wflow.WflowModel.clip_states">[docs]</a>
    <span class="k">def</span> <span class="nf">clip_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="mi">4326</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return clippped states for subbasin.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xarray.DataSet</span>
<span class="sd">            Clipped states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Clipping NetCDF states..&quot;</span><span class="p">)</span>
            <span class="n">ds_states</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">clip_bbox</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">bounds</span>
            <span class="p">)</span>
            <span class="c1"># Check for reservoirs/lakes presence in the clipped model</span>
            <span class="n">remove_maps</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;resareas&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;volume_reservoir&quot;</span> <span class="ow">in</span> <span class="n">ds_states</span><span class="p">:</span>
                    <span class="n">remove_maps</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;volume_reservoir&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;lakeareas&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;waterlevel_lake&quot;</span> <span class="ow">in</span> <span class="n">ds_states</span><span class="p">:</span>
                    <span class="n">remove_maps</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;waterlevel_lake&quot;</span><span class="p">])</span>
            <span class="n">ds_states</span> <span class="o">=</span> <span class="n">ds_states</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">remove_maps</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_states</span><span class="p">(</span><span class="n">ds_states</span><span class="p">)</span></div>
</div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=3ee479438cf8b5e0d341"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=3ee479438cf8b5e0d341"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright Deltares.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.3.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>