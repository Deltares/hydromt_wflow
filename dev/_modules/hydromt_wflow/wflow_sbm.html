
<!DOCTYPE html>


<html lang="en" data-content_root="../../" data-theme="light">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hydromt_wflow.wflow_sbm &#8212; HydroMT Wflow  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "light";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/theme-deltares.css?v=066b352c" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/hydromt_wflow/wflow_sbm';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.16.1';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://raw.githubusercontent.com/Deltares/hydromt_wflow/gh-pages/switcher.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '1.0.0';
        DOCUMENTATION_OPTIONS.show_version_warning_banner =
            false;
        </script>
    <link rel="icon" href="../../_static/hydromt-icon.svg"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="1.0.0.dev" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="light">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
    
    <img src="../../_static/hydromt-icon.svg" class="logo__image only-light" alt=""/>
    <img src="../../_static/hydromt-icon.svg" class="logo__image only-dark pst-js-only" alt=""/>
  
  
    <p class="title logo__title">HydroMT Wflow</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../getting_started/intro.html">
    Getting started
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../user_guide/index.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api/index.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../dev_guide/intro.html">
    Developments
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://deltares.github.io/hydromt/latest/index.html">
    HydroMT core
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/Deltares/hydromt_wflow" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fab fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://deltares.github.io/Wflow.jl/dev/" title="Wflow" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../_static/wflow_logo.png" class="icon-link-image" alt="Wflow"/></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.deltares.nl/en/" title="Deltares" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../_static/deltares-blue.svg" class="icon-link-image" alt="Deltares"/></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../getting_started/intro.html">
    Getting started
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../user_guide/index.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api/index.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../dev_guide/intro.html">
    Developments
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://deltares.github.io/hydromt/latest/index.html">
    HydroMT core
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/Deltares/hydromt_wflow" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fab fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://deltares.github.io/Wflow.jl/dev/" title="Wflow" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../_static/wflow_logo.png" class="icon-link-image" alt="Wflow"/></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.deltares.nl/en/" title="Deltares" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../_static/deltares-blue.svg" class="icon-link-image" alt="Deltares"/></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">hydromt_wflow.wflow_sbm</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for hydromt_wflow.wflow_sbm</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Implement Wflow model class.&quot;&quot;&quot;</span>

<span class="c1"># Implement model class following model API</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tomllib</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">os.path</span><span class="w"> </span><span class="kn">import</span> <span class="n">isfile</span><span class="p">,</span> <span class="n">join</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span>

<span class="c1"># Implement model class following model API</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">geopandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">gpd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">hydromt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pyflwdir</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydromt</span><span class="w"> </span><span class="kn">import</span> <span class="n">hydromt_step</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydromt.error</span><span class="w"> </span><span class="kn">import</span> <span class="n">NoDataStrategy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydromt.gis</span><span class="w"> </span><span class="kn">import</span> <span class="n">flw</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">hydromt_wflow.utils</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">utils</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydromt_wflow</span><span class="w"> </span><span class="kn">import</span> <span class="n">workflows</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydromt_wflow.naming</span><span class="w"> </span><span class="kn">import</span> <span class="n">_create_hydromt_wflow_mapping_sbm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydromt_wflow.version_upgrade</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">convert_reservoirs_to_wflow_v1_sbm</span><span class="p">,</span>
    <span class="n">convert_to_wflow_v1_sbm</span><span class="p">,</span>
    <span class="n">upgrade_lake_tables_to_reservoir_tables_v1</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">hydromt_wflow.wflow_base</span><span class="w"> </span><span class="kn">import</span> <span class="n">WflowBaseModel</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;WflowSbmModel&quot;</span><span class="p">]</span>
<span class="n">__hydromt_eps__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;WflowSbmModel&quot;</span><span class="p">]</span>  <span class="c1"># core entrypoints</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;hydromt.</span><span class="si">{</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="WflowSbmModel">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.html#hydromt_wflow.WflowSbmModel">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WflowSbmModel</span><span class="p">(</span><span class="n">WflowBaseModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to read, write, build, update wflow-SBM models.</span>

<span class="sd">    This class provides methods to manipulate the wflow-SBM model components</span>
<span class="sd">    and their data. It extends the :py:class:`hydromt_wflow.WflowBaseModel`</span>
<span class="sd">    with specific methods for the setup of the wflow-SBM model schematisation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    root : str, optional</span>
<span class="sd">        Model root, by default None (current working directory)</span>
<span class="sd">    config_filename : str, optional</span>
<span class="sd">        A path relative to the root where the configuration file will</span>
<span class="sd">        be read and written if user does not provide a path themselves.</span>
<span class="sd">        By default &quot;wflow_sbm.toml&quot;</span>
<span class="sd">    mode : {&#39;r&#39;,&#39;r+&#39;,&#39;w&#39;}, optional</span>
<span class="sd">        read/append/write mode, by default &quot;w&quot;</span>
<span class="sd">    data_libs : list[str] | str, optional</span>
<span class="sd">        List of data catalog configuration files, by default None</span>
<span class="sd">    **catalog_keys:</span>
<span class="sd">        Additional keyword arguments to be passed down to the DataCatalog.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;wflow_sbm&quot;</span>

<div class="viewcode-block" id="WflowSbmModel.__init__">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.html#hydromt_wflow.WflowSbmModel.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">root</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">config_filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span>
        <span class="n">data_libs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">catalog_keys</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">root</span><span class="p">,</span>
            <span class="n">config_filename</span><span class="o">=</span><span class="n">config_filename</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">data_libs</span><span class="o">=</span><span class="n">data_libs</span><span class="p">,</span>
            <span class="o">**</span><span class="n">catalog_keys</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># hydromt mapping and wflow variable names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span> <span class="o">=</span> <span class="n">_create_hydromt_wflow_mapping_sbm</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">data</span>
        <span class="p">)</span></div>


    <span class="c1">## SETUP METHODS</span>
<div class="viewcode-block" id="WflowSbmModel.setup_rivers">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_rivers.html#hydromt_wflow.WflowSbmModel.setup_rivers">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_rivers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hydrography_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">river_geom_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">river_upa</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">rivdph_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;powlaw&quot;</span><span class="p">,</span>
        <span class="n">slope_len</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2e3</span><span class="p">,</span>
        <span class="n">min_rivlen_ratio</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">min_rivdph</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">min_rivwth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">smooth_len</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5e3</span><span class="p">,</span>
        <span class="n">elevtn_map</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;land_elevation&quot;</span><span class="p">,</span>
        <span class="n">river_routing</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;kinematic_wave&quot;</span><span class="p">,</span>
        <span class="n">connectivity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;river_location__mask&quot;</span><span class="p">:</span> <span class="s2">&quot;river_mask&quot;</span><span class="p">,</span>
            <span class="s2">&quot;river__length&quot;</span><span class="p">:</span> <span class="s2">&quot;river_length&quot;</span><span class="p">,</span>
            <span class="s2">&quot;river__width&quot;</span><span class="p">:</span> <span class="s2">&quot;river_width&quot;</span><span class="p">,</span>
            <span class="s2">&quot;river_bank_water__depth&quot;</span><span class="p">:</span> <span class="s2">&quot;river_depth&quot;</span><span class="p">,</span>
            <span class="s2">&quot;river__slope&quot;</span><span class="p">:</span> <span class="s2">&quot;river_slope&quot;</span><span class="p">,</span>
            <span class="s2">&quot;river_bank_water__elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;river_bank_elevation&quot;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set full river parameter maps including river depth and bank elevation.</span>

<span class="sd">        The river mask is defined by all cells with a minimum upstream area threshold</span>
<span class="sd">        ``river_upa`` [km2].</span>

<span class="sd">        The river length is defined as the distance from the subgrid outlet pixel to</span>
<span class="sd">        the next upstream subgrid outlet pixel. The ``min_rivlen_ratio`` is the minimum</span>
<span class="sd">        global river length to avg. cell resolution ratio and is used as a threshold in</span>
<span class="sd">        window based smoothing of river length.</span>

<span class="sd">        The river slope is derived from the subgrid elevation difference between pixels</span>
<span class="sd">        at a half distance ``slope_len`` [m] up-</span>
<span class="sd">        and downstream from the subgrid outlet pixel.</span>

<span class="sd">        The river width is derived from the nearest river segment in ``river_geom_fn``.</span>
<span class="sd">        Data gaps are filled by the nearest valid upstream value and averaged along</span>
<span class="sd">        the flow directions over a length ``smooth_len`` [m]</span>

<span class="sd">        The river depth can be directly derived from ``river_geom_fn`` property or</span>
<span class="sd">        calculated using the ``rivdph_method``, by default powlaw:</span>
<span class="sd">        h = hc*Qbf**hp, which is based on qbankfull discharge from the nearest river</span>
<span class="sd">        segment in ``river_geom_fn`` and takes optional arguments for the hc</span>
<span class="sd">        (default = 0.27) and hp (default = 0.30) parameters. For other methods see</span>
<span class="sd">        :py:meth:`hydromt.workflows.river_depth`.</span>

<span class="sd">        If ``river_routing`` is set to &quot;local_inertial&quot;, the bankfull elevation map</span>
<span class="sd">        can be conditioned based on the average cell elevation (&quot;land_elevation&quot;)</span>
<span class="sd">        or subgrid outlet pixel elevation (&quot;meta_subgrid_elevation&quot;).</span>
<span class="sd">        The subgrid elevation might provide a better representation</span>
<span class="sd">        of the river elevation profile, however in combination with</span>
<span class="sd">        local_inertial land routing (see :py:meth:`setup_floodplains`)</span>
<span class="sd">        the subgrid elevation will likely overestimate the floodplain storage capacity.</span>
<span class="sd">        Note that the same input elevation map should be used for river bankfull</span>
<span class="sd">        elevation and land elevation when using local_inertial land routing.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **wflow_river** map: river mask [-]</span>
<span class="sd">        * **river_length** map: river length [m]</span>
<span class="sd">        * **river_width** map: river width [m]</span>
<span class="sd">        * **river_depth** map: bankfull river depth [m]</span>
<span class="sd">        * **river_slope** map: river slope [m/m]</span>
<span class="sd">        * **rivers** geom: river vector based on wflow_river mask</span>
<span class="sd">        * **river_bank_elevation** map: hydrologically conditioned elevation [m+REF]</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_basemaps`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hydrography_fn : str, Path, xarray.Dataset</span>
<span class="sd">            Name of RasterDataset source for hydrography data. Must be same as</span>
<span class="sd">            setup_basemaps for consistent results.</span>

<span class="sd">            * **Required variables**: &#39;flwdir&#39; [LLD or D8 or NEXTXY], &#39;uparea&#39; [km2],</span>
<span class="sd">              &#39;elevtn&#39; [m+REF]</span>

<span class="sd">            * **Optional variables**: &#39;rivwth&#39; [m], &#39;qbankfull&#39; [m3/s]</span>

<span class="sd">        river_geom_fn : str, Path, geopandas.GeoDataFrame, optional</span>
<span class="sd">            Name of GeoDataFrame source for river data.</span>

<span class="sd">            * **Required variables**: &#39;rivwth&#39; [m], &#39;rivdph&#39; [m] or &#39;qbankfull&#39; [m3/s]</span>

<span class="sd">        river_upa : float, optional</span>
<span class="sd">            Minimum upstream area threshold for the river map [km2]. By default 30.0</span>
<span class="sd">        slope_len : float, optional</span>
<span class="sd">            Length over which the river slope is calculated [km]. By default 2.0</span>
<span class="sd">        min_rivlen_ratio: float, optional</span>
<span class="sd">            Ratio of cell resolution used minimum length threshold in a moving</span>
<span class="sd">            window based smoothing of river length, by default 0.0</span>
<span class="sd">            The river length smoothing is skipped if `min_riverlen_ratio` = 0.</span>
<span class="sd">            For details about the river length smoothing,</span>
<span class="sd">            see :py:meth:`pyflwdir.FlwdirRaster.smooth_rivlen`</span>
<span class="sd">        rivdph_method : {&#39;gvf&#39;, &#39;manning&#39;, &#39;powlaw&#39;}</span>
<span class="sd">            see :py:meth:`hydromt.workflows.river_depth` for details, by default</span>
<span class="sd">            &quot;powlaw&quot;</span>
<span class="sd">        river_routing : {&#39;kinematic_wave&#39;, &#39;local_inertial&#39;}</span>
<span class="sd">            Routing methodology to be used, by default &quot;kinematic_wave&quot;.</span>
<span class="sd">        smooth_len : float, optional</span>
<span class="sd">            Length [m] over which to smooth the output river width and depth,</span>
<span class="sd">            by default 5e3</span>
<span class="sd">        min_rivdph : float, optional</span>
<span class="sd">            Minimum river depth [m], by default 1.0</span>
<span class="sd">        min_rivwth : float, optional</span>
<span class="sd">            Minimum river width [m], by default 30.0</span>
<span class="sd">        elevtn_map : str, optional</span>
<span class="sd">            Name of the elevation map in the current WflowBaseModel.staticmaps.</span>
<span class="sd">            By default &quot;land_elevation&quot;</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        workflows.river_bathymetry</span>
<span class="sd">        hydromt.workflows.river_depth</span>
<span class="sd">        pyflwdir.FlwdirRaster.river_depth</span>
<span class="sd">        setup_floodplains</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">setup_rivers</span><span class="p">(</span>
            <span class="n">hydrography_fn</span><span class="o">=</span><span class="n">hydrography_fn</span><span class="p">,</span>
            <span class="n">river_geom_fn</span><span class="o">=</span><span class="n">river_geom_fn</span><span class="p">,</span>
            <span class="n">river_upa</span><span class="o">=</span><span class="n">river_upa</span><span class="p">,</span>
            <span class="n">slope_len</span><span class="o">=</span><span class="n">slope_len</span><span class="p">,</span>
            <span class="n">min_rivlen_ratio</span><span class="o">=</span><span class="n">min_rivlen_ratio</span><span class="p">,</span>
            <span class="n">smooth_len</span><span class="o">=</span><span class="n">smooth_len</span><span class="p">,</span>
            <span class="n">min_rivwth</span><span class="o">=</span><span class="n">min_rivwth</span><span class="p">,</span>
            <span class="n">rivdph_method</span><span class="o">=</span><span class="n">rivdph_method</span><span class="p">,</span>
            <span class="n">min_rivdph</span><span class="o">=</span><span class="n">min_rivdph</span><span class="p">,</span>
            <span class="n">output_names</span><span class="o">=</span><span class="n">output_names</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">routing_options</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;kinematic_wave&quot;</span><span class="p">,</span> <span class="s2">&quot;local_inertial&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">river_routing</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">routing_options</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;river_routing=&quot;</span><span class="si">{</span><span class="n">river_routing</span><span class="si">}</span><span class="s1">&quot; unknown. &#39;</span>
                <span class="sa">f</span><span class="s2">&quot;Select from </span><span class="si">{</span><span class="n">routing_options</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Update wflow config model.river_routing=&quot;</span><span class="si">{</span><span class="n">river_routing</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.river_routing&quot;</span><span class="p">,</span> <span class="n">river_routing</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">river_routing</span> <span class="o">==</span> <span class="s2">&quot;local_inertial&quot;</span><span class="p">:</span>
            <span class="n">postfix</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;land_elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;_avg&quot;</span><span class="p">,</span>
                <span class="s2">&quot;meta_subgrid_elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;_subgrid&quot;</span><span class="p">,</span>
            <span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">elevtn_map</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;river_bank_elevation</span><span class="si">{</span><span class="n">postfix</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">hydrodem_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;hydrodem&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">hydrodem_var</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">output_names</span><span class="p">[</span><span class="n">hydrodem_var</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="n">hydrodem_var</span><span class="p">:</span> <span class="n">name</span><span class="p">})</span>

            <span class="n">ds_out</span> <span class="o">=</span> <span class="n">flw</span><span class="o">.</span><span class="n">dem_adjust</span><span class="p">(</span>
                <span class="n">da_flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;flwdir&quot;</span><span class="p">]],</span>
                <span class="n">da_elevtn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">elevtn_map</span><span class="p">],</span>
                <span class="n">da_rivmsk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]],</span>
                <span class="n">flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span>
                <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
                <span class="n">river_d8</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ds_out</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_river_roughness">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_river_roughness.html#hydromt_wflow.WflowSbmModel.setup_river_roughness">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_river_roughness</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rivman_mapping_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">strord_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;meta_streamorder&quot;</span><span class="p">,</span>
        <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;river_manning_n&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set river Manning roughness coefficient for SBM.</span>

<span class="sd">        Adds model layers:</span>
<span class="sd">        - **river_manning_n** map: river Manning roughness coefficient [-]</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_basemaps`</span>
<span class="sd">        * :py:meth:`~WflowSbmModel.setup_rivers`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rivman_mapping_fn : str | Path | pd.DataFrame</span>
<span class="sd">            Path to the river Manning mapping file or a DataFrame with the mapping.</span>
<span class="sd">        strord_name : str</span>
<span class="sd">            Name of the stream order map.</span>
<span class="sd">        output_names : dict</span>
<span class="sd">            Mapping of output variable names.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        WflowSbmModel.setup_basemaps</span>
<span class="sd">        WflowSbmModel.setup_rivers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing river Manning roughness.&quot;</span><span class="p">)</span>

        <span class="c1"># then add Manning roughness mapping</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;strord&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">strord_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Streamorder map </span><span class="si">{</span><span class="n">strord_name</span><span class="si">}</span><span class="s2"> not found in grid. &quot;</span>
                    <span class="s2">&quot;Please run setup_basemaps or update the strord_name argument.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;strord&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">strord_name</span>
        <span class="c1"># update self._MAPS and self._WFLOW_NAMES with user defined output names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="s2">&quot;river_water_flow__manning_n_parameter&quot;</span><span class="p">:</span> <span class="n">output_name</span><span class="p">})</span>

        <span class="c1"># Make river_manning_n map from csv file with mapping with streamorder</span>
        <span class="k">if</span> <span class="n">rivman_mapping_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fn_map</span> <span class="o">=</span> <span class="s2">&quot;roughness_river_mapping_default&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fn_map</span> <span class="o">=</span> <span class="n">rivman_mapping_fn</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span><span class="n">fn_map</span><span class="p">)</span>

        <span class="n">strord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;strord&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># max streamorder value above which values get the same river_manning_n value</span>
        <span class="n">max_str</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">nodata</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># if streamorder value larger than max_str, assign last value</span>
        <span class="n">strord</span> <span class="o">=</span> <span class="n">strord</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">strord</span> <span class="o">&lt;=</span> <span class="n">max_str</span><span class="p">,</span> <span class="n">max_str</span><span class="p">)</span>
        <span class="c1"># handle missing value (last row of csv is mapping of missing values)</span>
        <span class="n">strord</span> <span class="o">=</span> <span class="n">strord</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">strord</span> <span class="o">!=</span> <span class="n">strord</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">nodata</span><span class="p">,</span> <span class="n">nodata</span><span class="p">)</span>
        <span class="n">strord</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">set_nodata</span><span class="p">(</span><span class="n">nodata</span><span class="p">)</span>
        <span class="n">ds_nriver</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">landuse</span><span class="p">(</span>
            <span class="n">da</span><span class="o">=</span><span class="n">strord</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_nriver</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ds_nriver</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
        <span class="c1"># update config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">ds_nriver</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_floodplains">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_floodplains.html#hydromt_wflow.WflowSbmModel.setup_floodplains">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_floodplains</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">hydrography_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">floodplain_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="c1">### Options for 1D floodplains</span>
        <span class="n">river_upa</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">flood_depths</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">],</span>
        <span class="c1">### Options for 2D floodplains</span>
        <span class="n">elevtn_map</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;land_elevation&quot;</span><span class="p">,</span>
        <span class="n">connectivity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;floodplain_water__sum_of_volume_per_depth&quot;</span><span class="p">:</span> <span class="s2">&quot;floodplain_volume&quot;</span><span class="p">,</span>
            <span class="s2">&quot;river_bank_elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;river_bank_elevation_avg_D4&quot;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add floodplain information to the model schematisation.</span>

<span class="sd">        The user can define what type of floodplains are required (1D or 2D),</span>
<span class="sd">        through the ``floodplain_type`` argument.</span>

<span class="sd">        If ``floodplain_type`` is set to &quot;1d&quot;, a floodplain profile is derived for every</span>
<span class="sd">        river cell. It adds a map with floodplain volume per flood depth,</span>
<span class="sd">        which is used in the wflow 1D floodplain schematisation.</span>

<span class="sd">        Note, it is important to use the same river uparea value as used in the</span>
<span class="sd">        :py:meth:`setup_rivers` method.</span>

<span class="sd">        If ``floodplain_type`` is set to &quot;2d&quot;, this component adds</span>
<span class="sd">        a hydrologically conditioned elevation (river_bank_elevation) map for</span>
<span class="sd">        land routing (local_inertial). For this options, landcells need to be</span>
<span class="sd">        conditioned to D4 flow directions otherwise pits may remain in the land cells.</span>

<span class="sd">        The conditioned elevation can be based on the average cell elevation</span>
<span class="sd">        (&quot;land_elevation&quot;) or subgrid outlet pixel elevation (&quot;meta_subgrid_elevation&quot;).</span>
<span class="sd">        Note that the subgrid elevation will likely overestimate</span>
<span class="sd">        the floodplain storage capacity.</span>

<span class="sd">        Additionally, note that the same input elevation map should be used for river</span>
<span class="sd">        bankfull elevation and land elevation when using local_inertial land routing.</span>

<span class="sd">        Requires :py:meth:`setup_rivers` to be executed beforehand</span>
<span class="sd">        (with ``river_routing`` set to &quot;local_inertial&quot;).</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **floodplain_volume** map: map with floodplain volumes, has flood depth as \</span>
<span class="sd">            third dimension [m3] (for 1D floodplains)</span>
<span class="sd">        * **river_bank_elevation** map: hydrologically conditioned elevation [m+REF]</span>
<span class="sd">          (for 2D floodplains)</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_rivers`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        floodplain_type: {&quot;1d&quot;, &quot;2d&quot;}</span>
<span class="sd">            Option defining the type of floodplains, see below what arguments</span>
<span class="sd">            are related to the different floodplain types</span>
<span class="sd">        hydrography_fn : str, Path, xarray.Dataset</span>
<span class="sd">            Name of RasterDataset source for hydrography data. Must be same as</span>
<span class="sd">            setup_basemaps for consistent results.</span>

<span class="sd">            * Required variables: [&#39;flwdir&#39;, &#39;uparea&#39;, &#39;elevtn&#39;]</span>
<span class="sd">        river_upa : float, optional</span>
<span class="sd">            (1D floodplains) minimum upstream area threshold for drain in the HAND.</span>
<span class="sd">            Optional value, as it is inferred from the grid metadata,</span>
<span class="sd">            to be consistent with setup_rivers.</span>
<span class="sd">        flood_depths : tuple of float, optional</span>
<span class="sd">            (1D floodplains) flood depths at which a volume is derived.</span>
<span class="sd">            By default [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0]</span>

<span class="sd">        elevtn_map: {&quot;land_elevation&quot;, &quot;meta_subgrid_elevation&quot;}</span>
<span class="sd">            (2D floodplains) Name of staticmap to hydrologically condition.</span>
<span class="sd">            By default &quot;land_elevation&quot;</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        workflows.river_floodplain_volume</span>
<span class="sd">        hydromt.flw.dem_adjust</span>
<span class="sd">        pyflwdir.FlwdirRaster.dem_adjust</span>
<span class="sd">        setup_rivers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;model.river_routing&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;local_inertial&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Floodplains (1d or 2d) are currently only supported with </span><span class="se">\</span>
<span class="s2">local inertial river routing&quot;</span>
            <span class="p">)</span>
        <span class="c1"># update self._MAPS and self._WFLOW_NAMES with user defined output names</span>
        <span class="n">var</span> <span class="o">=</span> <span class="s2">&quot;floodplain_water__sum_of_volume_per_depth&quot;</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="n">var</span><span class="p">:</span> <span class="n">output_names</span><span class="p">[</span><span class="n">var</span><span class="p">]})</span>

        <span class="n">r_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;1d&quot;</span><span class="p">,</span> <span class="s2">&quot;2d&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">floodplain_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r_list</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;river_routing=&quot;</span><span class="si">{</span><span class="n">floodplain_type</span><span class="si">}</span><span class="s1">&quot; unknown. Select from </span><span class="si">{</span><span class="n">r_list</span><span class="si">}</span><span class="s1">.&#39;</span>
            <span class="p">)</span>

        <span class="c1"># Adjust settings based on floodplain_type selection</span>
        <span class="k">if</span> <span class="n">floodplain_type</span> <span class="o">==</span> <span class="s2">&quot;1d&quot;</span><span class="p">:</span>
            <span class="n">floodplain_1d</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">land_routing</span> <span class="o">=</span> <span class="s2">&quot;kinematic_wave&quot;</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pyflwdir</span><span class="o">.</span><span class="n">FlwdirRaster</span><span class="p">,</span> <span class="s2">&quot;ucat_volume&quot;</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;This method requires pyflwdir &gt;= 0.5.6&quot;</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing 1D river floodplain_volume map.&quot;</span><span class="p">)</span>

            <span class="c1"># read data</span>
            <span class="n">ds_hydro</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">hydrography_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">10</span>
            <span class="p">)</span>
            <span class="n">ds_hydro</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_hydro</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">geometry_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">)</span>

            <span class="c1"># try to get river uparea from grid, throw error if not specified</span>
            <span class="c1"># or when found but different from specified value</span>
            <span class="n">new_river_upa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;river_upa&quot;</span><span class="p">,</span> <span class="n">river_upa</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">new_river_upa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;No value for `river_upa` specified, and the value cannot </span><span class="se">\</span>
<span class="s2">be inferred from the grid attributes&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">new_river_upa</span> <span class="o">!=</span> <span class="n">river_upa</span> <span class="ow">and</span> <span class="n">river_upa</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Value specified for river_upa (</span><span class="si">{</span><span class="n">river_upa</span><span class="si">}</span><span class="s2">) is different from </span><span class="se">\</span>
<span class="s2">the value found in the grid (</span><span class="si">{</span><span class="n">new_river_upa</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using river_upa value value of: </span><span class="si">{</span><span class="n">new_river_upa</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># get river floodplain volume</span>
            <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span>
            <span class="p">}</span>
            <span class="n">da_fldpln</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">river_floodplain_volume</span><span class="p">(</span>
                <span class="n">ds</span><span class="o">=</span><span class="n">ds_hydro</span><span class="p">,</span>
                <span class="n">ds_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
                <span class="n">river_upa</span><span class="o">=</span><span class="n">new_river_upa</span><span class="p">,</span>
                <span class="n">flood_depths</span><span class="o">=</span><span class="n">flood_depths</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># check if the layer already exists, since overwriting with different</span>
            <span class="c1"># flood_depth values is not working properly if this is the case</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;floodplain_volume&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Layer `floodplain_volume` already in grid, removing layer </span><span class="se">\</span>
<span class="s2">and `flood_depth` dimension to ensure correctly </span><span class="se">\</span>
<span class="s2">setting new flood_depth dimensions&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">drop_dims</span><span class="p">(</span><span class="s2">&quot;flood_depth&quot;</span><span class="p">)</span>

            <span class="n">da_fldpln</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;floodplain_volume&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">da_fldpln</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">da_fldpln</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">floodplain_type</span> <span class="o">==</span> <span class="s2">&quot;2d&quot;</span><span class="p">:</span>
            <span class="n">floodplain_1d</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">land_routing</span> <span class="o">=</span> <span class="s2">&quot;local_inertial&quot;</span>

            <span class="k">if</span> <span class="n">elevtn_map</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">elevtn_map</span><span class="si">}</span><span class="s1">&quot; not found in grid&#39;</span><span class="p">)</span>

            <span class="n">postfix</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;land_elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;_avg&quot;</span><span class="p">,</span>
                <span class="s2">&quot;meta_subgrid_elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;_subgrid&quot;</span><span class="p">,</span>
            <span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">elevtn_map</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;river_bank_elevation</span><span class="si">{</span><span class="n">postfix</span><span class="si">}</span><span class="s2">_D</span><span class="si">{</span><span class="n">connectivity</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="c1"># Check if users wanted a specific name for the river_bank_elevation</span>
            <span class="n">hydrodem_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;hydrodem&quot;</span><span class="p">])</span>
            <span class="n">lndelv_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">])</span>
            <span class="c1"># river_bank_elevation is used for two wflow variables</span>
            <span class="k">if</span> <span class="n">hydrodem_var</span> <span class="ow">in</span> <span class="n">output_names</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">output_names</span><span class="p">[</span><span class="n">hydrodem_var</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="n">hydrodem_var</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
                    <span class="n">lndelv_var</span><span class="p">:</span> <span class="n">elevtn_map</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparing </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> map for land routing.&quot;</span><span class="p">)</span>
            <span class="n">ds_out</span> <span class="o">=</span> <span class="n">flw</span><span class="o">.</span><span class="n">dem_adjust</span><span class="p">(</span>
                <span class="n">da_flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;flwdir&quot;</span><span class="p">]],</span>
                <span class="n">da_elevtn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">elevtn_map</span><span class="p">],</span>
                <span class="n">da_rivmsk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]],</span>
                <span class="n">flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span>
                <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span>
                <span class="n">river_d8</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ds_out</span><span class="p">)</span>
            <span class="c1"># Update the bankfull elevation map</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;input.static.river_bank_water__elevation&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="c1"># In this case river_bank_elevation is also used for the ground elevation?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="s2">&quot;input.static.land_surface_water_flow__ground_elevation&quot;</span><span class="p">,</span> <span class="n">elevtn_map</span>
            <span class="p">)</span>

        <span class="c1"># Update config</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;Update wflow config model.floodplain_1d__flag=&quot;</span><span class="si">{</span><span class="n">floodplain_1d</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.floodplain_1d__flag&quot;</span><span class="p">,</span> <span class="n">floodplain_1d</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Update wflow config model.land_routing=&quot;</span><span class="si">{</span><span class="n">land_routing</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.land_routing&quot;</span><span class="p">,</span> <span class="n">land_routing</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">floodplain_type</span> <span class="o">==</span> <span class="s2">&quot;1d&quot;</span><span class="p">:</span>
            <span class="c1"># Add states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="s2">&quot;state.variables.floodplain_water__instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                <span class="s2">&quot;floodplain_instantaneous_q&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="s2">&quot;state.variables.floodplain_water__depth&quot;</span><span class="p">,</span>
                <span class="s2">&quot;floodplain_h&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="s2">&quot;state.variables.land_surface_water__instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                <span class="s2">&quot;land_instantaneous_q&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Remove local_inertial land states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                <span class="s2">&quot;state.variables.land_surface_water__x_component_of_instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                <span class="s2">&quot;state.variables.land_surface_water__y_component_of_instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Remove from output.netcdf_grid section</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                <span class="s2">&quot;output.netcdf_grid.variables.land_surface_water__x_component_of_instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                <span class="s2">&quot;output.netcdf_grid.variables.land_surface_water__y_component_of_instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Add local_inertial land routing states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="s2">&quot;state.variables.land_surface_water__x_component_of_instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                <span class="s2">&quot;land_instantaneous_qx&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="s2">&quot;state.variables.land_surface_water__y_component_of_instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                <span class="s2">&quot;land_instantaneous_qy&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Remove kinematic_wave and 1d floodplain states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                <span class="s2">&quot;state.variables.land_surface_water__instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                <span class="s2">&quot;state.variables.floodplain_water__instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                <span class="s2">&quot;state.variables.floodplain_water__depth&quot;</span><span class="p">,</span>
                <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Remove from output.netcdf_grid section</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span>
                <span class="s2">&quot;output.netcdf_grid.variables.land_surface_water__instantaneous_volume_flow_rate&quot;</span><span class="p">,</span>
                <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_reservoirs_no_control">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_reservoirs_no_control.html#hydromt_wflow.WflowSbmModel.setup_reservoirs_no_control">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_reservoirs_no_control</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reservoirs_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">rating_curve_fns</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">overwrite_existing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">duplicate_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;error&quot;</span><span class="p">,</span>
        <span class="n">min_area</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;reservoir_area__count&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_area_id&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_location__count&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_outlet_id&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_surface__area&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_area&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_water_surface__initial_elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_initial_depth&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_water_flow_threshold_level__elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_outflow_threshold&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;reservoir_water__rating_curve_coefficient&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_b&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_water__rating_curve_exponent&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_e&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_water__rating_curve_type_count&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_rating_curve&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_water__storage_curve_type_count&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_storage_curve&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_lower_location__count&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_lower_id&quot;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">geom_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;meta_reservoirs_no_control&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate maps of reservoir areas, outlets and parameters.</span>

<span class="sd">        This function adds (uncontrolled) reservoirs such as natural lakes or weirs to</span>
<span class="sd">        the model. It prepares rating and storage curves parameters for the reservoirs</span>
<span class="sd">        modelled with the following rating curve types (see</span>
<span class="sd">        `Wflow reservoir concepts &lt;https://deltares.github.io/Wflow.jl/stable/model_docs/lateral/kinwave/&gt;`__ ):</span>

<span class="sd">        * 1 for Q = f(H) from reservoir data and interpolation</span>
<span class="sd">        * 2 for Q = b(H - H0)^e (general power law)</span>
<span class="sd">        * 3 for Q = b(H - H0)^2 (Modified Puls Approach)</span>

<span class="sd">        Created reservoirs can be added to already existing ones in the model</span>
<span class="sd">        `overwrite_existing=False` (default) or overwrite them</span>
<span class="sd">        `overwrite_existing=True`.</span>

<span class="sd">        Reservoir data is generated from features with ``min_area`` [km2] (default 1</span>
<span class="sd">        km2) from a database with reservoir geometry, IDs and metadata. Parameters can</span>
<span class="sd">        be directly provided in the GeoDataFrame or derived using common properties such</span>
<span class="sd">        as average depth, area and discharge.</span>

<span class="sd">        If rating curve data is available for storage and discharge they can be prepared</span>
<span class="sd">        via ``rating_curve_fns`` (see below for syntax and requirements).</span>
<span class="sd">        Else the parameters &#39;reservoir_b&#39; and &#39;reservoir_e&#39; will be used for discharge,</span>
<span class="sd">        and a rectangular profile will be used to compute storage. This corresponds to</span>
<span class="sd">        the following storage curve types in Wflow:</span>

<span class="sd">        * 1 for S = A * H</span>
<span class="sd">        * 2 for S = f(H) from reservoir data and interpolation</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **reservoir_area_id** map: reservoir IDs [-]</span>
<span class="sd">        * **reservoir_outlet_id** map: reservoir IDs at outlet locations [-]</span>
<span class="sd">        * **reservoir_area** map: reservoir area [m2]</span>
<span class="sd">        * **reservoir_initial_depth** map: reservoir average water level [m]</span>
<span class="sd">        * **reservoir_outflow_threshold** map: reservoir outflow threshold water</span>
<span class="sd">            level [m]</span>
<span class="sd">        * **meta_reservoir_mean_outflow** map: reservoir average discharge [m3/s]</span>
<span class="sd">        * **reservoir_b** map: reservoir rating curve coefficient [-]</span>
<span class="sd">        * **reservoir_e** map: reservoir rating curve exponent [-]</span>
<span class="sd">        * **reservoir_rating_curve** map: option to compute rating curve [-]</span>
<span class="sd">        * **reservoir_storage_curve** map: option to compute storage curve [-]</span>
<span class="sd">        * **reservoir_lower_id** map: optional, lower linked reservoir locations [-]</span>
<span class="sd">        * **meta_reservoirs_no_control** geom: polygon with reservoirs (e.g. lakes or</span>
<span class="sd">          weirs) and wflow parameters.</span>
<span class="sd">        * **reservoirs** geom: polygon with all reservoirs as in the model</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_rivers`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reservoirs_fn : str, Path, gpd.GeoDataFrame</span>
<span class="sd">            Name of GeoDataFrame source for uncontrolled reservoir parameters.</span>

<span class="sd">                * Required variables for direct use:</span>
<span class="sd">                    - &#39;waterbody_id&#39; [-],</span>
<span class="sd">                    - &#39;Area_avg&#39; [m2],</span>
<span class="sd">                    - &#39;Depth_avg&#39; [m],</span>
<span class="sd">                    - &#39;Dis_avg&#39; [m3/s],</span>
<span class="sd">                    - &#39;reservoir_b&#39; [-],</span>
<span class="sd">                    - &#39;reservoir_e&#39; [-],</span>
<span class="sd">                    - &#39;reservoir_rating_curve&#39; [-],</span>
<span class="sd">                    - &#39;reservoir_storage_curve&#39; [-],</span>
<span class="sd">                    - &#39;reservoir_outflow_threshold&#39; [m],</span>
<span class="sd">                    - &#39;reservoir_lower_id&#39; [-]</span>
<span class="sd">                * Required variables for parameter estimation:</span>
<span class="sd">                    - &#39;waterbody_id&#39; [-],</span>
<span class="sd">                    - &#39;Area_avg&#39; [m2],</span>
<span class="sd">                    - &#39;Vol_avg&#39; [m3],</span>
<span class="sd">                    - &#39;Depth_avg&#39; [m],</span>
<span class="sd">                    - &#39;Dis_avg&#39;[m3/s]</span>

<span class="sd">        rating_curve_fns: str, Path, pandas.DataFrame, List, optional</span>
<span class="sd">            Data catalog entry/entries, path(s) or pandas.DataFrame containing rating</span>
<span class="sd">            curve values for reservoirs. If None then will be derived from properties of</span>
<span class="sd">            `reservoirs_fn`.</span>
<span class="sd">            Assumes one file per reservoir (with all variables) and that the reservoir</span>
<span class="sd">            ID is either in the filename or data catalog entry name (eg using</span>
<span class="sd">            placeholder). The ID should be placed at the end separated by an underscore</span>
<span class="sd">            (eg &#39;rating_curve_12.csv&#39; or &#39;rating_curve_12&#39;)</span>

<span class="sd">                * Required variables for storage curve:</span>
<span class="sd">                    - &#39;elevtn&#39; [m+REF],</span>
<span class="sd">                    - &#39;volume&#39; [m3]</span>
<span class="sd">                * Required variables for rating curve:</span>
<span class="sd">                    - &#39;elevtn&#39; [m+REF],</span>
<span class="sd">                    - &#39;discharge&#39; [m3/s]</span>

<span class="sd">        overwrite_existing : bool, optional</span>
<span class="sd">            If False (default), update existing reservoirs in the model with the new</span>
<span class="sd">            reservoirs_fn data.</span>
<span class="sd">        duplicate_id: str, optional {&quot;error&quot;, &quot;skip&quot;}</span>
<span class="sd">            Action to take if duplicate reservoir IDs are found when merging with</span>
<span class="sd">            existing reservoirs. Options are &quot;error&quot; to raise an error (default); &quot;skip&quot;</span>
<span class="sd">            to skip adding new reservoirs.</span>
<span class="sd">        min_area : float, optional</span>
<span class="sd">            Minimum reservoir area threshold [km2], by default 10.0 km2.</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>
<span class="sd">        geom_name : str, optional</span>
<span class="sd">            Name of the reservoir geometry in the staticgeoms folder, by default</span>
<span class="sd">            &#39;meta_reservoirs_no_control&#39; for meta_reservoirs_no_control.geojson.</span>
<span class="sd">        kwargs: optional</span>
<span class="sd">            Keyword arguments passed to the method</span>
<span class="sd">            hydromt.DataCatalog.get_rasterdataset()</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
        <span class="c1"># retrieve data for basin</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing reservoir maps.&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;predicate&quot;</span><span class="p">,</span> <span class="s2">&quot;contains&quot;</span><span class="p">)</span>
        <span class="n">gdf_org</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">reservoirs_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins_highres</span><span class="p">,</span>
            <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
            <span class="n">source_kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">gdf_org</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skipping method, as no data has been found&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Derive reservoir area and outlet maps</span>
        <span class="n">ds_reservoirs</span><span class="p">,</span> <span class="n">gdf_org</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">reservoir_id_maps</span><span class="p">(</span>
            <span class="n">gdf</span><span class="o">=</span><span class="n">gdf_org</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">min_area</span><span class="o">=</span><span class="n">min_area</span><span class="p">,</span>
            <span class="n">uparea_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;uparea&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ds_reservoirs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># No reservoirs of sufficient size found</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>

        <span class="c1"># If rating_curve_fn prepare rating curve dict</span>
        <span class="n">rating_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">rating_curve_fns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rating_curve_fns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">rating_curve_fns</span><span class="p">)</span>
            <span class="c1"># Find ids in rating_curve_fns</span>
            <span class="n">fns_ids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">rating_curve_fns</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fns_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;Could not parse integer reservoir index from &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;rating curve fn </span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s2">. Skipping.&quot;</span>
                    <span class="p">)</span>
            <span class="c1"># assume reservoir index will be in the path</span>
            <span class="c1"># Assume one rating curve per reservoir index</span>
            <span class="k">for</span> <span class="n">_id</span> <span class="ow">in</span> <span class="n">gdf_org</span><span class="p">[</span><span class="s2">&quot;waterbody_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="n">_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_id</span><span class="p">)</span>
                <span class="c1"># Find if _id is is one of the paths in rating_curve_fns</span>
                <span class="k">if</span> <span class="n">_id</span> <span class="ow">in</span> <span class="n">fns_ids</span><span class="p">:</span>
                    <span class="c1"># Update path based on current waterbody_id</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">fns_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">_id</span><span class="p">)</span>
                    <span class="n">rating_fn</span> <span class="o">=</span> <span class="n">rating_curve_fns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="c1"># Read data</span>
                    <span class="k">if</span> <span class="n">isfile</span><span class="p">(</span><span class="n">rating_fn</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">contains_source</span><span class="p">(</span>
                        <span class="n">rating_fn</span>
                    <span class="p">):</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Preparing reservoir rating curve data from </span><span class="si">{</span><span class="n">rating_fn</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="n">df_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span><span class="n">rating_fn</span><span class="p">)</span>
                        <span class="c1"># Add to dict</span>
                        <span class="n">rating_dict</span><span class="p">[</span><span class="n">_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_rate</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Rating curve file not found for reservoir with id </span><span class="si">{</span><span class="n">_id</span><span class="si">}</span><span class="s2">. &quot;</span>
                        <span class="s2">&quot;Using default storage/outflow function parameters.&quot;</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;No rating curve data provided. &quot;</span>
                <span class="s2">&quot;Using default storage/outflow function parameters.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># add reservoir parameters</span>
        <span class="n">ds_reservoirs</span><span class="p">,</span> <span class="n">gdf_reservoirs</span><span class="p">,</span> <span class="n">rating_curves</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">workflows</span><span class="o">.</span><span class="n">reservoirs</span><span class="o">.</span><span class="n">reservoir_parameters</span><span class="p">(</span>
                <span class="n">ds_reservoirs</span><span class="p">,</span>
                <span class="n">gdf_org</span><span class="p">,</span>
                <span class="n">rating_dict</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># merge with existing reservoirs</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">overwrite_existing</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_area&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span>
        <span class="p">):</span>
            <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">v</span><span class="p">:</span> <span class="n">k</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data_vars</span>
            <span class="p">}</span>
            <span class="n">ds_reservoirs</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">reservoirs</span><span class="o">.</span><span class="n">merge_reservoirs</span><span class="p">(</span>
                <span class="n">ds_reservoirs</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
                <span class="n">duplicate_id</span><span class="o">=</span><span class="n">duplicate_id</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Check if ds_res is None ie duplicate IDs</span>
            <span class="k">if</span> <span class="n">ds_reservoirs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Duplicate reservoir IDs found. Skipping adding new reservoirs.&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># remove all reservoir layers from the grid as some control parameters</span>
            <span class="c1"># like demand will not be in ds_reservoirs and won&#39;t be overwritten</span>
            <span class="n">reservoir_maps</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">workflows</span><span class="o">.</span><span class="n">reservoirs</span><span class="o">.</span><span class="n">RESERVOIR_LAYERS</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">reservoir_maps</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

        <span class="c1"># add to grid</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_reservoirs</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ds_reservoirs</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
        <span class="c1"># write reservoirs with attr tables to static geoms.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">gdf_reservoirs</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">geom_name</span><span class="p">)</span>
        <span class="c1"># Prepare a combined geoms of all reservoirs</span>
        <span class="n">gdf_res_all</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">reservoirs</span><span class="o">.</span><span class="n">create_reservoirs_geoms</span><span class="p">(</span>
            <span class="n">ds_reservoirs</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">gdf_res_all</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;reservoirs&quot;</span><span class="p">)</span>
        <span class="c1"># add the tables</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">rating_curves</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

        <span class="c1"># Reservoir settings in the toml to update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.reservoir__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
            <span class="s2">&quot;state.variables.reservoir_water_surface__elevation&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_water_level&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="n">ds_reservoirs</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="s2">&quot;reservoir_area_id&quot;</span><span class="p">,</span>
                <span class="s2">&quot;reservoir_outlet_id&quot;</span><span class="p">,</span>
                <span class="s2">&quot;reservoir_lower_id&quot;</span><span class="p">,</span>
            <span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="n">dvar</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="n">dvar</span><span class="p">])</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_reservoirs_simple_control">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_reservoirs_simple_control.html#hydromt_wflow.WflowSbmModel.setup_reservoirs_simple_control">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_reservoirs_simple_control</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reservoirs_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">timeseries_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">overwrite_existing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">duplicate_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;error&quot;</span><span class="p">,</span>
        <span class="n">min_area</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;reservoir_area__count&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_area_id&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_location__count&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_outlet_id&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_surface__area&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_area&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_water_surface__initial_elevation&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_initial_depth&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_water__rating_curve_type_count&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_rating_curve&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_water__storage_curve_type_count&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_storage_curve&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_water__max_volume&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_max_volume&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_water__target_min_volume_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_target_min_fraction&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;reservoir_water__target_full_volume_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_target_full_fraction&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;reservoir_water_demand__required_downstream_volume_flow_rate&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_demand&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;reservoir_water_release_below_spillway__max_volume_flow_rate&quot;</span><span class="p">:</span> <span class="s2">&quot;reservoir_max_release&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
        <span class="p">},</span>
        <span class="n">geom_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;meta_reservoirs_simple_control&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate maps of controlled reservoir areas, outlets and parameters.</span>

<span class="sd">        Also generates parameters with average reservoir area, demand,</span>
<span class="sd">        min and max target storage capacities and discharge capacity values.</span>

<span class="sd">        This function adds reservoirs with simple control operations to the model. It</span>
<span class="sd">        prepares rating and storage curves parameters for the reservoirs modelled with</span>
<span class="sd">        the following rating curve types (see</span>
<span class="sd">        `Wflow reservoir concepts &lt;https://deltares.github.io/Wflow.jl/stable/model_docs/lateral/waterbodies/&gt;`__</span>
<span class="sd">        ):</span>

<span class="sd">        * 4 simple reservoir operational parameters</span>

<span class="sd">        Created reservoirs can be added to already existing ones in the model</span>
<span class="sd">        `overwrite_existing=False` (default) or overwrite them</span>
<span class="sd">        `overwrite_existing=True`.</span>

<span class="sd">        The data is generated from features with ``min_area`` [km2] (default is 1 km2)</span>
<span class="sd">        from a database with reservoir geometry, IDs and metadata. Parameters can</span>
<span class="sd">        be directly provided in the GeoDataFrame or derived using common properties such</span>
<span class="sd">        as average depth, area and discharge.</span>

<span class="sd">        Data requirements for direct use (i.e. wflow parameters are data already present</span>
<span class="sd">        in reservoirs_fn) are reservoir ID &#39;waterbody_id&#39;, area &#39;reservoir_area&#39; [m2],</span>
<span class="sd">        initial depth &#39;reservoir_initial_depth&#39; [m], rating curve type</span>
<span class="sd">        &#39;reservoir_rating_curve&#39; [-], storage curve type &#39;reservoir_storage_curve&#39; [-],</span>
<span class="sd">        maximum volume &#39;reservoir_max_volume&#39; [m3], the targeted minimum and maximum</span>
<span class="sd">        fraction of water volume in the reservoir &#39;reservoir_target_min_fraction&#39; and</span>
<span class="sd">        &#39;reservoir_target_full_fraction&#39; [-], the average water demand</span>
<span class="sd">        &#39;reservoir_demand&#39; [m3/s] and the maximum release of the reservoir before</span>
<span class="sd">        spilling &#39;reservoir_max_release&#39; [m3/s].</span>

<span class="sd">        In case the wflow parameters are not directly available they can be computed by</span>
<span class="sd">        HydroMT based on time series of reservoir surface water area.</span>
<span class="sd">        These time series can be retrieved from either the hydroengine or the gwwapi,</span>
<span class="sd">        based on the Hylak_id the reservoir, found in the GrandD database.</span>

<span class="sd">        The required variables for computation of the parameters with time series data</span>
<span class="sd">        are reservoir ID &#39;waterbody_id&#39;, reservoir ID in the HydroLAKES database</span>
<span class="sd">        &#39;Hylak_id&#39;, average volume &#39;Vol_avg&#39; [m3], average depth &#39;Depth_avg&#39; [m],</span>
<span class="sd">        average discharge &#39;Dis_avg&#39; [m3/s] and dam height &#39;Dam_height&#39; [m].</span>
<span class="sd">        To compute parameters without using time series data, the required variables in</span>
<span class="sd">        reservoirs_fn are reservoir ID &#39;waterbody_id&#39;, average area &#39;Area_avg&#39; [m2],</span>
<span class="sd">        average volume &#39;Vol_avg&#39; [m3], average depth &#39;Depth_avg&#39; [m], average discharge</span>
<span class="sd">        &#39;Dis_avg&#39; [m3/s] and dam height &#39;Dam_height&#39; [m]</span>
<span class="sd">        and minimum / normal / maximum storage capacity of the dam &#39;Capacity_min&#39;,</span>
<span class="sd">        &#39;Capacity_norm&#39;, &#39;Capacity_max&#39; [m3].</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">            * **reservoir_area_id** map: reservoir IDs [-]</span>
<span class="sd">            * **reservoir_outlet_id** map: reservoir IDs at outlet locations [-]</span>
<span class="sd">            * **reservoir_area** map: reservoir area [m2]</span>
<span class="sd">            * **reservoir_initial_depth** map: reservoir initial water level [m]</span>
<span class="sd">            * **reservoir_rating_curve** map: option to compute rating curve [-]</span>
<span class="sd">            * **reservoir_storage_curve** map: option to compute storage curve [-]</span>
<span class="sd">            * **reservoir_max_volume** map: reservoir max volume [m3]</span>
<span class="sd">            * **reservoir_target_min_fraction** map: reservoir target min frac [m3/m3]</span>
<span class="sd">            * **reservoir_target_full_fraction** map: reservoir target full frac [m3/m3]</span>
<span class="sd">            * **reservoir_demand** map: reservoir demand flow [m3/s]</span>
<span class="sd">            * **reservoir_max_release** map: reservoir max release flow [m3/s]</span>
<span class="sd">            * **meta_reservoirs_simple_control** geom: polygon with</span>
<span class="sd">                reservoirs and parameters</span>
<span class="sd">            * **reservoirs** geom: polygon with all reservoirs as in the model</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_rivers`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reservoirs_fn : str</span>
<span class="sd">            Name of data source for reservoir parameters, see data/data_sources.yml.</span>

<span class="sd">            * Required variables for direct use:</span>
<span class="sd">              &#39;waterbody_id&#39; [-], &#39;reservoir_area&#39; [m2], &#39;reservoir_max_volume&#39; [m3],</span>
<span class="sd">              &#39;reservoir_initial_depth&#39; [m], &#39;reservoir_rating_curve&#39; [-],</span>
<span class="sd">              &#39;reservoir_storage_curve&#39; [-], &#39;reservoir_target_min_fraction&#39; [m3/m3],</span>
<span class="sd">              &#39;reservoir_target_full_fraction&#39; [m3/m3], &#39;reservoir_demand&#39; [m3/s],</span>
<span class="sd">              &#39;reservoir_max_release&#39; [m3/s]</span>
<span class="sd">            * Required variables for computation with timeseries_fn:</span>
<span class="sd">              &#39;waterbody_id&#39; [-], &#39;Hylak_id&#39; [-], &#39;Vol_avg&#39; [m3], &#39;Depth_avg&#39; [m],</span>
<span class="sd">              &#39;Dis_avg&#39; [m3/s], &#39;Dam_height&#39; [m]</span>
<span class="sd">            * Required variables for computation without timeseries_fn:</span>
<span class="sd">              &#39;waterbody_id&#39; [-], &#39;Area_avg&#39; [m2], &#39;Vol_avg&#39; [m3], &#39;Depth_avg&#39; [m],</span>
<span class="sd">              &#39;Dis_avg&#39; [m3/s], &#39;Capacity_max&#39; [m3], &#39;Capacity_norm&#39; [m3],</span>
<span class="sd">              &#39;Capacity_min&#39; [m3], &#39;Dam_height&#39; [m]</span>

<span class="sd">        timeseries_fn : {&#39;gww&#39;, &#39;hydroengine&#39;, None}, optional</span>
<span class="sd">            Download and use time series of reservoir surface water area to calculate</span>
<span class="sd">            and overwrite the reservoir volume/areas of the data source. Timeseries are</span>
<span class="sd">            either downloaded from Global Water Watch &#39;gww&#39; (using gwwapi package) or</span>
<span class="sd">            JRC &#39;jrc&#39; (using hydroengine package). By default None.</span>
<span class="sd">        overwrite_existing : bool, optional</span>
<span class="sd">            If False (default), update existing reservoirs in the model with the new</span>
<span class="sd">            reservoirs_fn data.</span>
<span class="sd">        duplicate_id: str, optional {&quot;error&quot;, &quot;skip&quot;}</span>
<span class="sd">            Action to take if duplicate reservoir IDs are found when merging with</span>
<span class="sd">            existing reservoirs. Options are &quot;error&quot; to raise an error (default); &quot;skip&quot;</span>
<span class="sd">            to skip adding new reservoirs.</span>
<span class="sd">        min_area : float, optional</span>
<span class="sd">            Minimum reservoir area threshold [km2], by default 1.0 km2.</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>
<span class="sd">        geom_name : str, optional</span>
<span class="sd">            Name of the reservoirs geometry in the staticgeoms folder, by default</span>
<span class="sd">            &quot;meta_reservoirs_simple_control&quot; for meta_reservoirs_simple_control.geojson.</span>
<span class="sd">        kwargs: optional</span>
<span class="sd">            Keyword arguments passed to the method</span>
<span class="sd">            hydromt.DataCatalog.get_geodataframe()</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
        <span class="c1"># retrieve data for basin</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing reservoir with simple control maps.&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;predicate&quot;</span><span class="p">,</span> <span class="s2">&quot;contains&quot;</span><span class="p">)</span>
        <span class="n">gdf_org</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">reservoirs_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins_highres</span><span class="p">,</span>
            <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
            <span class="n">source_kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Skip method if no data is returned</span>
        <span class="k">if</span> <span class="n">gdf_org</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skipping method, as no data has been found&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Derive reservoir area and outlet maps</span>
        <span class="n">ds_res</span><span class="p">,</span> <span class="n">gdf_org</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">reservoir_id_maps</span><span class="p">(</span>
            <span class="n">gdf</span><span class="o">=</span><span class="n">gdf_org</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">min_area</span><span class="o">=</span><span class="n">min_area</span><span class="p">,</span>
            <span class="n">uparea_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;uparea&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">ds_res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># No reservoir of sufficient size found</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>

        <span class="c1"># add parameters</span>
        <span class="n">ds_res</span><span class="p">,</span> <span class="n">gdf_res</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">reservoir_simple_control_parameters</span><span class="p">(</span>
            <span class="n">gdf</span><span class="o">=</span><span class="n">gdf_org</span><span class="p">,</span>
            <span class="n">ds_reservoirs</span><span class="o">=</span><span class="n">ds_res</span><span class="p">,</span>
            <span class="n">timeseries_fn</span><span class="o">=</span><span class="n">timeseries_fn</span><span class="p">,</span>
            <span class="n">output_folder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">path</span> <span class="o">/</span> <span class="s2">&quot;validation&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># merge with existing reservoirs</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">overwrite_existing</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_area&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span>
        <span class="p">):</span>
            <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">v</span><span class="p">:</span> <span class="n">k</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data_vars</span>
            <span class="p">}</span>
            <span class="n">ds_res</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">reservoirs</span><span class="o">.</span><span class="n">merge_reservoirs</span><span class="p">(</span>
                <span class="n">ds_res</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
                <span class="n">duplicate_id</span><span class="o">=</span><span class="n">duplicate_id</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Check if ds_res is None ie duplicate IDs</span>
            <span class="k">if</span> <span class="n">ds_res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Duplicate reservoir IDs found. Skipping adding new reservoirs.&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># remove all reservoir layers from the grid as some parameters</span>
            <span class="c1"># like b or e will not be in ds_res and won&#39;t be overwritten</span>
            <span class="n">reservoir_maps</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">workflows</span><span class="o">.</span><span class="n">reservoirs</span><span class="o">.</span><span class="n">RESERVOIR_LAYERS</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">reservoir_maps</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

        <span class="c1"># add to grid</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_res</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ds_res</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>

        <span class="c1"># write reservoirs with param values to geoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">gdf_res</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">geom_name</span><span class="p">)</span>
        <span class="c1"># Prepare a combined geoms of all reservoirs</span>
        <span class="n">gdf_res_all</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">reservoirs</span><span class="o">.</span><span class="n">create_reservoirs_geoms</span><span class="p">(</span>
            <span class="n">ds_res</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">gdf_res_all</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;reservoirs&quot;</span><span class="p">)</span>

        <span class="c1"># update toml</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.reservoir__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
            <span class="s2">&quot;state.variables.reservoir_water_surface__elevation&quot;</span><span class="p">,</span>
            <span class="s2">&quot;reservoir_water_level&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="n">ds_res</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;reservoir_area_id&quot;</span><span class="p">,</span> <span class="s2">&quot;reservoir_outlet_id&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="n">dvar</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="n">dvar</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;static&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_glaciers">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_glaciers.html#hydromt_wflow.WflowSbmModel.setup_glaciers">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_glaciers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">glaciers_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">min_area</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;glacier_surface__area_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;glacier_fraction&quot;</span><span class="p">,</span>
            <span class="s2">&quot;glacier_ice__initial_leq_depth&quot;</span><span class="p">:</span> <span class="s2">&quot;glacier_initial_leq_depth&quot;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">geom_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;glaciers&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate maps of glacier areas, area fraction and volume fraction.</span>

<span class="sd">        The data is generated from features with ``min_area`` [km2] (default is 1 km2)</span>
<span class="sd">        from a database with glacier geometry, IDs and metadata.</span>

<span class="sd">        The required variables from glaciers_fn dataset are glacier ID &#39;simple_id&#39;.</span>
<span class="sd">        Optionally glacier area &#39;AREA&#39; [km2] can be present to filter the glaciers</span>
<span class="sd">        by size. If not present it will be computed on the fly.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **meta_glacier_area_id** map: glacier IDs [-]</span>
<span class="sd">        * **glacier_fraction** map: area fraction of glacier per cell [-]</span>
<span class="sd">        * **glacier_initial_leq_depth** map: storage (volume) of glacier per cell [mm]</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_basemaps`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        glaciers_fn :</span>
<span class="sd">            Name of data source for glaciers, see data/data_sources.yml.</span>

<span class="sd">            * Required variables: [&#39;simple_id&#39;]</span>
<span class="sd">        min_area : float, optional</span>
<span class="sd">            Minimum glacier area threshold [km2], by default 0 (all included)</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>
<span class="sd">        geom_name : str, optional</span>
<span class="sd">            Name of the geometry to be used in the model, by default &quot;glaciers&quot; for</span>
<span class="sd">            glaciers.geojson.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>
        <span class="c1"># retrieve data for basin</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing glacier maps.&quot;</span><span class="p">)</span>
        <span class="n">gdf_org</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">glaciers_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins_highres</span><span class="p">,</span>
            <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;intersects&quot;</span><span class="p">,</span>
            <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Check if there are glaciers found</span>
        <span class="k">if</span> <span class="n">gdf_org</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skipping method, as no data has been found&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># skip small size glacier</span>
        <span class="k">if</span> <span class="s2">&quot;AREA&quot;</span> <span class="ow">in</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">gdf_org</span> <span class="o">=</span> <span class="n">gdf_org</span><span class="p">[</span><span class="n">gdf_org</span><span class="p">[</span><span class="s2">&quot;AREA&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_area</span><span class="p">]</span>
        <span class="c1"># get glacier maps and parameters</span>
        <span class="n">nb_glac</span> <span class="o">=</span> <span class="n">gdf_org</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="n">nb_glac</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;No glaciers of sufficient size found within region!&quot;</span>
                <span class="s2">&quot;Skipping glacier procedures!&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nb_glac</span><span class="si">}</span><span class="s2"> glaciers of sufficient size found within region.&quot;</span><span class="p">)</span>
        <span class="c1"># add glacier maps</span>
        <span class="n">ds_glac</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">glaciermaps</span><span class="p">(</span>
            <span class="n">gdf</span><span class="o">=</span><span class="n">gdf_org</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">id_column</span><span class="o">=</span><span class="s2">&quot;simple_id&quot;</span><span class="p">,</span>
            <span class="n">elevtn_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_glac</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ds_glac</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
        <span class="c1"># update config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">ds_glac</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.glacier__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;state.variables.glacier_ice__leq_depth&quot;</span><span class="p">,</span> <span class="s2">&quot;glacier_leq_depth&quot;</span><span class="p">)</span>
        <span class="c1"># update geoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">gdf_org</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">geom_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_lulcmaps_with_paddy">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_lulcmaps_with_paddy.html#hydromt_wflow.WflowSbmModel.setup_lulcmaps_with_paddy">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_lulcmaps_with_paddy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lulc_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">paddy_class</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">output_paddy_class</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lulc_mapping_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">paddy_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">paddy_mapping_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">soil_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="s2">&quot;soilgrids&quot;</span><span class="p">,</span>
        <span class="n">wflow_thicknesslayers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">800</span><span class="p">],</span>
        <span class="n">target_conductivity</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="mi">5</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">lulc_vars</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;landuse&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_kext&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land_manning_n&quot;</span><span class="p">,</span>
            <span class="s2">&quot;soil_compacted_fraction&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_root_depth&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_leaf_storage&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_wood_storage&quot;</span><span class="p">,</span>
            <span class="s2">&quot;land_water_fraction&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_crop_factor&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_feddes_alpha_h1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_feddes_h1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_feddes_h2&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_feddes_h3_high&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_feddes_h3_low&quot;</span><span class="p">,</span>
            <span class="s2">&quot;vegetation_feddes_h4&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">paddy_waterlevels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;demand_paddy_h_min&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
            <span class="s2">&quot;demand_paddy_h_opt&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>
            <span class="s2">&quot;demand_paddy_h_max&quot;</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">save_high_resolution_lulc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">output_names_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up landuse maps and parameters including for paddy fields.</span>

<span class="sd">        Lookup table `lulc_mapping_fn` columns are converted to lulc classes model</span>
<span class="sd">        parameters based on literature. The data is remapped at its original resolution</span>
<span class="sd">        and then resampled to the model resolution using the average value, unless noted</span>
<span class="sd">        differently.</span>

<span class="sd">        If paddies are present either directly as a class in the landuse_fn or in a</span>
<span class="sd">        separate paddy_fn, the paddy class is used to derive the paddy parameters.</span>

<span class="sd">        To allow for water to pool on the surface (for paddy/rice fields), the layers in</span>
<span class="sd">        the model can be updated to new depths, such that we can allow a thin layer with</span>
<span class="sd">        limited vertical conductivity. These updated layers means that the</span>
<span class="sd">        ``soil_brooks_corey_c`` parameter needs to be calculated again. Next, the</span>
<span class="sd">        soil_ksat_vertical_factor layer corrects the vertical conductivity</span>
<span class="sd">        (by multiplying) such that the bottom of the layer corresponds to the</span>
<span class="sd">        ``target_conductivity`` for that layer. This currently assumes the wflow models</span>
<span class="sd">        to have an exponential declining vertical conductivity (using the ``f``</span>
<span class="sd">        parameter). If no target_conductivity is specified for a layer (``None``),</span>
<span class="sd">        the soil_ksat_vertical_factor value is set to 1.</span>

<span class="sd">        The different values for the minimum/optimal/maximum water levels for paddy</span>
<span class="sd">        fields will be added as constant values in the toml file, through the</span>
<span class="sd">        ``irrigated_paddy__min_depth.value = 20`` interface.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **landuse** map:</span>
<span class="sd">            Landuse class [-]</span>
<span class="sd">        * **vegetation_kext** map:</span>
<span class="sd">            Extinction coefficient in the canopy gap fraction equation [-]</span>
<span class="sd">        * **vegetation_leaf_storage** map:</span>
<span class="sd">            Specific leaf storage [mm]</span>
<span class="sd">        * **vegetation_wood_storage** map:</span>
<span class="sd">            Fraction of wood in the vegetation/plant [-]</span>
<span class="sd">        * **vegetation_root_depth** map:</span>
<span class="sd">            Length of vegetation roots [mm]</span>
<span class="sd">        * **soil_compacted_fraction** map:</span>
<span class="sd">            The fraction of compacted or urban area per grid cell [-]</span>
<span class="sd">        * **land_water_fraction** map:</span>
<span class="sd">            The fraction of open water per grid cell [-]</span>
<span class="sd">        * **land_manning_n** map:</span>
<span class="sd">            Manning Roughness [-]</span>
<span class="sd">        * **vegetation_crop_factor** map:</span>
<span class="sd">            Crop coefficient [-]</span>
<span class="sd">        * **vegetation_feddes_alpha_h1** map:</span>
<span class="sd">            Root water uptake reduction at soil water pressure head</span>
<span class="sd">            h1 (0 or 1) [-]</span>
<span class="sd">        * **vegetation_feddes_h1** map:</span>
<span class="sd">            Soil water pressure head h1 at which root water</span>
<span class="sd">            uptake is reduced (Feddes) [cm]</span>
<span class="sd">        * **vegetation_feddes_h2** map:</span>
<span class="sd">            Soil water pressure head h2 at which root water</span>
<span class="sd">            uptake is reduced (Feddes) [cm]</span>
<span class="sd">        * **vegetation_feddes_h3_high** map:</span>
<span class="sd">            Soil water pressure head h3 (high) at which root water uptake is</span>
<span class="sd">            reduced (Feddes) [cm]</span>
<span class="sd">        * **vegetation_feddes_h3_low** map:</span>
<span class="sd">            Soil water pressure head h3 (low) at which root water uptake is</span>
<span class="sd">            reduced (Feddes) [cm]</span>
<span class="sd">        * **vegetation_feddes_h4** map:</span>
<span class="sd">            Soil water pressure head h4 at which root water</span>
<span class="sd">            uptake is reduced (Feddes) [cm]</span>
<span class="sd">        * **demand_paddy_h_min** value:</span>
<span class="sd">            Minimum required water depth for paddy fields [mm]</span>
<span class="sd">        * **demand_paddy_h_opt** value:</span>
<span class="sd">            Optimal water depth for paddy fields [mm]</span>
<span class="sd">        * **demand_paddy_h_max** value:</span>
<span class="sd">            Maximum water depth for paddy fields [mm]</span>
<span class="sd">        * **soil_ksat_vertical_factor**:</span>
<span class="sd">            Map with a multiplication factor for the vertical conductivity [-]</span>

<span class="sd">        Updates model layers:</span>

<span class="sd">        * **soil_brooks_corey_c**:</span>
<span class="sd">            Brooks Corey coefficients [-] based on pore size</span>
<span class="sd">            distribution, a map for each of the wflow_sbm soil layers (updated based</span>
<span class="sd">            on the newly specified layers)</span>


<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_soilmaps`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lulc_fn : str, Path, xr.DataArray</span>
<span class="sd">            RasterDataset or name in data catalog / path to landuse map.</span>
<span class="sd">        paddy_class : int</span>
<span class="sd">            Landuse class value for paddy fields either in landuse_fn or paddy_fn if</span>
<span class="sd">            provided.</span>
<span class="sd">        output_paddy_class : int, optional</span>
<span class="sd">            Landuse class value for paddy fields in the output landuse map. If None,</span>
<span class="sd">            the ``paddy_class`` is used, by default None. This can be useful when</span>
<span class="sd">            merging paddy location from ``paddy_fn`` into ``landuse_fn``.</span>
<span class="sd">        lulc_mapping_fn : str, Path, pd.DataFrame, optional</span>
<span class="sd">            Path to a mapping csv file from landuse in source name to parameter values</span>
<span class="sd">            in lulc_vars. If lulc_fn is one of {&quot;globcover&quot;, &quot;vito&quot;, &quot;corine&quot;,</span>
<span class="sd">            &quot;esa_worldcover&quot;, &quot;glmnco&quot;}, a default mapping is used and this argument</span>
<span class="sd">            becomes optional.</span>
<span class="sd">        paddy_fn : str, Path, xr.DataArray, optional</span>
<span class="sd">            RasterDataset or name in data catalog / path to paddy map.</span>
<span class="sd">        paddy_mapping_fn : str, Path, pd.DataFrame, optional</span>
<span class="sd">            Path to a mapping csv file from paddy in source name to parameter values</span>
<span class="sd">            in lulc_vars. A default mapping table for rice parameters is used if not</span>
<span class="sd">            provided.</span>
<span class="sd">        soil_fn : str, Path, xr.DataArray, optional</span>
<span class="sd">            Soil data to be used to recalculate the Brooks-Corey coefficients</span>
<span class="sd">            (`soil_brooks_corey_c` parameter), based on the provided</span>
<span class="sd">            ``wflow_thicknesslayers``, by default &quot;soilgrids&quot;, but should ideally</span>
<span class="sd">            be equal to the data used in :py:meth:`setup_soilmaps`</span>

<span class="sd">            * Required variables: &#39;bd_sl*&#39; [g/cm3], &#39;clyppt_sl*&#39; [%], &#39;sltppt_sl*&#39; [%],</span>
<span class="sd">              &#39;ph_sl*&#39; [-].</span>
<span class="sd">        wflow_thicknesslayers: list, optional</span>
<span class="sd">            List of soil thickness per layer [mm], by default [50, 100, 50, 200, 800, ]</span>
<span class="sd">        target_conductivity: list, optional</span>
<span class="sd">            List of target vertical conductivities [mm/day] for each layer in</span>
<span class="sd">            ``wflow_thicknesslayers``. Set value to `None` if no specific value is</span>
<span class="sd">            required, by default [None, None, 5, None, None].</span>
<span class="sd">        lulc_vars : list[str], optional</span>
<span class="sd">            List of landuse parameters to prepare.</span>
<span class="sd">            The names are the columns of the mapping file.</span>
<span class="sd">            Can be a subset of: [&quot;landuse&quot;, &quot;vegetation_kext&quot;, &quot;land_manning_n&quot;,</span>
<span class="sd">            &quot;soil_compacted_fraction&quot;, &quot;vegetation_root_depth&quot;,</span>
<span class="sd">            &quot;vegetation_leaf_storage&quot;, &quot;vegetation_wood_storage&quot;, &quot;land_water_fraction&quot;,</span>
<span class="sd">            &quot;vegetation_crop_factor&quot;, &quot;vegetation_feddes_alpha_h1&quot;,</span>
<span class="sd">            &quot;vegetation_feddes_h1&quot;, &quot;vegetation_feddes_h2&quot;, &quot;vegetation_feddes_h3_high&quot;,</span>
<span class="sd">            &quot;vegetation_feddes_h3_low&quot;, &quot;vegetation_feddes_h4&quot;]</span>
<span class="sd">        paddy_waterlevels : dict, optional</span>
<span class="sd">            Dictionary with the minimum, optimal and maximum water levels for paddy</span>
<span class="sd">            fields [mm]. By default {&quot;demand_paddy_h_min&quot;: 20, &quot;demand_paddy_h_opt&quot;: 50,</span>
<span class="sd">            &quot;demand_paddy_h_max&quot;: 80}</span>
<span class="sd">        save_high_resolution_lulc : bool, optional</span>
<span class="sd">            Save the high resolution landuse map merged with the paddies to the static</span>
<span class="sd">            folder. By default False.</span>
<span class="sd">        output_names_suffix : str, optional</span>
<span class="sd">            Suffix to be added to the output names to avoid having to rename all the</span>
<span class="sd">            columns of the mapping tables. For example if the suffix is &quot;vito&quot;, all</span>
<span class="sd">            variables in lulc_vars will be renamed to &quot;landuse_vito&quot;, &quot;Kext_vito&quot;, etc.</span>
<span class="sd">            Note that the suffix will also be used to rename the paddy parameter</span>
<span class="sd">            soil_ksat_vertical_factor but not the soil_brooks_corey_c parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing LULC parameter maps including paddies.&quot;</span><span class="p">)</span>

        <span class="n">workflows</span><span class="o">.</span><span class="n">validate_lulc_vars</span><span class="p">(</span><span class="n">lulc_vars</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">output_names_suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># rename lulc_vars with the suffix</span>
            <span class="n">output_names</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">workflows</span><span class="o">.</span><span class="n">LULC_VARS_MAPPING</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">output_names_suffix</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lulc_vars</span>
            <span class="p">}</span>
            <span class="c1"># Add soil_ksat_vertical_factor</span>
            <span class="n">output_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;soil_ksat_vertical_factor&quot;</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;soil_ksat_vertical_factor_</span><span class="si">{</span><span class="n">output_names_suffix</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">workflows</span><span class="o">.</span><span class="n">LULC_VARS_MAPPING</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">lulc_vars</span><span class="p">}</span>
        <span class="c1"># update self._MAPS and self._WFLOW_NAMES with user defined output names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>

        <span class="c1"># Check if soil data is available</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;ksat_vertical&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;ksat_vertical and f are required to update the soil parameters with &quot;</span>
                <span class="s2">&quot;paddies. Please run setup_soilmaps first.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">lulc_mapping_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lulc_mapping_fn</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lulc_fn</span><span class="si">}</span><span class="s2">_mapping_default&quot;</span>
        <span class="c1"># read landuse map and mapping table</span>
        <span class="n">landuse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">lulc_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;landuse&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">df_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span>
            <span class="n">lulc_mapping_fn</span><span class="p">,</span>
            <span class="n">source_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;driver&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;pandas&quot;</span><span class="p">,</span> <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;index_col&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}}},</span>
        <span class="p">)</span>
        <span class="n">output_paddy_class</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">paddy_class</span> <span class="k">if</span> <span class="n">output_paddy_class</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">output_paddy_class</span>
        <span class="p">)</span>

        <span class="c1"># if needed, add paddies to landuse</span>
        <span class="k">if</span> <span class="n">paddy_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Read paddy map and mapping table</span>
            <span class="n">paddy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">paddy_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;paddy&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">paddy_mapping_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">paddy_mapping_fn</span> <span class="o">=</span> <span class="s2">&quot;paddy_mapping_default&quot;</span>
            <span class="n">df_paddy_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span>
                <span class="n">paddy_mapping_fn</span><span class="p">,</span>
                <span class="n">source_kwargs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;driver&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;pandas&quot;</span><span class="p">,</span> <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;index_col&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}}</span>
                <span class="p">},</span>
            <span class="p">)</span>

            <span class="n">landuse</span><span class="p">,</span> <span class="n">df_mapping</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">add_paddy_to_landuse</span><span class="p">(</span>
                <span class="n">landuse</span><span class="p">,</span>
                <span class="n">paddy</span><span class="p">,</span>
                <span class="n">paddy_class</span><span class="p">,</span>
                <span class="n">output_paddy_class</span><span class="o">=</span><span class="n">output_paddy_class</span><span class="p">,</span>
                <span class="n">df_mapping</span><span class="o">=</span><span class="n">df_mapping</span><span class="p">,</span>
                <span class="n">df_paddy_mapping</span><span class="o">=</span><span class="n">df_paddy_mapping</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">save_high_resolution_lulc</span><span class="p">:</span>
                <span class="n">output_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;maps&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>
                <span class="n">landuse</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">to_raster</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;landuse_with_paddy.tif&quot;</span><span class="p">))</span>
                <span class="n">df_mapping</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s2">&quot;landuse_with_paddy_mapping.csv&quot;</span><span class="p">))</span>

        <span class="c1"># Prepare landuse parameters</span>
        <span class="n">landuse_maps</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">landuse</span><span class="p">(</span>
            <span class="n">da</span><span class="o">=</span><span class="n">landuse</span><span class="p">,</span> <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">df_mapping</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">lulc_vars</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_landuse_on_staticmaps</span><span class="p">(</span><span class="n">landuse_maps</span><span class="p">,</span> <span class="n">lulc_vars</span><span class="p">,</span> <span class="n">output_names_suffix</span><span class="p">)</span>

        <span class="c1"># Update soil parameters if there are paddies in the domain</span>
        <span class="c1"># Get paddy pixels at model resolution</span>
        <span class="n">wflow_paddy</span> <span class="o">=</span> <span class="n">landuse_maps</span><span class="p">[</span><span class="s2">&quot;landuse&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">output_paddy_class</span>
        <span class="k">if</span> <span class="n">wflow_paddy</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;model.soil_layer__thickness&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">wflow_thicknesslayers</span>
            <span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;same thickness already present, skipping updating&quot;</span>
                    <span class="s2">&quot; `soil_brooks_corey_c` parameter&quot;</span>
                <span class="p">)</span>
                <span class="n">update_c</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Different thicknesslayers requested, updating &quot;</span>
                    <span class="s2">&quot;`soil_brooks_corey_c` parameter&quot;</span>
                <span class="p">)</span>
                <span class="n">update_c</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># Read soil data</span>
            <span class="n">soil</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">soil_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
            <span class="c1"># update soil parameters soil_brooks_corey_c and soil_ksat_vertical_factor</span>
            <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">v</span><span class="p">:</span> <span class="n">k</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data_vars</span>
            <span class="p">}</span>
            <span class="n">soil_maps</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">update_soil_with_paddy</span><span class="p">(</span>
                <span class="n">ds</span><span class="o">=</span><span class="n">soil</span><span class="p">,</span>
                <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
                <span class="n">paddy_mask</span><span class="o">=</span><span class="n">wflow_paddy</span><span class="p">,</span>
                <span class="n">soil_fn</span><span class="o">=</span><span class="n">soil_fn</span><span class="p">,</span>
                <span class="n">update_c</span><span class="o">=</span><span class="n">update_c</span><span class="p">,</span>
                <span class="n">wflow_layers</span><span class="o">=</span><span class="n">wflow_thicknesslayers</span><span class="p">,</span>
                <span class="n">target_conductivity</span><span class="o">=</span><span class="n">target_conductivity</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="n">soil_maps</span><span class="p">[</span><span class="s2">&quot;soil_ksat_vertical_factor&quot;</span><span class="p">],</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;soil_ksat_vertical_factor&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;soil_ksat_vertical_factor&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="s2">&quot;soil_brooks_corey_c&quot;</span> <span class="ow">in</span> <span class="n">soil_maps</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                    <span class="n">soil_maps</span><span class="p">[</span><span class="s2">&quot;soil_brooks_corey_c&quot;</span><span class="p">],</span>
                    <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;soil_brooks_corey_c&quot;</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;soil_brooks_corey_c&quot;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.soil_layer__thickness&quot;</span><span class="p">,</span> <span class="n">wflow_thicknesslayers</span><span class="p">)</span>
            <span class="c1"># Add paddy water levels to the config</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">paddy_waterlevels</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;input.static.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="si">}</span><span class="s2">.value&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="c1"># Update the states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="s2">&quot;state.variables.paddy_surface_water__depth&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_paddy_h&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No paddy fields found, skipping updating soil parameters&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_laimaps">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_laimaps.html#hydromt_wflow.WflowSbmModel.setup_laimaps">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_laimaps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lai_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">lulc_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lulc_sampling_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;any&quot;</span><span class="p">,</span>
        <span class="n">lulc_zero_classes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">buffer</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;vegetation_leaf_area_index&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set leaf area index (LAI) climatology maps per month [1,2,3,...,12].</span>

<span class="sd">        The values are resampled to the model resolution using the average value.</span>
<span class="sd">        Currently only directly cyclic LAI data is supported.</span>

<span class="sd">        If `lulc_fn` is provided, mapping tables from landuse classes to LAI values</span>
<span class="sd">        will be derived from the LULC data. These tables can then be re-used later if</span>
<span class="sd">        you would like to add new LAI maps derived from this mapping table and new</span>
<span class="sd">        landuse scenarios. We advise to use a larger `buffer` to ensure that LAI values</span>
<span class="sd">        can be assigned for all landuse classes and based on a large enough sample of</span>
<span class="sd">        the LULC data.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **vegetation_leaf_area_index** map: Leaf Area Index climatology [-]</span>
<span class="sd">            Resampled from source data using average. Assuming that missing values</span>
<span class="sd">            correspond to bare soil, these are set to zero before resampling.</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_basemaps`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lai_fn : str, xarray.DataArray</span>
<span class="sd">            Name of RasterDataset source for LAI parameters, see data/data_sources.yml.</span>

<span class="sd">            * Required variables: &#39;LAI&#39; [-]</span>

<span class="sd">            * Required dimensions: &#39;time&#39; = [1,2,3,...,12] (months)</span>
<span class="sd">        lulc_fn : str, xarray.DataArray, optional</span>
<span class="sd">            Name of RasterDataset source for landuse-landcover data.</span>
<span class="sd">            If provided, the LAI values are mapped to landuse classes and will be saved</span>
<span class="sd">            to a csv file.</span>
<span class="sd">        lulc_sampling_method : str, optional</span>
<span class="sd">            Resampling method for the LULC data to the LAI resolution. Two methods are</span>
<span class="sd">            supported:</span>

<span class="sd">            * &#39;any&#39; (default): if any cell of the desired landuse class is present in</span>
<span class="sd">              the resampling window (even just one), it will be used to derive LAI</span>
<span class="sd">              values. This method is less exact but will provide LAI values for all</span>
<span class="sd">              landuse classes for the high resolution landuse map.</span>
<span class="sd">            * &#39;mode&#39;: the most frequent value in the resampling window is</span>
<span class="sd">              used. This method is less precise as for cells with a lot of different</span>
<span class="sd">              landuse classes, the most frequent value might still be only a small</span>
<span class="sd">              fraction of the cell. More landuse classes should however be covered and</span>
<span class="sd">              it can always be used with the landuse map of the wflow model instead of</span>
<span class="sd">              the original high resolution one.</span>
<span class="sd">            * &#39;q3&#39;: only cells with the most frequent value (mode) and that cover 75%</span>
<span class="sd">              (q3) of the resampling window will be used. This method is more exact but</span>
<span class="sd">              for small basins, you may have less or no samples to derive LAI values</span>
<span class="sd">              for some classes.</span>
<span class="sd">        lulc_zero_classes : list, optional</span>
<span class="sd">            List of landuse classes that should have zero for leaf area index values</span>
<span class="sd">            for example waterbodies, open ocean etc. For very high resolution landuse</span>
<span class="sd">            maps, urban surfaces and bare areas can be included here as well.</span>
<span class="sd">            By default empty.</span>
<span class="sd">        buffer : int, optional</span>
<span class="sd">            Buffer in pixels around the region to read the data, by default 2.</span>
<span class="sd">        output_name : str</span>
<span class="sd">            Name of the output vegetation__leaf_area_index map.</span>
<span class="sd">            By default &quot;vegetation_leaf_area_index&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># retrieve data for region</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing LAI maps.&quot;</span><span class="p">)</span>
        <span class="n">wflow_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="n">wflow_var</span><span class="p">:</span> <span class="n">output_name</span><span class="p">})</span>
        <span class="n">da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">lai_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">lulc_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing LULC-LAI mapping table.&quot;</span><span class="p">)</span>
            <span class="n">da_lulc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">lulc_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span>
            <span class="p">)</span>
            <span class="c1"># derive mapping</span>
            <span class="n">df_lai_mapping</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">create_lulc_lai_mapping_table</span><span class="p">(</span>
                <span class="n">da_lulc</span><span class="o">=</span><span class="n">da_lulc</span><span class="p">,</span>
                <span class="n">da_lai</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">sampling_method</span><span class="o">=</span><span class="n">lulc_sampling_method</span><span class="p">,</span>
                <span class="n">lulc_zero_classes</span><span class="o">=</span><span class="n">lulc_zero_classes</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Save to csv</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lulc_fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isfile</span><span class="p">(</span><span class="n">lulc_fn</span><span class="p">):</span>
                <span class="n">df_fn</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;lai_per_lulc_</span><span class="si">{</span><span class="n">lulc_fn</span><span class="si">}</span><span class="s2">.csv&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">df_fn</span> <span class="o">=</span> <span class="s2">&quot;lai_per_lulc.csv&quot;</span>
            <span class="n">df_lai_mapping</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">df_fn</span><span class="p">))</span>

        <span class="c1"># Resample LAI data to wflow model resolution</span>
        <span class="n">da_lai</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">lai</span><span class="p">(</span>
            <span class="n">da</span><span class="o">=</span><span class="n">da</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Rename the first dimension to time</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">da_lai</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="s2">&quot;time&quot;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">da_lai</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;cyclic&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_laimaps_from_lulc_mapping">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_laimaps_from_lulc_mapping.html#hydromt_wflow.WflowSbmModel.setup_laimaps_from_lulc_mapping">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_laimaps_from_lulc_mapping</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lulc_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">lai_mapping_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;vegetation_leaf_area_index&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derive cyclic LAI maps from a LULC data source and a LULC-LAI mapping table.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **vegetation_leaf_area_index** map: Leaf Area Index climatology [-]</span>
<span class="sd">            Resampled from source data using average. Assuming that missing values</span>
<span class="sd">            correspond to bare soil, these are set to zero before resampling.</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_basemaps`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lulc_fn : str, xarray.DataArray</span>
<span class="sd">            Name of RasterDataset source for landuse-landcover data.</span>
<span class="sd">        lai_mapping_fn : str, pd.DataFrame</span>
<span class="sd">            Path to a mapping csv file from landuse in source name to</span>
<span class="sd">            LAI values. The csv file should contain rows with landuse classes</span>
<span class="sd">            and LAI values for each month. The columns should be named as the</span>
<span class="sd">            months (1,2,3,...,12).</span>
<span class="sd">            This table can be created using the :py:meth:`setup_laimaps` method.</span>
<span class="sd">        output_name : str</span>
<span class="sd">            Name of the output vegetation__leaf_area_index map.</span>
<span class="sd">            By default &quot;vegetation_leaf_area_index&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing LAI maps from LULC data using LULC-LAI mapping table.&quot;</span><span class="p">)</span>
        <span class="c1"># update self._MAPS and self._WFLOW_NAMES with user defined output names</span>
        <span class="n">wflow_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="n">wflow_var</span><span class="p">:</span> <span class="n">output_name</span><span class="p">})</span>

        <span class="c1"># read landuse map to DataArray</span>
        <span class="n">da</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">lulc_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;landuse&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">df_lai_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span>
            <span class="n">lai_mapping_fn</span><span class="p">,</span>
            <span class="n">source_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;driver&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;pandas&quot;</span><span class="p">,</span> <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;index_col&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}}},</span>
        <span class="p">)</span>
        <span class="c1"># process landuse with LULC-LAI mapping table</span>
        <span class="n">da_lai</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">lai_from_lulc_mapping</span><span class="p">(</span>
            <span class="n">da</span><span class="o">=</span><span class="n">da</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df_lai_mapping</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Add to grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">da_lai</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">])</span>
        <span class="c1"># Add to config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;cyclic&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_rootzoneclim">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_rootzoneclim.html#hydromt_wflow.WflowSbmModel.setup_rootzoneclim">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_rootzoneclim</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">run_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">forcing_obs_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">forcing_cc_hist_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">forcing_cc_fut_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">return_period</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
        <span class="n">Imax</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">start_hydro_year</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Sep&quot;</span><span class="p">,</span>
        <span class="n">start_field_capacity</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Apr&quot;</span><span class="p">,</span>
        <span class="n">LAI</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">rootzone_storage</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">correct_cc_deficit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">time_range</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">time_range_fut</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">missing_days_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">330</span><span class="p">,</span>
        <span class="n">output_name_rootingdepth</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;vegetation_root_depth_obs_20&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the vegetation_root_depth.</span>

<span class="sd">        Done by estimating the catchment-scale root-zone storage capacity from observed</span>
<span class="sd">        hydroclimatic data (and optionally also for climate change historical and</span>
<span class="sd">        future periods).</span>

<span class="sd">        This presents an alternative approach to determine the vegetation_root_depth</span>
<span class="sd">        based on hydroclimatic data instead of through a look-up table relating</span>
<span class="sd">        land use to rooting depth (as usually done for the wflow_sbm model).</span>
<span class="sd">        The method is based on the estimation of maximum annual storage deficits</span>
<span class="sd">        based on precipitation and estimated actual evaporation time series,</span>
<span class="sd">        which in turn are estimated from observed streamflow data and</span>
<span class="sd">        long-term precipitation and potential evap. data, as explained in</span>
<span class="sd">        Bouaziz et al. (2022).</span>

<span class="sd">        The main assumption is that vegetation adapts its rootzone storage capacity</span>
<span class="sd">        to overcome dry spells with a certain return period (typically 20 years for</span>
<span class="sd">        forest ecosystems). In response to a changing climtate,</span>
<span class="sd">        it is likely that vegetation also adapts its rootzone storage capacity,</span>
<span class="sd">        thereby changing model parameters for future conditions.</span>
<span class="sd">        This method also allows to estimate the change in rootzone storage capacity</span>
<span class="sd">        in response to a changing climate.</span>

<span class="sd">        As the method requires precipitation and potential evaporation timeseries,</span>
<span class="sd">        it may be useful to run this method as an update step in the setting-up of</span>
<span class="sd">        the hydrological model, once the forcing files have already been derived.</span>
<span class="sd">        In addition the setup_soilmaps method is also required to calculate</span>
<span class="sd">        the vegetation_root_depth (rootzone_storage / (theta_s-theta_r)).</span>
<span class="sd">        The setup_laimaps method is also required if LAI is set to True</span>
<span class="sd">        (interception capacity estimated from LAI maps, instead of providing</span>
<span class="sd">        a default maximum interception capacity).</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Bouaziz, L. J. E., Aalbers, E. E., Weerts, A. H., Hegnauer, M., Buiteveld,</span>
<span class="sd">        H., Lammersen, R., Stam, J., Sprokkereef, E., Savenije, H. H. G. and</span>
<span class="sd">        Hrachowitz, M. (2022). Ecosystem adaptation to climate change: the</span>
<span class="sd">        sensitivity of hydrological predictions to time-dynamic model parameters,</span>
<span class="sd">        Hydrology and Earth System Sciences, 26(5), 1295-1318. DOI:</span>
<span class="sd">        10.5194/hess-26-1295-2022.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **vegetation_root_depth_{forcing}_{RP}** map: rooting depth [mm of the soil \</span>
<span class="sd">column] estimated from hydroclimatic data {forcing: obs, cc_hist or cc_fut} for \</span>
<span class="sd">different return periods RP. The translation to vegetation_root_depth is done by \</span>
<span class="sd">dividing the rootzone_storage by (theta_s - theta_r).</span>
<span class="sd">        * **meta_rootzone_storage_{forcing}_{RP}** geom: polygons of rootzone \</span>
<span class="sd">storage capacity [mm of water] for each catchment estimated before filling \</span>
<span class="sd">the missing with data from downstream catchments.</span>
<span class="sd">        * **meta_rootzone_storage_{forcing}_{RP}** map: rootzone storage capacity \</span>
<span class="sd">[mm of water] estimated from hydroclimatic data {forcing: obs, cc_hist or cc_fut} for \</span>
<span class="sd">different return periods RP. Only if rootzone_storage is set to True!</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_soilmaps`</span>
<span class="sd">        * :py:meth:`~WflowSbmModel.setup_laimaps` or equivalent</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        run_fn : str, Path, xr.Dataset</span>
<span class="sd">            Geodataset with streamflow timeseries (m3/s) per x,y location.</span>
<span class="sd">            The geodataset expects the coordinate names &quot;index&quot; (for each station id)</span>
<span class="sd">            and the variable name &quot;discharge&quot;.</span>
<span class="sd">        forcing_obs_fn : str, Path, xr.Dataset</span>
<span class="sd">            Gridded timeseries with the observed forcing [mm/timestep].</span>
<span class="sd">            Expects to have variables &quot;precip&quot; and &quot;pet&quot;.</span>
<span class="sd">        forcing_cc_hist_fn : str, Path, xr.Dataset, optional</span>
<span class="sd">            Gridded timeseries with the simulated historical forcing [mm/timestep],</span>
<span class="sd">            based on a climate model. Expects to have variables &quot;precip&quot; and &quot;pet&quot;.</span>
<span class="sd">            The default is None.</span>
<span class="sd">        forcing_cc_fut_fn : str, optional</span>
<span class="sd">            Gridded timeseries with the simulated climate forcing [mm/timestep],</span>
<span class="sd">            based on a climate model. Expects to have variables &quot;precip&quot; and &quot;pet&quot;.</span>
<span class="sd">            The default is None.</span>
<span class="sd">        chunksize : int, optional</span>
<span class="sd">            Chunksize on time dimension for processing data (not for saving to</span>
<span class="sd">            disk!). The default is 100.</span>
<span class="sd">        return_period : list, optional</span>
<span class="sd">            List with one or more values indicating the return period(s) (in</span>
<span class="sd">            years) for which the rootzone storage depth should be calculated. The</span>
<span class="sd">            default is [2,3,5,10,15,20,25,50,60,100] years.</span>
<span class="sd">        Imax : float, optional</span>
<span class="sd">            The maximum interception storage capacity [mm]. The default is 2.0 mm.</span>
<span class="sd">        start_hydro_year : str, optional</span>
<span class="sd">            The start month (abbreviated to the first three letters of the month,</span>
<span class="sd">            starting with a capital letter) of the hydrological year. The</span>
<span class="sd">            default is &#39;Sep&#39;.</span>
<span class="sd">        start_field_capacity : str, optional</span>
<span class="sd">            The end of the wet season / commencement of dry season. This is the</span>
<span class="sd">            moment when the soil is at field capacity, i.e. there is no storage</span>
<span class="sd">            deficit yet. The default is &#39;Apr&#39;.</span>
<span class="sd">        LAI : bool, optional</span>
<span class="sd">            Determine whether the leaf area index will be used to</span>
<span class="sd">            determine Imax. The default is False.</span>
<span class="sd">            If set to True, requires to have run setup_laimaps.</span>
<span class="sd">        rootzone_storage : bool, optional</span>
<span class="sd">            Determines whether the rootzone storage maps</span>
<span class="sd">            should be stored in the grid or not. The default is False.</span>
<span class="sd">        correct_cc_deficit : bool, optional</span>
<span class="sd">            Determines whether a bias-correction of the future deficit should be</span>
<span class="sd">            applied using the cc_hist deficit. Only works if the time periods of</span>
<span class="sd">            cc_hist and cc_fut are the same. If the climate change scenario and</span>
<span class="sd">            hist period are bias-corrected, this should probably set to False.</span>
<span class="sd">            The default is False.</span>
<span class="sd">        time_range: tuple, optional</span>
<span class="sd">            Select which time period to read from all the forcing files.</span>
<span class="sd">            There should be some overlap between the time period available in the</span>
<span class="sd">            forcing files for the historical period and in the observed streamflow data.</span>
<span class="sd">        missing_days_threshold: int, optional</span>
<span class="sd">            Minimum number of days within a year for that year to be counted in</span>
<span class="sd">            the long-term Budyko analysis.</span>
<span class="sd">        output_name_rootingdepth: str, optional</span>
<span class="sd">            Update the wflow_sbm model config of the vegetation_root_depth variable with</span>
<span class="sd">            the estimated vegetation_root_depth.</span>
<span class="sd">            The default is vegetation_root_depth_obs_20,</span>
<span class="sd">            which requires to have RP 20 in the list provided for \</span>
<span class="sd">the return_period argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing climate based root zone storage parameter maps.&quot;</span><span class="p">)</span>
        <span class="c1"># Open the data sets</span>
        <span class="n">ds_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">forcing_obs_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">,</span> <span class="s2">&quot;precip&quot;</span><span class="p">],</span>
            <span class="n">time_range</span><span class="o">=</span><span class="n">time_range</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ds_cc_hist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">forcing_cc_hist_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ds_cc_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">forcing_cc_hist_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">,</span> <span class="s2">&quot;precip&quot;</span><span class="p">],</span>
                <span class="n">time_range</span><span class="o">=</span><span class="n">time_range</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">ds_cc_fut</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">forcing_cc_fut_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ds_cc_fut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">forcing_cc_fut_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">,</span> <span class="s2">&quot;precip&quot;</span><span class="p">],</span>
                <span class="n">time_range</span><span class="o">=</span><span class="n">time_range_fut</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># observed streamflow data</span>
        <span class="n">dsrun</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataset</span><span class="p">(</span>
            <span class="n">run_fn</span><span class="p">,</span> <span class="n">single_var_as_array</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">time_range</span><span class="o">=</span><span class="n">time_range</span>
        <span class="p">)</span>

        <span class="c1"># make sure dsrun overlaps with ds_obs, otherwise give error</span>
        <span class="k">if</span> <span class="n">dsrun</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ds_obs</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">dsrun</span> <span class="o">=</span> <span class="n">dsrun</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">ds_obs</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dsrun</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ds_obs</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">dsrun</span> <span class="o">=</span> <span class="n">dsrun</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">ds_obs</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dsrun</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;No overlapping period between the meteo and observed streamflow data&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check if setup_soilmaps and setup_laimaps were run when:</span>
        <span class="c1"># if LAI == True and rooting_depth == True</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">LAI</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;LAI variable not found in grid. </span><span class="se">\</span>
<span class="s2">Set LAI to False or run setup_laimaps first&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;theta_r&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;theta_s&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span>
        <span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;theta_s or theta_r variables not found in grid. </span><span class="se">\</span>
<span class="s2">Run setup_soilmaps first&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Run the rootzone clim workflow</span>
        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data_vars</span>
        <span class="p">}</span>
        <span class="n">dsout</span><span class="p">,</span> <span class="n">gdf</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">rootzoneclim</span><span class="p">(</span>
            <span class="n">dsrun</span><span class="o">=</span><span class="n">dsrun</span><span class="p">,</span>
            <span class="n">ds_obs</span><span class="o">=</span><span class="n">ds_obs</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">flwdir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flwdir</span><span class="p">,</span>
            <span class="n">ds_cc_hist</span><span class="o">=</span><span class="n">ds_cc_hist</span><span class="p">,</span>
            <span class="n">ds_cc_fut</span><span class="o">=</span><span class="n">ds_cc_fut</span><span class="p">,</span>
            <span class="n">return_period</span><span class="o">=</span><span class="n">return_period</span><span class="p">,</span>
            <span class="n">Imax</span><span class="o">=</span><span class="n">Imax</span><span class="p">,</span>
            <span class="n">start_hydro_year</span><span class="o">=</span><span class="n">start_hydro_year</span><span class="p">,</span>
            <span class="n">start_field_capacity</span><span class="o">=</span><span class="n">start_field_capacity</span><span class="p">,</span>
            <span class="n">LAI</span><span class="o">=</span><span class="n">LAI</span><span class="p">,</span>
            <span class="n">rootzone_storage</span><span class="o">=</span><span class="n">rootzone_storage</span><span class="p">,</span>
            <span class="n">correct_cc_deficit</span><span class="o">=</span><span class="n">correct_cc_deficit</span><span class="p">,</span>
            <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
            <span class="n">missing_days_threshold</span><span class="o">=</span><span class="n">missing_days_threshold</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># set nodata value outside basin</span>
        <span class="n">dsout</span> <span class="o">=</span> <span class="n">dsout</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">999</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">dsout</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="n">dsout</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">set_nodata</span><span class="p">(</span><span class="o">-</span><span class="mi">999</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">dsout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;rootzone_storage&quot;</span><span class="p">)</span>

        <span class="c1"># update config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;input.static.vegetation_root__depth&quot;</span><span class="p">,</span> <span class="n">output_name_rootingdepth</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_soilmaps">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_soilmaps.html#hydromt_wflow.WflowSbmModel.setup_soilmaps">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_soilmaps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">soil_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;soilgrids&quot;</span><span class="p">,</span>
        <span class="n">ptf_ksatver</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;brakensiek&quot;</span><span class="p">,</span>
        <span class="n">wflow_thicknesslayers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">800</span><span class="p">],</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;soil_water__saturated_volume_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;soil_theta_s&quot;</span><span class="p">,</span>
            <span class="s2">&quot;soil_water__residual_volume_fraction&quot;</span><span class="p">:</span> <span class="s2">&quot;soil_theta_r&quot;</span><span class="p">,</span>
            <span class="s2">&quot;soil_surface_water__vertical_saturated_hydraulic_conductivity&quot;</span><span class="p">:</span> <span class="s2">&quot;soil_ksat_vertical&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;soil__thickness&quot;</span><span class="p">:</span> <span class="s2">&quot;soil_thickness&quot;</span><span class="p">,</span>
            <span class="s2">&quot;soil_water__vertical_saturated_hydraulic_conductivity_scale_parameter&quot;</span><span class="p">:</span> <span class="s2">&quot;soil_f&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;soil_layer_water__brooks_corey_exponent&quot;</span><span class="p">:</span> <span class="s2">&quot;soil_brooks_corey_c&quot;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derive several (layered) soil parameters.</span>

<span class="sd">        Based on a database with physical soil properties using available point-scale</span>
<span class="sd">        (pedo)transfer functions (PTFs) from literature with upscaling rules to</span>
<span class="sd">        ensure flux matching across scales.</span>

<span class="sd">        Currently, supported ``soil_fn`` is &quot;soilgrids&quot; and &quot;soilgrids_2020&quot;.</span>
<span class="sd">        ``ptf_ksatver`` (PTF for the vertical hydraulic conductivity) options are</span>
<span class="sd">        &quot;brakensiek&quot; and &quot;cosby&quot;. &quot;soilgrids&quot; provides data at 7 specific depths,</span>
<span class="sd">        while &quot;soilgrids_2020&quot; provides data averaged over 6 depth intervals.</span>
<span class="sd">        This leads to small changes in the workflow:</span>
<span class="sd">        (1) M parameter uses midpoint depths in soilgrids_2020 versus \</span>
<span class="sd">specific depths in soilgrids,</span>
<span class="sd">        (2) weighted average of soil properties over soil thickness is done with \</span>
<span class="sd">the trapezoidal rule in soilgrids versus simple block weighted average in \</span>
<span class="sd">soilgrids_2020,</span>
<span class="sd">        (3) the soil_brooks_corey_c parameter is computed as weighted average over \</span>
<span class="sd">wflow_sbm soil layers defined in ``wflow_thicknesslayers``.</span>

<span class="sd">        The required data from soilgrids are soil bulk density &#39;bd_sl*&#39; [g/cm3], \</span>
<span class="sd">clay content &#39;clyppt_sl*&#39; [%], silt content &#39;sltppt_sl*&#39; [%], organic carbon content \</span>
<span class="sd">&#39;oc_sl*&#39; [%], pH &#39;ph_sl*&#39; [-], sand content &#39;sndppt_sl*&#39; [%] and soil thickness \</span>
<span class="sd">&#39;soilthickness&#39; [cm].</span>

<span class="sd">        A ``soil_mapping_fn`` can optionnally be provided to derive parameters based</span>
<span class="sd">        on soil texture classes. A default table *soil_mapping_default* is available</span>
<span class="sd">        to derive the infiltration capacity of the soil.</span>

<span class="sd">        The following maps are added to grid:</span>

<span class="sd">        * **soil_theta_s** map:</span>
<span class="sd">            average saturated soil water content [m3/m3]</span>
<span class="sd">        * **soil_theta_r** map:</span>
<span class="sd">            average residual water content [m3/m3]</span>
<span class="sd">        * **soil_ksat_vertical** map:</span>
<span class="sd">            vertical saturated hydraulic conductivity at soil surface [mm/day]</span>
<span class="sd">        * **soil_thickness** map:</span>
<span class="sd">            soil thickness [mm]</span>
<span class="sd">        * **soil_f** map: scaling parameter controlling the decline of ksat_vertical \</span>
<span class="sd">[mm-1] (fitted with curve_fit (scipy.optimize)), bounds are checked</span>
<span class="sd">        * **soil_f_** map:</span>
<span class="sd">            scaling parameter controlling the decline of soil_ksat_vertical \</span>
<span class="sd">[mm-1] (fitted with numpy linalg regression), bounds are checked</span>
<span class="sd">        * **soil_brooks_corey_c_n** map:</span>
<span class="sd">            Brooks Corey coefficients [-] based on pore size distribution, \</span>
<span class="sd">a map for each of the wflow_sbm soil layers (n in total)</span>
<span class="sd">        * **meta_{soil_fn}_ksat_vertical_[z]cm** map: vertical hydraulic conductivity</span>
<span class="sd">            [mm/day] at soil depths [z] of ``soil_fn`` data</span>
<span class="sd">            [0.0, 5.0, 15.0, 30.0, 60.0, 100.0, 200.0]</span>
<span class="sd">        * **meta_soil_texture** map: soil texture based on USDA soil texture triangle \</span>
<span class="sd">(mapping: [1:Clay, 2:Silty Clay, 3:Silty Clay-Loam, 4:Sandy Clay, 5:Sandy Clay-Loam, \</span>
<span class="sd">6:Clay-Loam, 7:Silt, 8:Silt-Loam, 9:Loam, 10:Sand, 11: Loamy Sand, 12:Sandy Loam])</span>


<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_basemaps`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        soil_fn : {&#39;soilgrids&#39;, &#39;soilgrids_2020&#39;}</span>
<span class="sd">            Name of RasterDataset source for soil parameter maps, see</span>
<span class="sd">            data/data_sources.yml.</span>
<span class="sd">            Should contain info for the 7 soil depths of soilgrids</span>
<span class="sd">            (or 6 depths intervals for soilgrids_2020).</span>
<span class="sd">            * Required variables: \</span>
<span class="sd">&#39;bd_sl*&#39; [g/cm3], &#39;clyppt_sl*&#39; [%], &#39;sltppt_sl*&#39; [%], &#39;oc_sl*&#39; [%], &#39;ph_sl*&#39; [-], \</span>
<span class="sd">&#39;sndppt_sl*&#39; [%], &#39;soilthickness&#39; [cm]</span>
<span class="sd">        ptf_ksatver : {&#39;brakensiek&#39;, &#39;cosby&#39;}</span>
<span class="sd">            Pedotransfer function (PTF) to use for calculation of ksat vertical</span>
<span class="sd">            (vertical saturated hydraulic conductivity [mm/day]).</span>
<span class="sd">            By default &#39;brakensiek&#39;.</span>
<span class="sd">        wflow_thicknesslayers : list of int, optional</span>
<span class="sd">            Thickness of soil layers [mm] for wflow_sbm soil model.</span>
<span class="sd">            By default [100, 300, 800] for layers at depths 100, 400, 1200 and &gt;1200 mm.</span>
<span class="sd">            Used only for Brooks Corey coefficients.</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing soil parameter maps.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>
        <span class="c1"># TODO add variables list with required variable names</span>
        <span class="n">dsin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span><span class="n">soil_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">dsout</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">soilgrids</span><span class="p">(</span>
            <span class="n">ds</span><span class="o">=</span><span class="n">dsin</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">ptfKsatVer</span><span class="o">=</span><span class="n">ptf_ksatver</span><span class="p">,</span>
            <span class="n">soil_fn</span><span class="o">=</span><span class="n">soil_fn</span><span class="p">,</span>
            <span class="n">wflow_layers</span><span class="o">=</span><span class="n">wflow_thicknesslayers</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reset_coords</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dsout</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">dsout</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>

        <span class="c1"># Update the toml file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.soil_layer__thickness&quot;</span><span class="p">,</span> <span class="n">wflow_thicknesslayers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">dsout</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_ksathorfrac">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_ksathorfrac.html#hydromt_wflow.WflowSbmModel.setup_ksathorfrac">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_ksathorfrac</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ksat_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">variable</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">resampling_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;average&quot;</span><span class="p">,</span>
        <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set KsatHorFrac parameter values from a predetermined map.</span>

<span class="sd">        This predetermined map contains (preferably) &#39;calibrated&#39; values of \</span>
<span class="sd">the KsatHorFrac parameter. This map is either selected from the wflow Deltares data \</span>
<span class="sd">or created by a third party/ individual.</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_basemaps`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ksat_fn : str, xr.DataArray</span>
<span class="sd">            The identifier of the KsatHorFrac dataset in the data catalog.</span>
<span class="sd">        variable : str, optional</span>
<span class="sd">            The variable name for the subsurface_ksat_horizontal_ratio map to</span>
<span class="sd">            use in ``ksat_fn`` in case ``ksat_fn`` contains several variables.</span>
<span class="sd">            By default None.</span>
<span class="sd">        resampling_method : str, optional</span>
<span class="sd">            The resampling method when up- or downscaled, by default &quot;average&quot;</span>
<span class="sd">        output_name : str, optional</span>
<span class="sd">            The name of the output map. If None (default), the name will be set</span>
<span class="sd">            to the name of the ksat_fn DataArray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing KsatHorFrac parameter map.&quot;</span><span class="p">)</span>
        <span class="n">wflow_var</span> <span class="o">=</span> <span class="s2">&quot;subsurface_water__horizontal_to_vertical_saturated_hydraulic_conductivity_ratio&quot;</span>  <span class="c1"># noqa: E501</span>
        <span class="n">dain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">ksat_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">variable</span><span class="p">,</span>
            <span class="n">single_var_as_array</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Ensure its a DataArray</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dain</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The ksat_fn data contains several variables. </span><span class="se">\</span>
<span class="s2">Select the variable to use for subsurface_ksat_horizontal_ratio </span><span class="se">\</span>
<span class="s2">using &#39;variable&#39; argument.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Create scaled subsurface_ksat_horizontal_ratio map</span>
        <span class="n">daout</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">ksat_horizontal_ratio</span><span class="p">(</span>
            <span class="n">dain</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">resampling_method</span><span class="o">=</span><span class="n">resampling_method</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">output_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">daout</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">output_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="n">wflow_var</span><span class="p">:</span> <span class="n">daout</span><span class="o">.</span><span class="n">name</span><span class="p">})</span>
        <span class="c1"># Set the grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">daout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">daout</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_ksatver_vegetation">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_ksatver_vegetation.html#hydromt_wflow.WflowSbmModel.setup_ksatver_vegetation">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_ksatver_vegetation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">soil_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;soilgrids&quot;</span><span class="p">,</span>
        <span class="n">alfa</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">4.5</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;soil_ksat_vertical_vegetation&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Correct vertical saturated hydraulic conductivity with vegetation properties.</span>

<span class="sd">        This allows to account for biologically-promoted soil structure and \</span>
<span class="sd">        heterogeneities in natural landscapes based on the work of \</span>
<span class="sd">        Bonetti et al. (2021) https://www.nature.com/articles/s43247-021-00180-0.</span>

<span class="sd">        This method requires to have run setup_soilgrids and setup_lai first.</span>

<span class="sd">        The following map is added to grid:</span>

<span class="sd">        * **KsatVer_vegetation** map: saturated hydraulic conductivity considering \</span>
<span class="sd">        vegetation characteristics [mm/d]</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_soilmaps`</span>
<span class="sd">        * :py:meth:`~WflowSbmModel.setup_laimaps` or equivalent</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        soil_fn : {&#39;soilgrids&#39;, &#39;soilgrids_2020&#39;}</span>
<span class="sd">            Name of RasterDataset source for soil parameter maps, see</span>
<span class="sd">            data/data_sources.yml.</span>
<span class="sd">            Should contain info for the sand percentage of the upper layer</span>
<span class="sd">            * Required variable: &#39;sndppt_sl1&#39; [%]</span>
<span class="sd">        alfa : float, optional</span>
<span class="sd">            Shape parameter. The default is 4.5 when using LAI.</span>
<span class="sd">        beta : float, optional</span>
<span class="sd">            Shape parameter. The default is 5 when using LAI.</span>
<span class="sd">        output_name : dict, optional</span>
<span class="sd">            Name of the output map. By default &#39;KsatVer_vegetation&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Modifying ksat_vertical based on vegetation characteristics&quot;</span><span class="p">)</span>
        <span class="n">wflow_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;ksat_vertical&quot;</span><span class="p">]]</span>

        <span class="c1"># open soil dataset to get sand percentage</span>
        <span class="n">sndppt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">soil_fn</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sndppt_sl1&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># in ksatver_vegetation, ksat_vertical should be provided in mm/d</span>
        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data_vars</span>
        <span class="p">}</span>
        <span class="n">ksatver_vegetation</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">ksatver_vegetation</span><span class="p">(</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">sndppt</span><span class="o">=</span><span class="n">sndppt</span><span class="p">,</span>
            <span class="n">alfa</span><span class="o">=</span><span class="n">alfa</span><span class="p">,</span>
            <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="n">wflow_var</span><span class="p">:</span> <span class="n">output_name</span><span class="p">})</span>
        <span class="c1"># add to grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ksatver_vegetation</span><span class="p">,</span> <span class="n">output_name</span><span class="p">)</span>
        <span class="c1"># update config file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">output_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_allocation_areas">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_allocation_areas.html#hydromt_wflow.WflowSbmModel.setup_allocation_areas">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_allocation_areas</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">waterareas_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">priority_basins</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">minimum_area</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">50.0</span><span class="p">,</span>
        <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;demand_allocation_area_id&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create water demand allocation areas.</span>

<span class="sd">        The areas are based on the wflow model basins (at model resolution), the</span>
<span class="sd">        wflow model rivers and water areas or regions for allocation.</span>

<span class="sd">        Water regions are generally defined by sub-river-basins within a Country. In</span>
<span class="sd">        order to mimic reality, it is advisable to avoid cross-Country-border</span>
<span class="sd">        abstractions. Whenever information is available, it is strongly recommended to</span>
<span class="sd">        align the water regions with the actual areas managed by water management</span>
<span class="sd">        authorities, such as regional water boards.</span>

<span class="sd">        The allocation area will be an intersection of the wflow model basins and the</span>
<span class="sd">        water areas. For areas that do not contain river cells after intersection with</span>
<span class="sd">        the water areas, the priority_basins flag can be used to decide if these basins</span>
<span class="sd">        should be merged with the closest downstream basin or with any large enough</span>
<span class="sd">        basin in the same water area.</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_rivers`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        waterareas_fn : str | gpd.GeoDataFrame</span>
<span class="sd">            Administrative boundaries GeoDataFrame data, this could be</span>
<span class="sd">            e.g. water management areas by water boards or the administrative</span>
<span class="sd">            boundaries of countries.</span>
<span class="sd">        priority_basins : bool, optional</span>
<span class="sd">            If True, merge the basins with the closest downstream basin, else merge</span>
<span class="sd">            with any large enough basin in the same water area, by default True.</span>
<span class="sd">        minimum_area : float</span>
<span class="sd">            Minimum area of the subbasins to keep in km2. Default is 50 km2.</span>
<span class="sd">        output_name : str, optional</span>
<span class="sd">            Name of the allocation areas map to be saved in the wflow model staticmaps</span>
<span class="sd">            and staticgeoms. Default is &#39;demand_allocation_area_id&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing water demand allocation map.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="s2">&quot;land_water_allocation_area__count&quot;</span><span class="p">:</span> <span class="n">output_name</span><span class="p">})</span>
        <span class="c1"># Read the data</span>
        <span class="n">waterareas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">waterareas_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Create the allocation grid</span>
        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">}</span>
        <span class="n">da_alloc</span><span class="p">,</span> <span class="n">gdf_alloc</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">allocation_areas</span><span class="p">(</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">waterareas</span><span class="o">=</span><span class="n">waterareas</span><span class="p">,</span>
            <span class="n">basins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins</span><span class="p">,</span>
            <span class="n">priority_basins</span><span class="o">=</span><span class="n">priority_basins</span><span class="p">,</span>
            <span class="n">minimum_area</span><span class="o">=</span><span class="n">minimum_area</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">da_alloc</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">output_name</span><span class="p">)</span>
        <span class="c1"># Update the config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;input.static.land_water_allocation_area__count&quot;</span><span class="p">,</span> <span class="n">output_name</span><span class="p">)</span>
        <span class="c1"># Add alloc to geoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">gdf_alloc</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">output_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_allocation_surfacewaterfrac">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_allocation_surfacewaterfrac.html#hydromt_wflow.WflowSbmModel.setup_allocation_surfacewaterfrac">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_allocation_surfacewaterfrac</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">gwfrac_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">waterareas_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">gwbodies_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ncfrac_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">interpolate_nodata</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">mask_and_scale_gwfrac</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">output_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;demand_surface_water_ratio&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the fraction of water allocated from surface water.</span>

<span class="sd">        This fraction entails the division of the water demand between surface water,</span>
<span class="sd">        ground water (aquifers) and non conventional sources (e.g. desalination plants).</span>

<span class="sd">        The surface water fraction is based on the raw groundwater fraction, if</span>
<span class="sd">        groundwater bodies are present (these are absent in e.g. mountainous regions),</span>
<span class="sd">        a fraction of water consumed that is obtained by non-conventional means and the</span>
<span class="sd">        water source areas.</span>

<span class="sd">        Non-conventional water could e.g. be water acquired by desalination of ocean or</span>
<span class="sd">        other brackish water.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **demand_surface_water_ratio**: fraction of water allocated from surface water</span>
<span class="sd">          [0-1]</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_basemaps`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gwfrac_fn : str | xr.DataArray</span>
<span class="sd">            The raw groundwater fraction per grid cell. The values of these cells need</span>
<span class="sd">            to be between 0 and 1.</span>
<span class="sd">        waterareas_fn : str| xr.DataArray</span>
<span class="sd">            The areas over which the water has to be distributed. This may either be</span>
<span class="sd">            a global (or more local map). If not provided, the source areas created by</span>
<span class="sd">            the `setup_allocation_areas` will be used.</span>
<span class="sd">        gwbodies_fn : str | xr.DataArray | None</span>
<span class="sd">            The presence of groundwater bodies per grid cell. The values are ought to</span>
<span class="sd">            be binary (either 0 or 1). If they are not provided, we assume groundwater</span>
<span class="sd">            bodies are present where gwfrac is more than 0.</span>
<span class="sd">        ncfrac_fn : str | xr.DataArray | None</span>
<span class="sd">            The non-conventional fraction. Same types of values apply as for</span>
<span class="sd">            `gwfrac_fn`. If not provided, we assume no non-conventional sources are</span>
<span class="sd">            used.</span>
<span class="sd">        interpolate_nodata : bool, optional</span>
<span class="sd">            If True, nodata values in the resulting demand_surface_water_ratio map will</span>
<span class="sd">            be linearly</span>
<span class="sd">            interpolated. Else a default value of 1 will be used for nodata values</span>
<span class="sd">            (default).</span>
<span class="sd">        mask_and_scale_gwfrac : bool, optional</span>
<span class="sd">            If True, gwfrac will be masked for areas with no groundwater bodies. To keep</span>
<span class="sd">            the average gwfrac used over waterareas similar after the masking, gwfrac</span>
<span class="sd">            for areas with groundwater bodies can increase. If False, gwfrac will be</span>
<span class="sd">            used as is. By default True.</span>
<span class="sd">        output_name : str, optional</span>
<span class="sd">            Name of the fraction of surface water used map to be saved in the wflow</span>
<span class="sd">            model staticmaps file. Default is &#39;demand_surface_water_ratio&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing surface water fraction map.&quot;</span><span class="p">)</span>
        <span class="c1"># Load the data</span>
        <span class="n">gwfrac_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">gwfrac_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">gwbodies_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gwbodies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">gwbodies_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gwbodies</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">ncfrac_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ncfrac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">ncfrac_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ncfrac</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># check whether to use the models own allocation areas</span>
        <span class="k">if</span> <span class="n">waterareas_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using wflow model allocation areas.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;allocation_areas&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;No allocation areas found. Run setup_allocation_areas first &quot;</span>
                    <span class="s2">&quot;or provide a waterareas_fn.&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span>
            <span class="n">waterareas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;allocation_areas&quot;</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">waterareas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">waterareas_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Call the workflow</span>
        <span class="n">w_frac</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">surfacewaterfrac_used</span><span class="p">(</span>
            <span class="n">gwfrac_raw</span><span class="o">=</span><span class="n">gwfrac_raw</span><span class="p">,</span>
            <span class="n">da_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
            <span class="n">waterareas</span><span class="o">=</span><span class="n">waterareas</span><span class="p">,</span>
            <span class="n">gwbodies</span><span class="o">=</span><span class="n">gwbodies</span><span class="p">,</span>
            <span class="n">ncfrac</span><span class="o">=</span><span class="n">ncfrac</span><span class="p">,</span>
            <span class="n">interpolate</span><span class="o">=</span><span class="n">interpolate_nodata</span><span class="p">,</span>
            <span class="n">mask_and_scale_gwfrac</span><span class="o">=</span><span class="n">mask_and_scale_gwfrac</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Update the settings toml</span>
        <span class="n">wflow_var</span> <span class="o">=</span> <span class="s2">&quot;land_surface_water__withdrawal_fraction&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">({</span><span class="n">wflow_var</span><span class="p">:</span> <span class="n">output_name</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;input.static.</span><span class="si">{</span><span class="n">wflow_var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">output_name</span><span class="p">)</span>

        <span class="c1"># Set the dataarray to the wflow grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">w_frac</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">output_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_domestic_demand">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_domestic_demand.html#hydromt_wflow.WflowSbmModel.setup_domestic_demand">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_domestic_demand</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">domestic_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">population_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">domestic_fn_original_res</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;domestic__gross_water_demand_volume_flux&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_domestic_gross&quot;</span><span class="p">,</span>
            <span class="s2">&quot;domestic__net_water_demand_volume_flux&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_domestic_net&quot;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare domestic water demand maps from a raster dataset.</span>

<span class="sd">        Both gross and netto domestic demand should be provided in `domestic_fn`. They</span>
<span class="sd">        can either be cyclic or non-cyclic.</span>

<span class="sd">        To improve accuracy, the domestic demand can be downsampled based on a provided</span>
<span class="sd">        population dataset. If the data you are using was already downscaled using a</span>
<span class="sd">        different source for population data, you may decide to first resample to the</span>
<span class="sd">        original resolution of `domestic_fn` before downsampling with `population_fn`.</span>
<span class="sd">        For example, the pcr_globwb dataset is at a resolution of 0.0083333333 degrees,</span>
<span class="sd">        while the original data has a resolution of 0.5 degrees. Use the</span>
<span class="sd">        `domestic_fn_original_res` parameter to specify the original resolution.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **demand_domestic_gross**: gross domestic water demand [mm/day]</span>
<span class="sd">        * **demand_domestic_net**: net domestic water demand [mm/day]</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_basemaps`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        domestic_fn : str | xr.Dataset</span>
<span class="sd">            The domestic dataset. This can either be the dataset directly (xr.Dataset),</span>
<span class="sd">            a string referring to an entry in the data catalog or a dictionary</span>
<span class="sd">            containing the name of the dataset (keyword: `source`) and any optional</span>
<span class="sd">            keyword arguments (e.g. `version`). The data can be cyclic</span>
<span class="sd">            (with a `time` dimension) or non-cyclic. Allowed cyclic data can be monthly</span>
<span class="sd">            (12) or dayofyear (365 or 366).</span>

<span class="sd">            * Required variables: &#39;domestic_gross&#39; [mm/day], &#39;domestic_net&#39; [mm/day]</span>
<span class="sd">        population_fn : str | xr.Dataset</span>
<span class="sd">            The population dataset in capita. Either provided as a dataset directly or</span>
<span class="sd">            as a string referring to an entry in the data catalog.</span>
<span class="sd">        domestic_fn_original_res : Optional[float], optional</span>
<span class="sd">            The original resolution of the domestic dataset, by default None to skip</span>
<span class="sd">            upscaling before downsampling with population.</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing domestic demand maps.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>
        <span class="c1"># Set flag for cyclic data</span>
        <span class="n">_cyclic</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Read data</span>
        <span class="n">domestic_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">domestic_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;domestic_gross&quot;</span><span class="p">,</span> <span class="s2">&quot;domestic_net&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="c1"># Increase the buffer if original resolution is provided</span>
        <span class="k">if</span> <span class="n">domestic_fn_original_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">buffer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">domestic_fn_original_res</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">domestic_raw</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">domestic_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">domestic_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;domestic_gross&quot;</span><span class="p">,</span> <span class="s2">&quot;domestic_net&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="c1"># Check if data is time dependent</span>
        <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">domestic_raw</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="c1"># Check that this is indeed cyclic data</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">domestic_raw</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">365</span><span class="p">,</span> <span class="mi">366</span><span class="p">]:</span>
                <span class="n">_cyclic</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">domestic_raw</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">domestic_raw</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The provided domestic demand data is cyclic but the time &quot;</span>
                    <span class="s2">&quot;dimension does not match the expected length of 12, 365 or 366.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Get population data</span>
        <span class="n">pop_raw</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">population_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pop_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">population_fn</span><span class="p">,</span>
                <span class="n">bbox</span><span class="o">=</span><span class="n">domestic_raw</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Compute domestic demand</span>
        <span class="n">domestic</span><span class="p">,</span> <span class="n">pop</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">domestic</span><span class="p">(</span>
            <span class="n">domestic_raw</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">popu</span><span class="o">=</span><span class="n">pop_raw</span><span class="p">,</span>
            <span class="n">original_res</span><span class="o">=</span><span class="n">domestic_fn_original_res</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Add to grid</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">domestic</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">domestic</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">population_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;meta_population&quot;</span><span class="p">)</span>

        <span class="c1"># Update toml</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.water_demand.domestic__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;cyclic&quot;</span> <span class="k">if</span> <span class="n">_cyclic</span> <span class="k">else</span> <span class="s2">&quot;static&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">domestic</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">,</span> <span class="n">data_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_domestic_demand_from_population">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_domestic_demand_from_population.html#hydromt_wflow.WflowSbmModel.setup_domestic_demand_from_population">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_domestic_demand_from_population</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">population_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">domestic_gross_per_capita</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">domestic_net_per_capita</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;domestic__gross_water_demand_volume_flux&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_domestic_gross&quot;</span><span class="p">,</span>
            <span class="s2">&quot;domestic__net_water_demand_volume_flux&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_domestic_net&quot;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare domestic water demand maps from statistics per capita.</span>

<span class="sd">        Gross and net demands per capita can be provide as cyclic (list) or non-cyclic</span>
<span class="sd">        (constant). The statistics are then multiplied by the population dataset to</span>
<span class="sd">        derive the gross and net domestic demand.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **demand_domestic_gross**: gross domestic water demand [mm/day]</span>
<span class="sd">        * **demand_domestic_net**: net domestic water demand [mm/day]</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_basemaps`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        population_fn : str | xr.Dataset</span>
<span class="sd">            The (gridded) population dataset in capita. Either provided as a dataset</span>
<span class="sd">            directly or as a string referring to an entry in the data catalog.</span>
<span class="sd">        domestic_gross_per_capita : float | list[float]</span>
<span class="sd">            The gross domestic water demand per capita [m3/day]. If cyclic, provide a</span>
<span class="sd">            list with 12 values for monthly data or 365/366 values for daily data.</span>
<span class="sd">        domestic_net_per_capita : float | list[float] | None</span>
<span class="sd">            The net domestic water demand per capita [m3/day]. If cyclic, provide a</span>
<span class="sd">            list with 12 values for monthly data or 365/366 values for daily data. If</span>
<span class="sd">            not provided, the gross demand will be used as net demand.</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing domestic demand maps based on population.&quot;</span><span class="p">)</span>

        <span class="c1"># Set flag for cyclic data</span>
        <span class="n">_cyclic</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>

        <span class="c1"># Check if data is time dependent</span>
        <span class="n">time_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">domestic_gross_per_capita</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">time_length</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">365</span><span class="p">,</span> <span class="mi">366</span><span class="p">]:</span>
            <span class="n">_cyclic</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">time_length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The provided domestic demand data is cyclic but the length &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">time_length</span><span class="si">}</span><span class="s2">)does not match the expected length of 12, 365 or 366.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">domestic_net_per_capita</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">domestic_net_per_capita</span> <span class="o">=</span> <span class="n">domestic_gross_per_capita</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Net domestic demand not provided, using gross demand.&quot;</span><span class="p">)</span>

        <span class="c1"># Get population data</span>
        <span class="n">popu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">population_fn</span><span class="p">,</span>
            <span class="n">bbox</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Compute domestic demand</span>
        <span class="n">domestic</span><span class="p">,</span> <span class="n">popu_scaled</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">domestic_from_population</span><span class="p">(</span>
            <span class="n">popu</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">gross_per_capita</span><span class="o">=</span><span class="n">domestic_gross_per_capita</span><span class="p">,</span>
            <span class="n">net_per_capita</span><span class="o">=</span><span class="n">domestic_net_per_capita</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Add to grid</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">domestic</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">domestic</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">population_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">popu_scaled</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;meta_population&quot;</span><span class="p">)</span>

        <span class="c1"># Update toml</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.water_demand.domestic__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;cyclic&quot;</span> <span class="k">if</span> <span class="n">_cyclic</span> <span class="k">else</span> <span class="s2">&quot;static&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">domestic</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">,</span> <span class="n">data_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_other_demand">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_other_demand.html#hydromt_wflow.WflowSbmModel.setup_other_demand">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_other_demand</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">demand_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;industry_gross&quot;</span><span class="p">,</span>
            <span class="s2">&quot;industry_net&quot;</span><span class="p">,</span>
            <span class="s2">&quot;livestock_gross&quot;</span><span class="p">,</span>
            <span class="s2">&quot;livestock_net&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">resampling_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;average&quot;</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;industry__gross_water_demand_volume_flux&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_industry_gross&quot;</span><span class="p">,</span>
            <span class="s2">&quot;industry__net_water_demand_volume_flux&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_industry_net&quot;</span><span class="p">,</span>
            <span class="s2">&quot;livestock__gross_water_demand_volume_flux&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_livestock_gross&quot;</span><span class="p">,</span>
            <span class="s2">&quot;livestock__net_water_demand_volume_flux&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_livestock_net&quot;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create water demand maps from other sources (e.g. industry, livestock).</span>

<span class="sd">        These maps are created from a supplied dataset that either contains one</span>
<span class="sd">        or all of the following variables:</span>
<span class="sd">        - `Industrial` water demand</span>
<span class="sd">        - `Livestock` water demand</span>
<span class="sd">        - `Domestic` water demand (without population downsampling)</span>

<span class="sd">        For each of these datasets/ variables a gross and a netto water demand</span>
<span class="sd">        should be provided. They can either be provided cyclic or non-cyclic. The</span>
<span class="sd">        maps are then resampled to the model resolution using the provided</span>
<span class="sd">        `resampling_method`.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **{var}_gross**: gross water demand [mm/day]</span>
<span class="sd">        * **{var}_net**: net water demand [mm/day]</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_basemaps`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        demand_fn : str | dict[str, dict[str, Any]], xr.Dataset]</span>
<span class="sd">            The water demand dataset. This can either be the dataset directly</span>
<span class="sd">            (xr.Dataset), a string referring to an entry in the data catalog or</span>
<span class="sd">            a dictionary containing the name of the dataset (keyword: `source`) and</span>
<span class="sd">            any optional keyword arguments (e.g. `version`). The data can be cyclic</span>
<span class="sd">            (with a `time` dimension) or non-cyclic. Allowed cyclic data can be monthly</span>
<span class="sd">            (12) or dayofyear (365 or 366).</span>

<span class="sd">            * Required variables: variables listed in `variables` in [mm/day].</span>
<span class="sd">        variables : list, optional</span>
<span class="sd">            The variables to be processed. Supported variables are [&#39;domestic_gross&#39;,</span>
<span class="sd">            &#39;domestic_net&#39;, &#39;industry_gross&#39;, &#39;industry_net&#39;, &#39;livestock_gross&#39;,</span>
<span class="sd">            &#39;livestock_net&#39;]. By default gross and net demand for industry and livestock</span>
<span class="sd">            are processed.</span>
<span class="sd">        resampling_method : str, optional</span>
<span class="sd">            Resampling method for the demand maps, by default &quot;average&quot;</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Preparing water demand maps for </span><span class="si">{</span><span class="n">variables</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="c1"># Set flag for cyclic data</span>
        <span class="n">_cyclic</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">output_names</span><span class="p">)</span>

        <span class="c1"># Selecting data</span>
        <span class="n">demand_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">demand_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;time&quot;</span> <span class="ow">in</span> <span class="n">demand_raw</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
            <span class="c1"># Check that this is indeed cyclic data</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">demand_raw</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">365</span><span class="p">,</span> <span class="mi">366</span><span class="p">]:</span>
                <span class="n">_cyclic</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">demand_raw</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">demand_raw</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The provided demand data is cyclic but the time dimension does &quot;</span>
                    <span class="s2">&quot;not match the expected length of 12, 365 or 366.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Create static water demand rasters</span>
        <span class="n">demand</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">other_demand</span><span class="p">(</span>
            <span class="n">demand_raw</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">ds_method</span><span class="o">=</span><span class="n">resampling_method</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">demand</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">demand</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>

        <span class="c1"># Update the settings toml</span>
        <span class="k">if</span> <span class="s2">&quot;domestic_gross&quot;</span> <span class="ow">in</span> <span class="n">demand</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.water_demand.domestic__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;industry_gross&quot;</span> <span class="ow">in</span> <span class="n">demand</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.water_demand.industry__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;livestock_gross&quot;</span> <span class="ow">in</span> <span class="n">demand</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.water_demand.livestock__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;cyclic&quot;</span> <span class="k">if</span> <span class="n">_cyclic</span> <span class="k">else</span> <span class="s2">&quot;static&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="n">demand</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">,</span> <span class="n">data_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_irrigation">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_irrigation.html#hydromt_wflow.WflowSbmModel.setup_irrigation">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_irrigation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">irrigated_area_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">irrigation_value</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">cropland_class</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">paddy_class</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">area_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.6</span><span class="p">,</span>
        <span class="n">lai_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">lulcmap_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;meta_landuse&quot;</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;irrigated_paddy_area__count&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span><span class="p">,</span>
            <span class="s2">&quot;irrigated_non_paddy_area__count&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span><span class="p">,</span>
            <span class="s2">&quot;irrigated_paddy__irrigation_trigger_flag&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_paddy_irrigation_trigger&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;irrigated_non_paddy__irrigation_trigger_flag&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_nonpaddy_irrigation_trigger&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add required information to simulate irrigation water demand from grid.</span>

<span class="sd">        THIS FUNCTION SHOULD BE RUN AFTER LANDUSE AND LAI MAPS ARE CREATED.</span>

<span class="sd">        The function requires data that contains information about the location of the</span>
<span class="sd">        irrigated areas (``irrigated_area_fn``). This, combined with the wflow landuse</span>
<span class="sd">        map that contains classes for cropland (``cropland_class``) and optionally for</span>
<span class="sd">        paddy (rice) (``paddy_class``), determines which locations are considered to be</span>
<span class="sd">        paddy irrigation, and which locations are considered to be non-paddy irrigation.</span>

<span class="sd">        Next, the irrigated area map is reprojected to the model resolution, where a</span>
<span class="sd">        threshold (``area_threshold``) determines when pixels are considered to be</span>
<span class="sd">        classified as irrigation or rainfed cells (both paddy and non-paddy). It adds</span>
<span class="sd">        the resulting maps to the input data.</span>

<span class="sd">        To determine when irrigation is allowed to occur, an irrigation trigger map is</span>
<span class="sd">        defined. This is a cyclic map, that defines (with a mask) when irrigation is</span>
<span class="sd">        expected to occur. This is done based on the Leaf Area Index (LAI), that is</span>
<span class="sd">        already present in the wflow model configuration. We follow the procedure</span>
<span class="sd">        described by Peano et al. (2019). They describe a threshold value based on the</span>
<span class="sd">        LAI variability to determine the growing season. This threshold is defined as</span>
<span class="sd">        20% (default value) of the LAI variability, but can be adjusted via the</span>
<span class="sd">        ``lai_threshold`` argument.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **demand_nonpaddy_irrigated_mask**: Irrigated (non-paddy) mask [-]</span>
<span class="sd">        * **demand_paddy_irrigated_mask**: Irrigated (paddy) mask [-]</span>
<span class="sd">        * **demand_paddy_irrigation_trigger**: Map with monthly values, indicating</span>
<span class="sd">          whether irrigation is allowed (1) or not (0) [-] for paddy areas</span>
<span class="sd">        * **demand_paddy_irrigation_trigger**: Map with monthly values, indicating</span>
<span class="sd">          whether irrigation is allowed (1) or not (0) [-] for non-paddy areas</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_lulcmaps` or equivalent</span>
<span class="sd">        * :py:meth:`~WflowSbmModel.setup_laimaps` or equivalent</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        irrigated_area_fn: str, Path, xarray.DataArray</span>
<span class="sd">            Name of the (gridded) dataset that contains the location of irrigated areas.</span>
<span class="sd">        irrigation_value: list</span>
<span class="sd">            List of values that are considered to be irrigated areas in</span>
<span class="sd">            ``irrigated_area_fn``.</span>
<span class="sd">        cropland_class: list</span>
<span class="sd">            List of values that are considered to be cropland in the wflow landuse data.</span>
<span class="sd">        paddy_class: int</span>
<span class="sd">            Class in the wflow landuse data that is considered as paddy or rice. Leave</span>
<span class="sd">            empty if not present (default).</span>
<span class="sd">        area_threshold: float</span>
<span class="sd">            Fractional area of a (wflow) pixel before it gets classified as an irrigated</span>
<span class="sd">            pixel, by default 0.6</span>
<span class="sd">        lai_threshold: float</span>
<span class="sd">            Value of LAI variability to be used to determine the irrigation trigger. By</span>
<span class="sd">            default 0.2.</span>
<span class="sd">        lulcmap_name: str</span>
<span class="sd">            Name of the landuse map layer in the wflow model staticmaps. By default</span>
<span class="sd">            &#39;meta_landuse&#39;. Please update if your landuse map has a different name</span>
<span class="sd">            (eg &#39;landuse_globcover&#39;).</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        workflows.demand.irrigation</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Peano, D., Materia, S., Collalti, A., Alessandri, A., Anav, A., Bombelli, A., &amp;</span>
<span class="sd">        Gualdi, S. (2019). Global variability of simulated and observed vegetation</span>
<span class="sd">        growing season. Journal of Geophysical Research: Biogeosciences, 124, 35693587.</span>
<span class="sd">        https://doi.org/10.1029/2018JG004881</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing irrigation maps.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lulcmap_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="c1"># update the internal mapping</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;landuse&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lulcmap_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Landuse map </span><span class="si">{</span><span class="n">lulcmap_name</span><span class="si">}</span><span class="s2"> not found in the model grid. Please &quot;</span>
                <span class="s2">&quot;provide a valid landuse map name or run setup_lulcmaps.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Extract irrigated area dataset</span>
        <span class="n">irrigated_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">irrigated_area_fn</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="mi">3</span>
        <span class="p">)</span>

        <span class="c1"># Get irrigation areas for paddy, non paddy and irrigation trigger</span>
        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">}</span>
        <span class="n">ds_irrigation</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">irrigation</span><span class="p">(</span>
            <span class="n">da_irrigation</span><span class="o">=</span><span class="n">irrigated_area</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">irrigation_value</span><span class="o">=</span><span class="n">irrigation_value</span><span class="p">,</span>
            <span class="n">cropland_class</span><span class="o">=</span><span class="n">cropland_class</span><span class="p">,</span>
            <span class="n">paddy_class</span><span class="o">=</span><span class="n">paddy_class</span><span class="p">,</span>
            <span class="n">area_threshold</span><span class="o">=</span><span class="n">area_threshold</span><span class="p">,</span>
            <span class="n">lai_threshold</span><span class="o">=</span><span class="n">lai_threshold</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Check if paddy and non paddy are present</span>
        <span class="n">cyclic_lai</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span> <span class="ow">in</span> <span class="n">ds_irrigation</span><span class="o">.</span><span class="n">data_vars</span>
            <span class="ow">and</span> <span class="n">ds_irrigation</span><span class="p">[</span><span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">mask_nodata</span><span class="p">()</span>
            <span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="o">.</span><span class="n">values</span>
            <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="c1"># Select the paddy variables in output_names</span>
            <span class="n">paddy_names</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">output_names</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;irrigated-paddy&quot;</span> <span class="ow">in</span> <span class="n">k</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">paddy_names</span><span class="p">)</span>
            <span class="n">ds_paddy</span> <span class="o">=</span> <span class="n">ds_irrigation</span><span class="p">[</span>
                <span class="p">[</span><span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_paddy_irrigation_trigger&quot;</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_paddy</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ds_paddy</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.water_demand.paddy__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span>
                <span class="p">),</span>
                <span class="s2">&quot;static&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;cyclic&quot;</span> <span class="k">if</span> <span class="n">cyclic_lai</span> <span class="k">else</span> <span class="s2">&quot;static&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;demand_paddy_irrigation_trigger&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_paddy_irrigation_trigger&quot;</span>
                <span class="p">),</span>
                <span class="n">data_type</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.water_demand.paddy__flag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">ds_irrigation</span><span class="p">[</span><span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">mask_nodata</span><span class="p">()</span>
            <span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="o">.</span><span class="n">values</span>
            <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="n">nonpaddy_names</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">output_names</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;irrigated-non-paddy&quot;</span> <span class="ow">in</span> <span class="n">k</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">nonpaddy_names</span><span class="p">)</span>
            <span class="n">ds_nonpaddy</span> <span class="o">=</span> <span class="n">ds_irrigation</span><span class="p">[</span>
                <span class="p">[</span><span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_nonpaddy_irrigation_trigger&quot;</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_nonpaddy</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ds_nonpaddy</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
            <span class="c1"># Update the config</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.water_demand.nonpaddy__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span>
                <span class="p">),</span>
                <span class="s2">&quot;static&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;cyclic&quot;</span> <span class="k">if</span> <span class="n">cyclic_lai</span> <span class="k">else</span> <span class="s2">&quot;static&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;demand_nonpaddy_irrigation_trigger&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;demand_nonpaddy_irrigation_trigger&quot;</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">data_type</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.water_demand.nonpaddy__flag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_irrigation_from_vector">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_irrigation_from_vector.html#hydromt_wflow.WflowSbmModel.setup_irrigation_from_vector">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_irrigation_from_vector</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">irrigated_area_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">cropland_class</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">paddy_class</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
        <span class="n">area_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.6</span><span class="p">,</span>
        <span class="n">lai_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">output_names</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;irrigated_paddy_area__count&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span><span class="p">,</span>
            <span class="s2">&quot;irrigated_non_paddy_area__count&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span><span class="p">,</span>
            <span class="s2">&quot;irrigated_paddy__irrigation_trigger_flag&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_paddy_irrigation_trigger&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
            <span class="s2">&quot;irrigated_non_paddy__irrigation_trigger_flag&quot;</span><span class="p">:</span> <span class="s2">&quot;demand_nonpaddy_irrigation_trigger&quot;</span><span class="p">,</span>  <span class="c1"># noqa: E501</span>
        <span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add required information to simulate irrigation water demand from vector.</span>

<span class="sd">        THIS FUNCTION SHOULD BE RUN AFTER LANDUSE AND LAI MAPS ARE CREATED.</span>

<span class="sd">        The function requires data that contains information about the location of the</span>
<span class="sd">        irrigated areas (``irrigated_area_fn``). This, combined with the wflow landuse</span>
<span class="sd">        map that contains classes for cropland (``cropland_class``) and optionally for</span>
<span class="sd">        paddy (rice) (``paddy_class``), determines which locations are considered to be</span>
<span class="sd">        paddy irrigation, and which locations are considered to be non-paddy irrigation.</span>

<span class="sd">        Next, the irrigated area geometries are rasterized, where a threshold</span>
<span class="sd">        (``area_threshold``) determines when pixels are considered to be</span>
<span class="sd">        classified as irrigation or rainfed cells (both paddy and non-paddy). It adds</span>
<span class="sd">        the resulting maps to the input data.</span>

<span class="sd">        To determine when irrigation is allowed to occur, an irrigation trigger map is</span>
<span class="sd">        defined. This is a cyclic map, that defines (with a mask) when irrigation is</span>
<span class="sd">        expected to occur. This is done based on the Leaf Area Index (LAI), that is</span>
<span class="sd">        already present in the wflow model configuration. We follow the procedure</span>
<span class="sd">        described by Peano et al. (2019). They describe a threshold value based on the</span>
<span class="sd">        LAI variability to determine the growing season. This threshold is defined as</span>
<span class="sd">        20% (default value) of the LAI variability, but can be adjusted via the</span>
<span class="sd">        ``lai_threshold`` argument.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **demand_paddy_irrigated_mask**: Irrigated (paddy) mask [-]</span>
<span class="sd">        * **demand_nonpaddy_irrigated_mask**: Irrigated (non-paddy) mask [-]</span>
<span class="sd">        * **demand_paddy_irrigation_trigger**: Map with monthly values, indicating</span>
<span class="sd">          whether irrigation is allowed (1) or not (0) [-] for paddy areas</span>
<span class="sd">        * **demand_nonpaddy_irrigation_trigger**: Map with monthly values, indicating</span>
<span class="sd">          whether irrigation is allowed (1) or not (0) [-] for non-paddy areas</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_lulcmaps` or equivalent</span>
<span class="sd">        * :py:meth:`~WflowSbmModel.setup_laimaps` or equivalent</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        irrigated_area_fn: str, Path, geopandas.GeoDataFrame</span>
<span class="sd">            Name of the (vector) dataset that contains the location of irrigated areas.</span>
<span class="sd">        cropland_class: list</span>
<span class="sd">            List of values that are considered to be cropland in the wflow landuse data.</span>
<span class="sd">        paddy_class: int</span>
<span class="sd">            Class in the wflow landuse data that is considered as paddy or rice. Leave</span>
<span class="sd">            empty if not present (default).</span>
<span class="sd">        area_threshold: float</span>
<span class="sd">            Fractional area of a (wflow) pixel before it gets classified as an irrigated</span>
<span class="sd">            pixel, by default 0.6</span>
<span class="sd">        lai_threshold: float</span>
<span class="sd">            Value of LAI variability to be used to determine the irrigation trigger. By</span>
<span class="sd">            default 0.2.</span>
<span class="sd">        output_names : dict, optional</span>
<span class="sd">            Dictionary with output names that will be used in the model netcdf input</span>
<span class="sd">            files. Users should provide the Wflow.jl variable name followed by the name</span>
<span class="sd">            in the netcdf file.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        workflows.demand.irrigation</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Peano, D., Materia, S., Collalti, A., Alessandri, A., Anav, A., Bombelli, A., &amp;</span>
<span class="sd">        Gualdi, S. (2019). Global variability of simulated and observed vegetation</span>
<span class="sd">        growing season. Journal of Geophysical Research: Biogeosciences, 124, 35693587.</span>
<span class="sd">        https://doi.org/10.1029/2018JG004881</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing irrigation maps.&quot;</span><span class="p">)</span>

        <span class="c1"># Extract irrigated area dataset</span>
        <span class="n">irrigated_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">irrigated_area_fn</span><span class="p">,</span>
            <span class="n">bbox</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
            <span class="n">predicate</span><span class="o">=</span><span class="s2">&quot;intersects&quot;</span><span class="p">,</span>
            <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># Ensure we have a copy to resolve SettingWithCopyWarning</span>

        <span class="c1"># Check if the geodataframe is empty</span>
        <span class="k">if</span> <span class="n">irrigated_area</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">irrigated_area</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No irrigated areas found in the provided geodataframe.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Get irrigation areas for paddy, non paddy and irrigation trigger</span>
        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">}</span>
        <span class="n">ds_irrigation</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">demand</span><span class="o">.</span><span class="n">irrigation_from_vector</span><span class="p">(</span>
            <span class="n">gdf_irrigation</span><span class="o">=</span><span class="n">irrigated_area</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">cropland_class</span><span class="o">=</span><span class="n">cropland_class</span><span class="p">,</span>
            <span class="n">paddy_class</span><span class="o">=</span><span class="n">paddy_class</span><span class="p">,</span>
            <span class="n">area_threshold</span><span class="o">=</span><span class="n">area_threshold</span><span class="p">,</span>
            <span class="n">lai_threshold</span><span class="o">=</span><span class="n">lai_threshold</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Check if paddy and non paddy are present</span>
        <span class="n">cyclic_lai</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;LAI&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span> <span class="ow">in</span> <span class="n">ds_irrigation</span><span class="o">.</span><span class="n">data_vars</span>
            <span class="ow">and</span> <span class="n">ds_irrigation</span><span class="p">[</span><span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">mask_nodata</span><span class="p">()</span>
            <span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="o">.</span><span class="n">values</span>
            <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="n">paddy_names</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">output_names</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;irrigated-paddy&quot;</span> <span class="ow">in</span> <span class="n">k</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">paddy_names</span><span class="p">)</span>
            <span class="n">ds_paddy</span> <span class="o">=</span> <span class="n">ds_irrigation</span><span class="p">[</span>
                <span class="p">[</span><span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_paddy_irrigation_trigger&quot;</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_paddy</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ds_paddy</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
            <span class="c1"># Update the config</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.water_demand.paddy__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_paddy_irrigated_mask&quot;</span>
                <span class="p">),</span>
                <span class="s2">&quot;static&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;cyclic&quot;</span> <span class="k">if</span> <span class="n">cyclic_lai</span> <span class="k">else</span> <span class="s2">&quot;static&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;demand_paddy_irrigation_trigger&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_paddy_irrigation_trigger&quot;</span>
                <span class="p">),</span>
                <span class="n">data_type</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.water_demand.paddy__flag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">ds_irrigation</span><span class="p">[</span><span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">mask_nodata</span><span class="p">()</span>
            <span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="o">.</span><span class="n">values</span>
            <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="n">nonpaddy_names</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">output_names</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;irrigated-non-paddy&quot;</span> <span class="ow">in</span> <span class="n">k</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_naming</span><span class="p">(</span><span class="n">nonpaddy_names</span><span class="p">)</span>
            <span class="n">ds_nonpaddy</span> <span class="o">=</span> <span class="n">ds_irrigation</span><span class="p">[</span>
                <span class="p">[</span><span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_nonpaddy_irrigation_trigger&quot;</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">rmdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds_nonpaddy</span><span class="o">.</span><span class="n">data_vars</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ds_nonpaddy</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">rmdict</span><span class="p">))</span>
            <span class="c1"># Update the config</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.water_demand.nonpaddy__flag&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span><span class="p">,</span> <span class="s2">&quot;demand_nonpaddy_irrigated_mask&quot;</span>
                <span class="p">),</span>
                <span class="s2">&quot;static&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;cyclic&quot;</span> <span class="k">if</span> <span class="n">cyclic_lai</span> <span class="k">else</span> <span class="s2">&quot;static&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;demand_nonpaddy_irrigation_trigger&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;demand_nonpaddy_irrigation_trigger&quot;</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">data_type</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.water_demand.nonpaddy__flag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_1dmodel_connection">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_1dmodel_connection.html#hydromt_wflow.WflowSbmModel.setup_1dmodel_connection">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_1dmodel_connection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">river1d_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">,</span>
        <span class="n">connection_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;subbasin_area&quot;</span><span class="p">,</span>
        <span class="n">area_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">30.0</span><span class="p">,</span>
        <span class="n">basin_buffer_cells</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">geom_snapping_tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
        <span class="n">add_tributaries</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">include_river_boundaries</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mapname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;1dmodel&quot;</span><span class="p">,</span>
        <span class="n">update_toml</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">toml_output</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;netcdf_scalar&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Connect wflow to a 1D model by deriving linked subcatch (and tributaries).</span>

<span class="sd">        There are two methods to connect models:</span>

<span class="sd">        - `subbasin_area`:</span>
<span class="sd">            creates subcatchments linked to the 1d river based</span>
<span class="sd">            on an area threshold (area_max) for the subbasin size. With this method,</span>
<span class="sd">            if a tributary is larger than the `area_max`, it will be connected to</span>
<span class="sd">            the 1d river directly.</span>
<span class="sd">        - `nodes`:</span>
<span class="sd">            subcatchments are derived based on the 1driver nodes (used as</span>
<span class="sd">            gauges locations). With this method, large tributaries can also be derived</span>
<span class="sd">            separately using the `add_tributaries` option and adding a `area_max`</span>
<span class="sd">            threshold for the tributaries.</span>

<span class="sd">        If `add_tributary` option is on, you can decide to include or exclude the</span>
<span class="sd">        upstream boundary of the 1d river as an additional tributary using the</span>
<span class="sd">        `include_river_boundaries` option.</span>

<span class="sd">        River edges or river nodes are snapped to the closest downstream wflow river</span>
<span class="sd">        cell using the :py:meth:`hydromt.flw.gauge_map` method.</span>

<span class="sd">        Optionally, the toml file can also be updated to save lateral.river.inwater to</span>
<span class="sd">        save all river inflows for the subcatchments and lateral.river.q_av for the</span>
<span class="sd">        tributaries using</span>
<span class="sd">        :py:meth:`hydromt_wflow.wflow_base.setup_config_output_timeseries`.</span>

<span class="sd">        Note that if the method is `subbasin_area`, only connecting one continuous</span>
<span class="sd">        river1d is supported. To connect several riv1d networks to the same wflow model,</span>
<span class="sd">        the method can be run several times.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **subcatchment_{mapname}** map/geom:  connection subbasins between</span>
<span class="sd">          wflow and the 1D model.</span>
<span class="sd">        * **subcatchment_river_{mapname}** map/geom:  connection subbasins between</span>
<span class="sd">          wflow and the 1D model for river cells only.</span>
<span class="sd">        * **gauges_{mapname}** map/geom, optional: outlets of the tributaries</span>
<span class="sd">          flowing into the 1D model.</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_rivers`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        river1d_fn : str, Path, gpd.GeoDataFrame</span>
<span class="sd">            GeodataFrame with the 1D model river network and nodes where to derive</span>
<span class="sd">            subbasins for connection_method **nodes**.</span>
<span class="sd">        connection_method : str, default subbasin_area</span>
<span class="sd">            Method to connect wflow to the 1D model. Available methods are {</span>
<span class="sd">                &#39;subbasin_area&#39;, &#39;nodes&#39;}.</span>
<span class="sd">        area_max : float, default 10.0</span>
<span class="sd">            Maximum area [km2] of the subbasins to connect to the 1D model in km2 with</span>
<span class="sd">            connection_method **subbasin_area** or **nodes** with add_tributaries</span>
<span class="sd">            set to True.</span>
<span class="sd">        basin_buffer_cells : int, default 0</span>
<span class="sd">            Number of cells to use when clipping the river1d geometry to the basin</span>
<span class="sd">            extent. This can be used to not include river geometries near the basin</span>
<span class="sd">            border.</span>
<span class="sd">        geom_snapping_tolerance : float, default 0.1</span>
<span class="sd">            Distance used to determine whether to snap parts of the river1d geometry</span>
<span class="sd">            that are close to each other. This can be useful if some of the tributaries</span>
<span class="sd">            of the 1D river are not perfectly connected to the main river.</span>
<span class="sd">        add_tributaries : bool, default True</span>
<span class="sd">            If True, derive tributaries for the subbasins larger than area_max. Always</span>
<span class="sd">            True for **subbasin_area** method.</span>
<span class="sd">        include_river_boundaries : bool, default True</span>
<span class="sd">            If True, include the upstream boundary(ies) of the 1d river as an</span>
<span class="sd">            additional tributary(ies).</span>
<span class="sd">        mapname : str, default 1dmodel</span>
<span class="sd">            Name of the map to save the subcatchments and tributaries in the wflow model</span>
<span class="sd">            staticmaps and geoms (subcatchment_{mapname}).</span>
<span class="sd">        update_toml : bool, default True</span>
<span class="sd">            If True, updates the wflow configuration file to save the required outputs</span>
<span class="sd">            for the 1D model.</span>
<span class="sd">        toml_output : str, optional</span>
<span class="sd">            One of [&#39;csv&#39;, &#39;netcdf_scalar&#39;, None] to update [output.csv] or</span>
<span class="sd">            [output.netcdf_scalar] section of wflow toml file or do nothing. By</span>
<span class="sd">            default, &#39;netcdf_scalar&#39;.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments passed to the snapping method</span>
<span class="sd">            hydromt.flw.gauge_map. See its documentation for more information.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hydromt.flw.gauge_map</span>
<span class="sd">        hydromt_wflow.workflows.wflow_1dmodel_connection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check connection method values</span>
        <span class="k">if</span> <span class="n">connection_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;subbasin_area&quot;</span><span class="p">,</span> <span class="s2">&quot;nodes&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown connection method </span><span class="si">{</span><span class="n">connection_method</span><span class="si">}</span><span class="s2">,&quot;</span>
                <span class="s2">&quot;select from [&#39;subbasin_area&#39;, &#39;nodes&#39;]&quot;</span>
            <span class="p">)</span>
        <span class="c1"># read 1d model river network</span>
        <span class="n">gdf_riv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
            <span class="n">river1d_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># derive subcatchments and tributaries</span>
        <span class="n">inv_rename</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">}</span>
        <span class="n">ds_out</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">wflow_1dmodel_connection</span><span class="p">(</span>
            <span class="n">gdf_riv</span><span class="p">,</span>
            <span class="n">ds_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">inv_rename</span><span class="p">),</span>
            <span class="n">connection_method</span><span class="o">=</span><span class="n">connection_method</span><span class="p">,</span>
            <span class="n">area_max</span><span class="o">=</span><span class="n">area_max</span><span class="p">,</span>
            <span class="n">basin_buffer_cells</span><span class="o">=</span><span class="n">basin_buffer_cells</span><span class="p">,</span>
            <span class="n">geom_snapping_tolerance</span><span class="o">=</span><span class="n">geom_snapping_tolerance</span><span class="p">,</span>
            <span class="n">add_tributaries</span><span class="o">=</span><span class="n">add_tributaries</span><span class="p">,</span>
            <span class="n">include_river_boundaries</span><span class="o">=</span><span class="n">include_river_boundaries</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Derive tributary gauge map</span>
        <span class="k">if</span> <span class="s2">&quot;gauges&quot;</span> <span class="ow">in</span> <span class="n">ds_out</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;gauges&quot;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;gauges_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># Derive the gauges staticgeoms</span>
            <span class="n">gdf_tributary</span> <span class="o">=</span> <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;gauges&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">vectorize</span><span class="p">()</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">planar_operation_in_utm</span><span class="p">(</span>
                <span class="n">gdf_tributary</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="n">geom</span><span class="o">.</span><span class="n">centroid</span>
            <span class="p">)</span>
            <span class="n">gdf_tributary</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">centroid</span>
            <span class="n">gdf_tributary</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_tributary</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;gauges&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">gdf_tributary</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;gauges_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Add a check that all gauges are on the river</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">gdf_tributary</span><span class="p">)</span>
                <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">nodata</span>
            <span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">river_upa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;river_upa&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
                <span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Not all tributary gauges are on the river network and river &quot;</span>
                    <span class="s2">&quot;discharge cannot be saved. You should use a higher threshold &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for the subbasin area than </span><span class="si">{</span><span class="n">area_max</span><span class="si">}</span><span class="s2"> to match better the &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;wflow river in your model </span><span class="si">{</span><span class="n">river_upa</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="n">all_gauges_on_river</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_gauges_on_river</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Update toml</span>
            <span class="k">if</span> <span class="n">update_toml</span> <span class="ow">and</span> <span class="n">all_gauges_on_river</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setup_config_output_timeseries</span><span class="p">(</span>
                    <span class="n">mapname</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;gauges_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">toml_output</span><span class="o">=</span><span class="n">toml_output</span><span class="p">,</span>
                    <span class="n">header</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">],</span>
                    <span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;river_water__volume_flow_rate&quot;</span><span class="p">],</span>
                    <span class="n">reducer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># Derive subcatchment map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch&quot;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;subcatchment_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">gdf_subcatch</span> <span class="o">=</span> <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">vectorize</span><span class="p">()</span>
        <span class="n">gdf_subcatch</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_subcatch</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">gdf_subcatch</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;subcatchment_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Subcatchment map for river cells only (to be able to save river outputs</span>
        <span class="c1"># in wflow)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch_riv&quot;</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;subcatchment_riv_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">gdf_subcatch_riv</span> <span class="o">=</span> <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch_riv&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">vectorize</span><span class="p">()</span>
        <span class="n">gdf_subcatch_riv</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_subcatch_riv</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">ds_out</span><span class="p">[</span><span class="s2">&quot;subcatch&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">gdf_subcatch_riv</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;subcatchment_riv_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Update toml</span>
        <span class="k">if</span> <span class="n">update_toml</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setup_config_output_timeseries</span><span class="p">(</span>
                <span class="n">mapname</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;subcatchment_river_</span><span class="si">{</span><span class="n">mapname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">toml_output</span><span class="o">=</span><span class="n">toml_output</span><span class="p">,</span>
                <span class="n">header</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Qlat&quot;</span><span class="p">],</span>
                <span class="n">param</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;river_water__lateral_inflow_volume_flow_rate&quot;</span><span class="p">],</span>
                <span class="n">reducer</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sum&quot;</span><span class="p">],</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_precip_forcing">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_precip_forcing.html#hydromt_wflow.WflowSbmModel.setup_precip_forcing">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_precip_forcing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">precip_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">precip_clim_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate gridded precipitation forcing at model resolution.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **precip**: precipitation [mm]</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_basemaps`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        precip_fn : str, xarray.DataArray</span>
<span class="sd">            Precipitation RasterDataset source.</span>

<span class="sd">            * Required variable: &#39;precip&#39; [mm]</span>

<span class="sd">            * Required dimension: &#39;time&#39;  [timestamp]</span>
<span class="sd">        precip_clim_fn : str, xarray.DataArray, optional</span>
<span class="sd">            High resolution climatology precipitation RasterDataset source to correct</span>
<span class="sd">            precipitation.</span>

<span class="sd">            * Required variable: &#39;precip&#39; [mm]</span>

<span class="sd">            * Required dimension: &#39;time&#39;  [cyclic month]</span>
<span class="sd">        chunksize: int, optional</span>
<span class="sd">            Chunksize on time dimension for processing data (not for saving to disk!).</span>
<span class="sd">            If None the data chunksize is used, this can however be optimized for</span>
<span class="sd">            large/small catchments. By default None.</span>
<span class="sd">        **kwargs : dict, optional</span>
<span class="sd">            Additional arguments passed to the forcing function.</span>
<span class="sd">            See hydromt.model.processes.meteo.precip for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;time.starttime&quot;</span><span class="p">)</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;time.endtime&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;time.timestepsecs&quot;</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="n">precip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">precip_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">time_range</span><span class="o">=</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">),</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;precip&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">precip</span> <span class="o">=</span> <span class="n">precip</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">chunksize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">precip</span> <span class="o">=</span> <span class="n">precip</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">chunksize</span><span class="p">})</span>

        <span class="n">clim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">precip_clim_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">clim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">precip_clim_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="n">precip</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">box</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;precip&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">clim</span> <span class="o">=</span> <span class="n">clim</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="n">precip_out</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">processes</span><span class="o">.</span><span class="n">meteo</span><span class="o">.</span><span class="n">precip</span><span class="p">(</span>
            <span class="n">precip</span><span class="o">=</span><span class="n">precip</span><span class="p">,</span>
            <span class="n">da_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
            <span class="n">clim</span><span class="o">=</span><span class="n">clim</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">resample_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Update meta attributes (used for default output filename later)</span>
        <span class="n">precip_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;precip_fn&quot;</span><span class="p">:</span> <span class="n">precip_fn</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">precip_clim_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">precip_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;precip_clim_fn&quot;</span><span class="p">:</span> <span class="n">precip_clim_fn</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">precip_out</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;precip&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;precip&quot;</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;forcing&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_precip_from_point_timeseries">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_precip_from_point_timeseries.html#hydromt_wflow.WflowSbmModel.setup_precip_from_point_timeseries">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_precip_from_point_timeseries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">precip_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">interp_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
        <span class="n">precip_stations_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">index_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">buffer</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e5</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate gridded precipitation from point timeseries (requires wradlib).</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **precip**: precipitation [mm]</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_basemaps`</span>

<span class="sd">        Supported interpolation methods:</span>

<span class="sd">        * uniform: Applies spatially uniform precipitation to the model. \</span>
<span class="sd">        Only works when `precip_fn` contains a single timeseries.</span>
<span class="sd">        * nearest: Nearest-neighbour interpolation, also works with a single station.</span>
<span class="sd">        * idw: Inverse-distance weighting using 1 / distance ** p.</span>
<span class="sd">        * linear: Linear interpolation using scipy.interpolate.LinearNDInterpolator, \</span>
<span class="sd">        may result in missing values when station coverage is limited.</span>
<span class="sd">        * ordinarykriging: Interpolate using Ordinary Kriging, see wradlib \</span>
<span class="sd">        documentation for a full explanation: `wradlib.ipol.OrdinaryKriging &lt;https://docs.wradlib.org/en/latest/generated/wradlib.ipol.OrdinaryKriging.html&gt;`.</span>
<span class="sd">        * externaldriftkriging: Kriging interpolation including an external drift, \</span>
<span class="sd">        see wradlib documentation for a full explanation: \</span>
<span class="sd">        `wradlib.ipol.ExternalDriftKriging &lt;https://docs.wradlib.org/en/latest/generated/wradlib.ipol.ExternalDriftKriging.html&gt;`.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        precip_fn : str, pd.DataFrame, xr.Dataset</span>
<span class="sd">            Precipitation source as DataFrame or GeoDataset. \</span>
<span class="sd">            - DataFrame: the index column should contain time and the other \</span>
<span class="sd">            columns should correspond to the name or ID values of the stations \</span>
<span class="sd">            in `precip_stations_fn`.</span>
<span class="sd">            - GeoDataset: the dataset should contain the variable &#39;precip&#39; and \</span>
<span class="sd">            the dimensions &#39;time&#39; and &#39;index&#39;.</span>

<span class="sd">            * Required variable: &#39;time&#39;, &#39;precip&#39; [mm]</span>
<span class="sd">        interp_type : str</span>
<span class="sd">            Interpolation method. Options: &quot;nearest&quot;, &quot;idw&quot;, &quot;linear&quot;, \</span>
<span class="sd">            &quot;ordinarykriging&quot;, &quot;externaldriftkriging&quot;.</span>
<span class="sd">        precip_stations_fn : str, gpd.GeoDataFrame, optional</span>
<span class="sd">            Source for the locations of the stations as points: (x, y) or (lat, lon). \</span>
<span class="sd">            Only required if precip_fn is of type DataFrame.</span>
<span class="sd">        index_col : str, optional</span>
<span class="sd">            Column in precip_stations_fn to use for station ID values, by default None.</span>
<span class="sd">        buffer: float, optional</span>
<span class="sd">            Buffer around the basins in metres to determine which</span>
<span class="sd">            stations to include. Set to 100 km (1e5 metres) by default.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments passed to the interpolation function. \</span>
<span class="sd">            Supported arguments depend on the interpolation type:</span>
<span class="sd">            - nnearest: Maximum number of neighbors for interpolation (default: 4).</span>
<span class="sd">            - p: Power parameter for IDW interpolation (default: 2).</span>
<span class="sd">            - remove_missing: Mask NaN values in the input data (default: False).</span>
<span class="sd">            - cov: Covariance model for Kriging (default: &#39;1.0 Exp(10000.)&#39;).</span>
<span class="sd">            - src_drift: External drift values at source points (stations).</span>
<span class="sd">            - trg_drift: External drift values at target points (grid).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hydromt_wflow.workflows.forcing.spatial_interpolation</span>
<span class="sd">        `wradlib.ipol.interpolate &lt;https://docs.wradlib.org/en/latest/ipol.html#wradlib.ipol.interpolate&gt;`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;time.starttime&quot;</span><span class="p">)</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;time.endtime&quot;</span><span class="p">)</span>
        <span class="n">timestep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;time.timestepsecs&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="c1"># Check data type of precip_fn if it is provided through the data catalog</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">precip_fn</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">precip_fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="p">:</span>
            <span class="n">_data_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="p">[</span><span class="n">precip_fn</span><span class="p">]</span><span class="o">.</span><span class="n">data_type</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_data_type</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Read the precipitation timeseries</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">precip_fn</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_data_type</span> <span class="o">==</span> <span class="s2">&quot;GeoDataset&quot;</span><span class="p">:</span>
            <span class="n">da_precip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataset</span><span class="p">(</span>
                <span class="n">precip_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;precip&quot;</span><span class="p">],</span>
                <span class="n">time_range</span><span class="o">=</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">),</span>
                <span class="n">single_var_as_array</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Read timeseries</span>
            <span class="n">df_precip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_dataframe</span><span class="p">(</span>
                <span class="n">precip_fn</span><span class="p">,</span>
                <span class="n">time_range</span><span class="o">=</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="c1"># Get locs</span>
            <span class="k">if</span> <span class="n">interp_type</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
                <span class="c1"># Use basin centroid as &#39;station&#39; for uniform case</span>
                <span class="n">gdf_stations</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">geometry</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">basins</span><span class="o">.</span><span class="n">union_all</span><span class="p">()</span><span class="o">.</span><span class="n">centroid</span><span class="p">],</span>
                    <span class="n">index</span><span class="o">=</span><span class="n">df_precip</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                    <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">interp_type</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span>
                <span class="k">if</span> <span class="n">df_precip</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                        Data source (</span><span class="si">{</span><span class="n">precip_fn</span><span class="si">}</span><span class="s2">) should contain</span>
<span class="s2">                        a single timeseries, not </span><span class="si">{</span><span class="n">df_precip</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;&quot;&quot;</span>
                    <span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Uniform interpolation is applied using method &#39;nearest&#39;.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">precip_stations_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Using a DataFrame as precipitation source requires that station &quot;</span>
                    <span class="s2">&quot;locations are provided separately through precip_station_fn.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Load the stations and their coordinates</span>
                <span class="n">gdf_stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_geodataframe</span><span class="p">(</span>
                    <span class="n">precip_stations_fn</span><span class="p">,</span>
                    <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basins</span><span class="p">,</span>
                    <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
                    <span class="c1"># assert_gtype= &quot;Point&quot;, hydromt#1243</span>
                    <span class="n">handle_nodata</span><span class="o">=</span><span class="n">NoDataStrategy</span><span class="o">.</span><span class="n">IGNORE</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># Use station ids from gdf_stations when reading the DataFrame</span>
                <span class="k">if</span> <span class="n">index_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">gdf_stations</span> <span class="o">=</span> <span class="n">gdf_stations</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">index_col</span><span class="p">)</span>

            <span class="c1"># Index is required to contruct GeoDataArray</span>
            <span class="k">if</span> <span class="n">gdf_stations</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gdf_stations</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;stations&quot;</span>

            <span class="c1"># Convert to geodataset</span>
            <span class="n">da_precip</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">GeoDataArray</span><span class="o">.</span><span class="n">from_gdf</span><span class="p">(</span>
                <span class="n">gdf</span><span class="o">=</span><span class="n">gdf_stations</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">df_precip</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;precip&quot;</span><span class="p">,</span>
                <span class="n">index_dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">gdf_stations</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
                <span class="n">keep_cols</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">merge_index</span><span class="o">=</span><span class="s2">&quot;gdf&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Calling interpolation workflow</span>
        <span class="n">precip</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">spatial_interpolation</span><span class="p">(</span>
            <span class="n">forcing</span><span class="o">=</span><span class="n">da_precip</span><span class="p">,</span>
            <span class="n">interp_type</span><span class="o">=</span><span class="n">interp_type</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">mask_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">],</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Use precip workflow to create the forcing file</span>
        <span class="n">precip_out</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">processes</span><span class="o">.</span><span class="n">meteo</span><span class="o">.</span><span class="n">precip</span><span class="p">(</span>
            <span class="n">precip</span><span class="o">=</span><span class="n">precip</span><span class="p">,</span>
            <span class="n">da_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
            <span class="n">clim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">resample_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Turn precip_fn into a string if needed</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">precip_fn</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">precip_fn_str</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">precip_fn</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;unnamed_DataFrame&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">precip_fn</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="n">precip_fn_str</span> <span class="o">=</span> <span class="n">precip_fn</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;unnamed_Dataset&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">precip_fn_str</span> <span class="o">=</span> <span class="n">precip_fn</span>

        <span class="c1"># Update meta attributes (used for default output filename later)</span>
        <span class="n">precip_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;precip_fn&quot;</span><span class="p">:</span> <span class="n">precip_fn_str</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">precip_out</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;precip&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;precip&quot;</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;forcing&quot;</span><span class="p">)</span>

        <span class="c1"># Add to geoms</span>
        <span class="n">gdf_stations</span> <span class="o">=</span> <span class="n">da_precip</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">to_gdf</span><span class="p">()</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoms</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">gdf_stations</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;stations_precipitation&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_temp_pet_forcing">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_temp_pet_forcing.html#hydromt_wflow.WflowSbmModel.setup_temp_pet_forcing">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_temp_pet_forcing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">temp_pet_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
        <span class="n">pet_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;debruin&quot;</span><span class="p">,</span>
        <span class="n">press_correction</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">temp_correction</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wind_correction</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">wind_altitude</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">reproj_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nearest_index&quot;</span><span class="p">,</span>
        <span class="n">fillna_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dem_forcing_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skip_pet</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate gridded temperature and reference evapotranspiration forcing.</span>

<span class="sd">        If `temp_correction` is True, the temperature will be reprojected and then</span>
<span class="sd">        downscaled to model resolution using the elevation lapse rate. For better</span>
<span class="sd">        accuracy, you can provide the elevation grid of the climate data in</span>
<span class="sd">        `dem_forcing_fn`. If not present, the upscaled elevation grid of the wflow model</span>
<span class="sd">        is used (&#39;land_elevation&#39;).</span>

<span class="sd">        To compute PET (`skip_pet` is False), several methods are available. Before</span>
<span class="sd">        computation, both the temperature and pressure can be downscaled. Wind speed</span>
<span class="sd">        should be given at 2m altitude and can be corrected if `wind_correction` is True</span>
<span class="sd">        and the wind data altitude is provided in `wind_altitude` [m].</span>
<span class="sd">        Several methods to compute pet are available: {&#39;debruin&#39;, &#39;makkink&#39;,</span>
<span class="sd">        &#39;penman-monteith_rh_simple&#39;, &#39;penman-monteith_tdew&#39;}.</span>

<span class="sd">        Depending on the methods, `temp_pet_fn` should contain temperature &#39;temp&#39; [C],</span>
<span class="sd">        pressure &#39;press_msl&#39; [hPa], incoming shortwave radiation &#39;kin&#39; [W/m2], outgoing</span>
<span class="sd">        shortwave radiation &#39;kout&#39; [W/m2], wind speed &#39;wind&#39; [m/s], relative humidity</span>
<span class="sd">        &#39;rh&#39; [%], dew point temperature &#39;temp_dew&#39; [C], wind speed either total &#39;wind&#39;</span>
<span class="sd">        or the U- &#39;wind10_u&#39; [m/s] and V- &#39;wind10_v&#39; components [m/s].</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **pet**: reference evapotranspiration [mm]</span>
<span class="sd">        * **temp**: temperature [C]</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_basemaps`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        temp_pet_fn : str, xarray.Dataset</span>
<span class="sd">            Name or path of RasterDataset source with variables to calculate temperature</span>
<span class="sd">            and reference evapotranspiration.</span>

<span class="sd">            * Required variable for temperature: &#39;temp&#39; [C]</span>

<span class="sd">            * Required variables for De Bruin reference evapotranspiration: \</span>
<span class="sd">&#39;temp&#39; [C], &#39;press_msl&#39; [hPa], &#39;kin&#39; [W/m2], &#39;kout&#39; [W/m2]</span>

<span class="sd">            * Required variables for Makkink reference evapotranspiration: \</span>
<span class="sd">&#39;temp&#39; [C], &#39;press_msl&#39; [hPa], &#39;kin&#39;[W/m2]</span>

<span class="sd">            * Required variables for daily Penman-Monteith \</span>
<span class="sd">reference evapotranspiration: \</span>
<span class="sd">either {&#39;temp&#39; [C], &#39;temp_min&#39; [C], &#39;temp_max&#39; [C], &#39;wind&#39; [m/s], &#39;rh&#39; [%], &#39;kin&#39; \</span>
<span class="sd">[W/m2]} for &#39;penman-monteith_rh_simple&#39; or {&#39;temp&#39; [C], &#39;temp_min&#39; [C], &#39;temp_max&#39; \</span>
<span class="sd">[C], &#39;temp_dew&#39; [C], &#39;wind&#39; [m/s], &#39;kin&#39; [W/m2], &#39;press_msl&#39; [hPa], &#39;wind10_u&#39; [m/s],\</span>
<span class="sd">&quot;wind10_v&quot; [m/s]} for &#39;penman-monteith_tdew&#39; (these are the variables available in ERA5)</span>
<span class="sd">        pet_method : {&#39;debruin&#39;, &#39;makkink&#39;, &#39;penman-monteith_rh_simple&#39;, \</span>
<span class="sd">&#39;penman-monteith_tdew&#39;}, optional</span>
<span class="sd">            Reference evapotranspiration method, by default &#39;debruin&#39;.</span>
<span class="sd">            If penman-monteith is used, requires the installation of the pyet package.</span>
<span class="sd">        press_correction, temp_correction : bool, optional</span>
<span class="sd">            If True pressure, temperature are corrected using elevation lapse rate,</span>
<span class="sd">            by default False.</span>
<span class="sd">        dem_forcing_fn : str, default None</span>
<span class="sd">            Elevation data source with coverage of entire meteorological forcing domain.</span>
<span class="sd">            If temp_correction is True and dem_forcing_fn is provided this is used in</span>
<span class="sd">            combination with elevation at model resolution to correct the temperature.</span>

<span class="sd">            * Required variable: &#39;elevtn&#39; [m+REF]</span>
<span class="sd">        wind_correction : bool, optional</span>
<span class="sd">            If True wind speed is corrected to wind at 2m altitude using</span>
<span class="sd">            ``wind_altitude``. By default True.</span>
<span class="sd">        wind_altitude : int, optional</span>
<span class="sd">            Altitude of wind speed [m] variable, by default 10. Only used if</span>
<span class="sd">            ``wind_correction`` is True.</span>
<span class="sd">        skip_pet : bool, optional</span>
<span class="sd">            If True calculate temp only.</span>
<span class="sd">        reproj_method : str, optional</span>
<span class="sd">            Reprojection method from rasterio.enums.Resampling. to reproject the climate</span>
<span class="sd">            data to the model resolution. By default &#39;nearest_index&#39;.</span>
<span class="sd">        fillna_method: str, optional</span>
<span class="sd">            Method to fill NaN cells within the active model domain in the</span>
<span class="sd">            temperature data e.g. &#39;nearest&#39;</span>
<span class="sd">            By default None for no interpolation.</span>
<span class="sd">        chunksize: int, optional</span>
<span class="sd">            Chunksize on time dimension for processing data (not for saving to disk!).</span>
<span class="sd">            If None the data chunksize is used, this can however be optimized for</span>
<span class="sd">            large/small catchments. By default None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;time.starttime&quot;</span><span class="p">)</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;time.endtime&quot;</span><span class="p">)</span>
        <span class="n">timestep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;time.timestepsecs&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_pet</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pet_method</span> <span class="o">==</span> <span class="s2">&quot;debruin&quot;</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;press_msl&quot;</span><span class="p">,</span> <span class="s2">&quot;kin&quot;</span><span class="p">,</span> <span class="s2">&quot;kout&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">pet_method</span> <span class="o">==</span> <span class="s2">&quot;makkink&quot;</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;press_msl&quot;</span><span class="p">,</span> <span class="s2">&quot;kin&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">pet_method</span> <span class="o">==</span> <span class="s2">&quot;penman-monteith_rh_simple&quot;</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;temp_min&quot;</span><span class="p">,</span> <span class="s2">&quot;temp_max&quot;</span><span class="p">,</span> <span class="s2">&quot;wind&quot;</span><span class="p">,</span> <span class="s2">&quot;rh&quot;</span><span class="p">,</span> <span class="s2">&quot;kin&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">pet_method</span> <span class="o">==</span> <span class="s2">&quot;penman-monteith_tdew&quot;</span><span class="p">:</span>
                <span class="n">variables</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="s2">&quot;temp_min&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;temp_max&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;wind10_u&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;wind10_v&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;temp_dew&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;kin&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;press_msl&quot;</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s2">&quot;debruin&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;makkink&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;penman-monteith_rh_simple&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;penman-monteith_tdew&quot;</span><span class="p">,</span>
                <span class="p">]</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unknown pet method </span><span class="si">{</span><span class="n">pet_method</span><span class="si">}</span><span class="s2">, select from </span><span class="si">{</span><span class="n">methods</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">temp_pet_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">time_range</span><span class="o">=</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">),</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">single_var_as_array</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># always return dataset</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">chunksize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">chunk</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">chunksize</span><span class="p">})</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="n">dem_forcing</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">dem_forcing_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dem_forcing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
                <span class="n">dem_forcing_fn</span><span class="p">,</span>
                <span class="n">geom</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">box</span><span class="p">,</span>  <span class="c1"># clip dem with forcing bbox for full coverage</span>
                <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">],</span>
            <span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">dem_forcing</span> <span class="o">=</span> <span class="n">dem_forcing</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="n">temp_in</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">processes</span><span class="o">.</span><span class="n">meteo</span><span class="o">.</span><span class="n">temp</span><span class="p">(</span>
            <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">],</span>
            <span class="n">dem_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
            <span class="n">dem_forcing</span><span class="o">=</span><span class="n">dem_forcing</span><span class="p">,</span>
            <span class="n">lapse_correction</span><span class="o">=</span><span class="n">temp_correction</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># resample time after pet workflow</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="s2">&quot;penman-monteith&quot;</span> <span class="ow">in</span> <span class="n">pet_method</span>
        <span class="p">):</span>  <span class="c1"># also downscaled temp_min and temp_max for Penman needed</span>
            <span class="n">temp_max_in</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">processes</span><span class="o">.</span><span class="n">meteo</span><span class="o">.</span><span class="n">temp</span><span class="p">(</span>
                <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;temp_max&quot;</span><span class="p">],</span>
                <span class="n">dem_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
                <span class="n">dem_forcing</span><span class="o">=</span><span class="n">dem_forcing</span><span class="p">,</span>
                <span class="n">lapse_correction</span><span class="o">=</span><span class="n">temp_correction</span><span class="p">,</span>
                <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># resample time after pet workflow</span>
            <span class="p">)</span>
            <span class="n">temp_max_in</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;temp_max&quot;</span>

            <span class="n">temp_min_in</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">processes</span><span class="o">.</span><span class="n">meteo</span><span class="o">.</span><span class="n">temp</span><span class="p">(</span>
                <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;temp_min&quot;</span><span class="p">],</span>
                <span class="n">dem_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
                <span class="n">dem_forcing</span><span class="o">=</span><span class="n">dem_forcing</span><span class="p">,</span>
                <span class="n">lapse_correction</span><span class="o">=</span><span class="n">temp_correction</span><span class="p">,</span>
                <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># resample time after pet workflow</span>
            <span class="p">)</span>
            <span class="n">temp_min_in</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;temp_min&quot;</span>

            <span class="n">temp_in</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">temp_in</span><span class="p">,</span> <span class="n">temp_max_in</span><span class="p">,</span> <span class="n">temp_min_in</span><span class="p">],</span> <span class="n">compat</span><span class="o">=</span><span class="s2">&quot;override&quot;</span><span class="p">)</span>

        <span class="c1"># Turn temp_pet_fn into a string</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">temp_pet_fn</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">temp_pet_fn_str</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">temp_pet_fn</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;unnamed_DataFrame&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">temp_pet_fn</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="n">temp_pet_fn_str</span> <span class="o">=</span> <span class="n">temp_pet_fn</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;unnamed_Dataset&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp_pet_fn_str</span> <span class="o">=</span> <span class="n">temp_pet_fn</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_pet</span><span class="p">:</span>
            <span class="n">pet_out</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">processes</span><span class="o">.</span><span class="n">meteo</span><span class="o">.</span><span class="n">pet</span><span class="p">(</span>
                <span class="n">ds</span><span class="p">[</span><span class="n">variables</span><span class="p">[</span><span class="mi">1</span><span class="p">:]],</span>
                <span class="n">temp</span><span class="o">=</span><span class="n">temp_in</span><span class="p">,</span>
                <span class="n">dem_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;elevtn&quot;</span><span class="p">]],</span>
                <span class="n">method</span><span class="o">=</span><span class="n">pet_method</span><span class="p">,</span>
                <span class="n">press_correction</span><span class="o">=</span><span class="n">press_correction</span><span class="p">,</span>
                <span class="n">wind_correction</span><span class="o">=</span><span class="n">wind_correction</span><span class="p">,</span>
                <span class="n">wind_altitude</span><span class="o">=</span><span class="n">wind_altitude</span><span class="p">,</span>
                <span class="n">reproj_method</span><span class="o">=</span><span class="n">reproj_method</span><span class="p">,</span>
                <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                <span class="n">resample_kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="c1"># Update meta attributes with setup opt</span>
            <span class="n">opt_attr</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;pet_fn&quot;</span><span class="p">:</span> <span class="n">temp_pet_fn_str</span><span class="p">,</span>
                <span class="s2">&quot;pet_method&quot;</span><span class="p">:</span> <span class="n">pet_method</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">pet_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">opt_attr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">pet_out</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;pet&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;forcing&quot;</span><span class="p">)</span>

        <span class="c1"># make sure only temp is written to netcdf</span>
        <span class="k">if</span> <span class="s2">&quot;penman-monteith&quot;</span> <span class="ow">in</span> <span class="n">pet_method</span><span class="p">:</span>
            <span class="n">temp_in</span> <span class="o">=</span> <span class="n">temp_in</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">]</span>
        <span class="c1"># resample temp after pet workflow</span>
        <span class="n">temp_out</span> <span class="o">=</span> <span class="n">hydromt</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">processes</span><span class="o">.</span><span class="n">meteo</span><span class="o">.</span><span class="n">resample_time</span><span class="p">(</span>
            <span class="n">temp_in</span><span class="p">,</span>
            <span class="n">freq</span><span class="p">,</span>
            <span class="n">upsampling</span><span class="o">=</span><span class="s2">&quot;bfill&quot;</span><span class="p">,</span>  <span class="c1"># we assume right labeled original data</span>
            <span class="n">downsampling</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span>
            <span class="n">closed</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span>
            <span class="n">conserve_mass</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Update meta attributes with setup opt (used for default naming later)</span>
        <span class="n">opt_attr</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;temp_fn&quot;</span><span class="p">:</span> <span class="n">temp_pet_fn_str</span><span class="p">,</span>
            <span class="s2">&quot;temp_correction&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">temp_correction</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="n">temp_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">opt_attr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fillna_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">temp_out</span> <span class="o">=</span> <span class="n">temp_out</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">interpolate_na</span><span class="p">(</span>
                <span class="n">dim</span><span class="o">=</span><span class="n">temp_out</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">x_dim</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">fillna_method</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">temp_out</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;forcing&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_pet_forcing">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_pet_forcing.html#hydromt_wflow.WflowSbmModel.setup_pet_forcing">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_pet_forcing</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pet_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepare PET forcing from existig PET data.</span>

<span class="sd">        Adds model layer:</span>

<span class="sd">        * **pet**: reference evapotranspiration [mm]</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_basemaps`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pet_fn: str, xr.DataArray</span>
<span class="sd">            RasterDataset source or data for PET to be resampled.</span>

<span class="sd">            * Required variable: &#39;pet&#39; [mm]</span>

<span class="sd">        chunksize: int, optional</span>
<span class="sd">            Chunksize on time dimension for processing data (not for saving to disk!).</span>
<span class="sd">            If None the data chunksize is used, this can however be optimized for</span>
<span class="sd">            large/small catchments. By default None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing potential evapotranspiration forcing maps.&quot;</span><span class="p">)</span>

        <span class="n">starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;time.starttime&quot;</span><span class="p">)</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;time.endtime&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;time.timestepsecs&quot;</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>

        <span class="n">pet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_catalog</span><span class="o">.</span><span class="n">get_rasterdataset</span><span class="p">(</span>
            <span class="n">pet_fn</span><span class="p">,</span>
            <span class="n">geom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">],</span>
            <span class="n">time_range</span><span class="o">=</span><span class="p">(</span><span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">pet</span> <span class="o">=</span> <span class="n">pet</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="n">pet_out</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">pet</span><span class="p">(</span>
            <span class="n">pet</span><span class="o">=</span><span class="n">pet</span><span class="p">,</span>
            <span class="n">ds_like</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">mask_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">],</span>
            <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Update meta attributes (used for default output filename later)</span>
        <span class="n">pet_out</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;pet_fn&quot;</span><span class="p">:</span> <span class="n">pet_fn</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">pet_out</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;pet&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_config_variable_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;pet&quot;</span><span class="p">],</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;forcing&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.setup_cold_states">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.setup_cold_states.html#hydromt_wflow.WflowSbmModel.setup_cold_states">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_cold_states</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">timestamp</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare cold states for Wflow.</span>

<span class="sd">        To be run last as this requires some soil parameters or constant_pars to be</span>
<span class="sd">        computed already.</span>

<span class="sd">        To be run after setup_reservoirs methods and setup_glaciers to also create</span>
<span class="sd">        cold states for them if they are present in the basin.</span>

<span class="sd">        This function is mainly useful in case the wflow model is read into Delft-FEWS.</span>

<span class="sd">        Adds model layers:</span>

<span class="sd">        * **soil_saturated_depth**: saturated store [mm]</span>
<span class="sd">        * **snow_leq_depth**: snow storage [mm]</span>
<span class="sd">        * **soil_temp**: top soil temperature [C]</span>
<span class="sd">        * **soil_unsaturated_depth**: amount of water in the unsaturated store, per</span>
<span class="sd">          layer [mm]</span>
<span class="sd">        * **snow_water_depth**: liquid water content in the snow pack [mm]</span>
<span class="sd">        * **vegetation_water_depth**: canopy storage [mm]</span>
<span class="sd">        * **river_instantaneous_q**: river discharge [m3/s]</span>
<span class="sd">        * **river_h**: river water level [m]</span>
<span class="sd">        * **subsurface_q**: subsurface flow [m3/d]</span>
<span class="sd">        * **land_h**: land water level [m]</span>
<span class="sd">        * **land_instantaneous_q** or **land_instantaneous_qx** +</span>
<span class="sd">          **land_instantaneous_qy**: overland flow for kinwave [m3/s] or</span>
<span class="sd">          overland flow in x/y directions for local_inertial [m3/s]</span>

<span class="sd">        If reservoirs, also adds:</span>

<span class="sd">        * **reservoir_water_level**: reservoir water level [m]</span>

<span class="sd">        If glaciers, also adds:</span>

<span class="sd">        * **glacier_leq_depth**: water within the glacier [mm]</span>

<span class="sd">        If paddy, also adds:</span>

<span class="sd">        * **demand_paddy_h**: water on the paddy fields [mm]</span>

<span class="sd">        Required setup methods:</span>

<span class="sd">        * :py:meth:`~WflowSbmModel.setup_soilmaps`</span>
<span class="sd">        * :py:meth:`~WflowSbmModel.setup_constant_pars`</span>
<span class="sd">        * :py:meth:`~WflowSbmModel.setup_lakes`</span>
<span class="sd">        * :py:meth:`~WflowSbmModel.setup_reservoirs`</span>
<span class="sd">        * :py:meth:`~WflowSbmModel.setup_glaciers`</span>
<span class="sd">        * :py:meth:`~WflowSbmModel.setup_irrigation` or equivalent</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        timestamp : str, optional</span>
<span class="sd">            Timestamp of the cold states. By default uses the (starttime - timestepsecs)</span>
<span class="sd">            from the config.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">states_config</span> <span class="o">=</span> <span class="n">workflows</span><span class="o">.</span><span class="n">prepare_cold_states</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">config</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span>
            <span class="n">mask_name_land</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;basins&quot;</span><span class="p">],</span>
            <span class="n">mask_name_river</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;rivmsk&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_states</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>

        <span class="c1"># Update config to read the states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;model.cold_start__flag&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Update states variables names in config</span>
        <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">states_config</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">states_config</span><span class="p">[</span><span class="n">option</span><span class="p">])</span></div>


<div class="viewcode-block" id="WflowSbmModel.clip">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.clip.html#hydromt_wflow.WflowSbmModel.clip">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">clip</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">region</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">inverse_clip</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">clip_forcing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">clip_states</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">crs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4326</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clip model to region.</span>

<span class="sd">        First the staticmaps are clipped to the region.</span>
<span class="sd">        Then the staticgeoms are re-generated to match the new grid for basins and</span>
<span class="sd">        rivers and clipped for the others.</span>
<span class="sd">        Finally the forcing and states are clipped to the new grid extent.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        region : dict</span>
<span class="sd">            See :meth:`models.wflow_base.WflowBaseModel.setup_basemaps`</span>
<span class="sd">        inverse_clip: bool, optional</span>
<span class="sd">            Flag to perform &quot;inverse clipping&quot;: removing an upstream part of the model</span>
<span class="sd">            instead of the subbasin itself, by default False</span>
<span class="sd">        clip_forcing: bool, optional</span>
<span class="sd">            Flag to clip the forcing to the new grid extent, by default True</span>
<span class="sd">        clip_states: bool, optional</span>
<span class="sd">            Flag to clip the states to the new grid extent, by default True</span>
<span class="sd">        crs: int, optional</span>
<span class="sd">            Default crs of the grid to clip.</span>
<span class="sd">        **kwargs: dict</span>
<span class="sd">            Additional keyword arguments passed to</span>
<span class="sd">            :py:meth:`~hydromt.raster.Raster.clip_geom`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Reservoir maps that will be removed if no reservoirs after clipping</span>
        <span class="c1"># key: staticmaps name,  value: wflow input variable name</span>
        <span class="n">reservoir_maps</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_area_id&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_outlet_id&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_lower_id&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_storage_curve&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_rating_curve&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_area&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_initial_depth&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_demand&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_target_full_fraction&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_target_min_fraction&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_max_release&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_max_volume&quot;</span><span class="p">],</span>
            <span class="s2">&quot;meta_reservoir_mean_outflow&quot;</span><span class="p">,</span>  <span class="c1"># this is a hydromt meta map</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_outflow_threshold&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_b&quot;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_e&quot;</span><span class="p">],</span>
        <span class="p">]</span>
        <span class="n">reservoir_maps</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_WFLOW_NAMES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">reservoir_maps</span><span class="p">}</span>

        <span class="c1"># Reservoir states that will be removed if no reservoirs after clipping</span>
        <span class="c1"># key: states name,  value: wflow state variable name</span>
        <span class="n">reservoir_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span>
            <span class="s2">&quot;state.variables.reservoir_water_surface__elevation&quot;</span><span class="p">,</span>
            <span class="n">fallback</span><span class="o">=</span><span class="s2">&quot;reservoir_water_level&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">reservoir_states</span> <span class="o">=</span> <span class="p">{</span><span class="n">reservoir_state</span><span class="p">:</span> <span class="s2">&quot;reservoir_water_surface__elevation&quot;</span><span class="p">}</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span>
            <span class="n">region</span><span class="p">,</span>
            <span class="n">inverse_clip</span><span class="o">=</span><span class="n">inverse_clip</span><span class="p">,</span>
            <span class="n">clip_forcing</span><span class="o">=</span><span class="n">clip_forcing</span><span class="p">,</span>
            <span class="n">clip_states</span><span class="o">=</span><span class="n">clip_states</span><span class="p">,</span>
            <span class="n">reservoir_maps</span><span class="o">=</span><span class="n">reservoir_maps</span><span class="p">,</span>
            <span class="n">reservoir_states</span><span class="o">=</span><span class="n">reservoir_states</span><span class="p">,</span>
            <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Update reservoirs tables</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Updating reservoir tables to match clipped model.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_area_id&quot;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="c1"># no more reservoirs in the model, tables can be cleared</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">old_tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">reservoir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_MAPS</span><span class="p">[</span><span class="s2">&quot;reservoir_area_id&quot;</span><span class="p">]]</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">reservoir</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">mask_nodata</span><span class="p">())</span>
            <span class="c1"># remove nan from ids</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ids</span><span class="p">)]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">keys_to_keep</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">res_id</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
                <span class="n">res_tbl</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">data</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">res_id</span><span class="p">)</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>
                <span class="n">keys_to_keep</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">res_tbl</span><span class="p">)</span>

            <span class="c1"># Clear and add</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys_to_keep</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">old_tables</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">)</span></div>


<div class="viewcode-block" id="WflowSbmModel.upgrade_to_v1_wflow">
<a class="viewcode-back" href="../../api/_generated/hydromt_wflow.WflowSbmModel.upgrade_to_v1_wflow.html#hydromt_wflow.WflowSbmModel.upgrade_to_v1_wflow">[docs]</a>
    <span class="nd">@hydromt_step</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">upgrade_to_v1_wflow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Upgrade the model to wflow v1 format.</span>

<span class="sd">        The function reads a TOML from wflow v0x and converts it to wflow v1x format.</span>
<span class="sd">        The other components stay the same.</span>

<span class="sd">        Lakes and reservoirs have also been merged into one structure and parameters in</span>
<span class="sd">        the resulted staticmaps will be combined.</span>

<span class="sd">        This function should be followed by write_config() to write the upgraded file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">config_v0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">config_out</span> <span class="o">=</span> <span class="n">convert_to_wflow_v1_sbm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># Update the config</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_DATADIR</span> <span class="o">/</span> <span class="s2">&quot;default_config_headers.toml&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">tomllib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">config_out</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">config_out</span><span class="p">[</span><span class="n">option</span><span class="p">])</span>

        <span class="c1"># Merge lakes and reservoirs layers</span>
        <span class="n">ds_res</span><span class="p">,</span> <span class="n">vars_to_remove</span><span class="p">,</span> <span class="n">config_opt</span> <span class="o">=</span> <span class="n">convert_reservoirs_to_wflow_v1_sbm</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">config_v0</span>
        <span class="p">)</span>
        <span class="n">upgrade_lake_tables_to_reservoir_tables_v1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ds_res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Remove older maps from grid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">vars_to_remove</span><span class="p">)</span>
            <span class="c1"># Add new reservoir maps to grid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">staticmaps</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ds_res</span><span class="p">)</span>
            <span class="c1"># Update the config with the new names</span>
            <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">config_opt</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">config_opt</span><span class="p">[</span><span class="n">option</span><span class="p">])</span></div>
</div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-2"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-2"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-2"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-2">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright Deltares.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>